<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算机是如何存储数字的</title>
    <url>/p/bec1.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1.234</span>;</span><br></pre></td></tr></table></figure><p>问：a 和 b 在计算机中到底是如何存储的？</p><p>答：转为二进制？</p><p>问：转成二进制就直接存储了？</p><p>答：…</p><p>问：小数 b 如何转成二进制的？</p><p>答：…</p><p>我们日常更多的时候都在使用十进制的数，要知道我们的祖先可厉害了，应该很长一段时间都在使用 16 进制。譬如一个成语叫“半斤八两”，解释：半斤、八两轻重相等，比喻彼此不相上下。等等！半斤和八两怎么相等，对的，宋代一斤就是等于十六两，当然半斤等于八两。</p><p>都知道计算机使用的是二进制，只用 0 和 1 就能表示数字，但是计算机到底是如何解决数字存储的问题？下面分别讨论整数和小数的存储：</p><h1 id="如何存储整数"><a href="#如何存储整数" class="headerlink" title="如何存储整数"></a>如何存储整数</h1><p>假设我们现在有一个 8 位的操作系统，最高位是符号位，1 表示负数，0 表示正数，所以能表示的最大的整数区间为 <strong>11111111 ~ 01111111 =&gt; -127 ~ 127</strong>。</p><p>但是在存储表达的时候会遇到一个问题，10000000 和 00000000 两个 0 的问题，+0 和 -0 应该也是相等的，这给电路设计上带来了很多麻烦和多余的计算规则。</p><h2 id="十进制转成二进制"><a href="#十进制转成二进制" class="headerlink" title="十进制转成二进制"></a>十进制转成二进制</h2><p>简单点的记忆就是：除 2 取余再倒序。</p><ul><li>12 / 2 = 6..0</li><li>6 / 2 = 3..0</li><li>3 / 2 = 1..1</li><li>1 / 2 = 0..1</li></ul><p>0011 倒序 即为 1100，转成八位即在前面补0，则结果为 0000_1100。</p><blockquote><p>0000_1100 是 java8 中的写法，我觉得看起来比较舒服且前后连贯，_ 是为了看起来比较清楚人为添加的，后面沿用这种写法，0000_1100 = 00001100= 0000 1100<br>都是相等。</p></blockquote><h2 id="一个天才的设计师"><a href="#一个天才的设计师" class="headerlink" title="一个天才的设计师"></a>一个天才的设计师</h2><p>看了很多的文档没有找到解决这个问题的作者是谁？不管是谁反正提出了<code>补码</code>这个概念，真的是有效的解决了这个问题，不仅解决了 0 这个问题还带来了一个更大的优点，后面补充。</p><h2 id="正数的原码、反码、补码"><a href="#正数的原码、反码、补码" class="headerlink" title="正数的原码、反码、补码"></a>正数的原码、反码、补码</h2><p>正数原码 = 反码 = 补码</p><ul><li>12 的原码是 0000_1100</li><li>12 的反码是 0000_1100</li><li>12 的补码是 0000_1100</li></ul><p>这里并没有废话，尽是科学。</p><h2 id="负数的原码、反码、补码"><a href="#负数的原码、反码、补码" class="headerlink" title="负数的原码、反码、补码"></a>负数的原码、反码、补码</h2><p>反码 = 原码符号位不变其他位取反</p><p>补码 = 反码 + 1</p><ul><li>-12 的原码是 1000_1100</li><li>-12 的反码是 1111_0011</li><li>-12 的补码是 1111_0100</li></ul><h2 id="0-的存储"><a href="#0-的存储" class="headerlink" title="0 的存储"></a>0 的存储</h2><h3 id="0"><a href="#0" class="headerlink" title="+0"></a>+0</h3><ul><li>原码：0000_0000</li><li>反码：0000_0000</li><li>补码：0000_0000</li></ul><h3 id="0-1"><a href="#0-1" class="headerlink" title="-0"></a>-0</h3><ul><li>原码：1000_0000</li><li>反码：1111_1111</li><li>补码：0000_0000</li></ul><p>这里应该把前面的问题都解决了吧，补码不仅解决了 +0 和 -0 的问题，还神奇的把符号位都去掉了，计算机在运行的过程中从而可以更简单的进行运算。</p><h2 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h2><p>为了效率，计算机底层计算的时候是没有减法运算，减法运算都转成加法运算。</p><p>12 - 12 =&gt; 12 + (-12) =&gt; 0000_1100 + 1111_0100 =&gt; 0000_0000</p><ul><li>0000_110<code>0</code> + 1111_010<code>0</code> = 0 + 0 = 0</li><li>0000_11<code>0</code>0 + 1111_01<code>0</code>0 = 0 + 0 = 0</li><li>0000_1<code>1</code>00 + 1111_0<code>1</code>00 = 1 + 1 = 0 进 1</li><li>0000_<code>1</code>100 + 1111_<code>0</code>100 = 1+ 0 + 进1= 0 进 1</li><li>000<code>0</code>_1100 + 111<code>1</code>_0100 = 0+ 1 + 进1= 0 进 1</li><li>00<code>0</code>0_1100 + 11<code>1</code>1_0100 = 0+ 1 + 进1= 0 进 1</li><li>0<code>0</code>00_1100 + 1<code>1</code>11_0100 = 0+ 1 + 进1= 0 进 1</li><li><code>0</code>000_1100 + <code>1</code>111_0100 = 0+ 1 + 进1= 0 进 1</li></ul><p>因为只能存储 8 位，最后一个进 1 爆掉就剩下 0000_0000 了。</p><blockquote><p>这里都是以 8 位计算机进行举例，现在的 32 位或者 64 位计算机都是同理的。</p></blockquote><h1 id="如何存储浮点数"><a href="#如何存储浮点数" class="headerlink" title="如何存储浮点数"></a>如何存储浮点数</h1><p>相信很多人小数转成二进制都是不知道如何运算的，更别谈存储了，下面我就娓娓道来。</p><blockquote><p>文章刚开始编辑的时候将浮点数称为小数，由于发现这样不专业，其实小数不一定都是浮点数，在那个没有标准各自为政的早计算机时代其实还是有定点数，感兴趣可以看参考文档。</p></blockquote><h2 id="浮点数转成二进制"><a href="#浮点数转成二进制" class="headerlink" title="浮点数转成二进制"></a>浮点数转成二进制</h2><p>1.234 在计算机中转成二进制是按照是分整数部分和小数部分进行的，整数部分上面以前讲到，这里说下小数部分 0.234 为例：</p><p>简单点的记忆就是：乘 2 取整再顺序。</p><ul><li>0.234 * 2 = 0.468 =&gt; 整数部分为 0 =&gt; 取 0</li><li>0.468 * 2 = 0.936 =&gt; 整数部分为 0 =&gt; 取 0</li><li>0.936 * 2 = 1.872 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.872 * 2 = 1.744 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.744 * 2 = 1.488 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.488 * 2 = 0.976 =&gt; 整数部分为 0 =&gt; 取 0</li><li>0.976 * 2 = 1.952 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.952 * 2 = 1.904 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.904 * 2 = 1.808 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.808 * 2 = 1.616 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.616 * 2 = 1.232 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.232 * 2 = 0.464 =&gt; 整数部分为 0 =&gt; 取 0</li><li>…</li></ul><p>下面就不写下去了结果是 0.001110111110…，写的越长精度越高。</p><p>可见浮点数存储必将是一个头疼的问题，浮点数底层的逻辑肯定也是比整数更为复杂。</p><h2 id="IEEE754-标准"><a href="#IEEE754-标准" class="headerlink" title="IEEE754 标准"></a>IEEE754 标准</h2><p>电气电子工程师学会（英语：Institute of Electrical and Electronics Engineers）简称为 IEEE，IEEE754是专门规定浮点数该如何存储的一个标准，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。</p><h3 id="任意一个浮点数都可以表示为："><a href="#任意一个浮点数都可以表示为：" class="headerlink" title="任意一个浮点数都可以表示为："></a>任意一个浮点数都可以表示为：</h3><p>$$ V = (-1)^s \times M \times 2^E $$</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">-1</span>)^s 表示符号位，当 s=<span class="number">0</span>，V 为正数；当 s=<span class="number">1</span>，V 为负数。</span><br><span class="line">M 表示有效数字，大于等于 <span class="number">1</span>，小于 <span class="number">2</span>。</span><br><span class="line"><span class="number">2</span>^E 表示指数位。</span><br></pre></td></tr></table></figure><p>例子：V = 0.234(十进制) = 0.001110111110(二进制) = 1.110111110 * 2^-3 ，则 s=0 ，M= 1.110111110，E=-3。</p><h3 id="IEEE754-规定："><a href="#IEEE754-规定：" class="headerlink" title="IEEE754 规定："></a>IEEE754 规定：</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/General_floating_point_frac.svg/490px-General_floating_point_frac.svg.png" alt="IEEE 754浮点数的三个域
"></p><ul><li><p>对于 32 位的浮点数，最高的 1 位是符号位 s，接着的 8 位是指数 E，剩下的 23 位为有效数字 M。</p></li><li><p>对于 64 位的浮点数，最高的 1 位是符号位 s，接着的 11 位是指数 E，剩下的 52 位为有效数字 M。</p></li></ul><h3 id="IEEE754-还有一些特殊的规定："><a href="#IEEE754-还有一些特殊的规定：" class="headerlink" title="IEEE754 还有一些特殊的规定："></a>IEEE754 还有一些特殊的规定：</h3><h4 id="针对-M"><a href="#针对-M" class="headerlink" title="针对 M"></a>针对 M</h4><p>由于 1&lt;= M &lt;=2 ，所以 M 始终为 1.xxxx 形式，xxxx 表示小数，那些对于计算机底层严苛的设计师这时候又要将 1 这一位舍掉，只保留 xxxx 部分，这样的好处是可以多储存一位有效数字。</p><h4 id="针对-E"><a href="#针对-E" class="headerlink" title="针对 E"></a>针对 E</h4><p>由于 E 是一个 8 位的无符号存储，只能表示 0 ~ 255，现实中的指数还存在负数，所以规定：<strong>E必须再加上一个中间数，对于 8 位的 E，这个中间数是 127；对于 11 位的 E，这个中间数是 1023</strong>，这样就可以将指数的表达范围扩大到 <code>-127 ~ +128</code> 和 <code>-1023 ~ +1024</code>。</p><blockquote><p>实际中的取值范围是 <strong>-126~+127</strong>，-127 和 128 被用作特殊值处理，双精度同理。</p></blockquote><blockquote><p>阮一峰的博客中写的是 <em>减去一个中间数</em> 应该是有误的。</p></blockquote><p>举个例子，如果 E=17，则 17+127 =144 ，实际的存储指为 144。</p><p>针对 E 还有一些特殊值的情况</p><ol><li>如果指数 E 是 0 并且尾数的小数部分是 0，这个数是 ±0（和符号位相关）。</li><li>如果指数 E 是 1 并且尾数的小数部分是0，这个数是±∞（同样和符号位相关）</li><li>如果指数 E 是 1 并且尾数的小数部分非0，这个数表示为不是一个数（NaN）。</li></ol><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>V = 0.234(十进制) = 0.00111011111001110110110010(二进制) = 1.11011111001110110110010 * 2^-3 ，则 s=0 ，M= 1.110111110，E=-3。</p><p>根据 IEEE754 标准转化 :</p><blockquote><p>以 单精度为例</p></blockquote><p>s 不变<br>E=-3+127=124(十进制) = 0111_1100(二进制)</p><p>M=110_1111_1001_1101_1011_0010</p><p>结果将他们连接 0_0111_1100_110_1111_1001_1101_1011_0010(s_E_M)</p><p>可以<a href="http://www.speedfly.cn/tools/hexconvert/" target="_blank" rel="noopener">在线校验结果</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇文章详细介绍了计算机如何存储整数以及浮点数，个人也是从朦胧状态到理解透彻，参考了众多大佬的文章，在此表示感谢。有问题的朋友可以通过邮箱联系到我 <code>jake.zou.me@gmail.com</code>。</p><p>计算机之美妙不可言啊！</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/61628231" target="_blank" rel="noopener">计算机存储整数和小数</a></li><li><a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a></li><li><a href="https://medium.com/@saltedfishcaptain/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B4%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A5-%E8%A1%A5%E7%A0%81-%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%82%A8-ed8f6654eb3a" target="_blank" rel="noopener">计算机中整数为什么以补码形式存储</a></li><li><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">维基百科.IEEE754</a></li><li><a href="https://www.zhihu.com/question/19848808" target="_blank" rel="noopener">为什么叫浮点数?</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
  </entry>
  <entry>
    <title>北京时间</title>
    <url>/p/e249.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>北京时间？对，想说的就是北京时间。</p><p>首先北京时间是位于东八区的东经 120 度的标准时间，北京的经度是 116.4，北京时间与北京当地时间相差 14 分钟 28 秒。</p><p>其次是北京时间的国家授时中心位于陕西省蒲城县，陕西蒲城县位于东七区。中国幅员辽阔，东西跨度 5000 公里，国家授时中心每秒钟以无线电波的形式向半径 3000 公里的中国大地发送标准的北京时间。</p><h3 id="一句话小结"><a href="#一句话小结" class="headerlink" title="一句话小结"></a>一句话小结</h3><p>国家授时中心在蒲城县(东七区)发送北京时间(东八区)给到全国校准时间。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><p><a href="https://zh.wikipedia.org/zh-hans/%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">维基百科.北京时间</a></p></li><li><p><a href="https://new.qq.com/omn/20180622/20180622G17DC9.html" target="_blank" rel="noopener">“北京时间”确认过眼神——陕西就是那个对的地方</a></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>科普</category>
      </categories>
  </entry>
  <entry>
    <title>博客加载速度优化</title>
    <url>/p/6d58.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>博客加载一直很慢，昨晚折腾的事情如下：</p><h3 id="netlify"><a href="#netlify" class="headerlink" title="netlify"></a>netlify</h3><p>对接了 <a href="https://app.netlify.com/" target="_blank" rel="noopener">netlify</a>，可以试试打开他们家的主页，没有一分钟都加载不出来，比用 github page 都要慢，放弃！</p><blockquote><p>netlify 异常强大，后台可以直接注入 script，几行代码就可以搭建一套 cms。</p></blockquote><h3 id="zeit"><a href="#zeit" class="headerlink" title="zeit"></a>zeit</h3><ul><li>后来又搜索到一家服务商 <a href="https://zeit.co/" target="_blank" rel="noopener">zeit.co</a> 也提供了静态页部署的功能，速度那是杠杠的，基本秒开确实快，但是每次部署都要手动去网页上点击一个<strong>发布</strong>，这是一个免费就需要折磨的节奏吗？</li></ul><blockquote><p>netlify精简版</p></blockquote><h3 id="bootcdn"><a href="#bootcdn" class="headerlink" title="bootcdn"></a>bootcdn</h3><ul><li>还是老老实实的国内 coding 加国外 github，但是可以配置 js 的引用地址，测试了几个 cdn，还是 <a href="https://www.bootcdn.cn" target="_blank" rel="noopener">bootcdn</a> 快，将 <code>/next/_config.yml</code> 下面的 vendors 修改如下：</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 2.1.3</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">//cdn.bootcss.com/jquery/2.1.3/jquery.min.js</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 2.1.5</span></span><br><span class="line"><span class="comment"># See: http://fancyapps.com/fancybox/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="string">//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js</span></span><br><span class="line"><span class="attr">fancybox_css:</span> <span class="string">//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.0.6</span></span><br><span class="line"><span class="comment"># See: https://github.com/ftlabs/fastclick</span></span><br><span class="line"><span class="attr">fastclick:</span> <span class="string">//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.9.7</span></span><br><span class="line"><span class="comment"># See: https://github.com/tuupola/jquery_lazyload</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="string">//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.2.1</span></span><br><span class="line"><span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">velocity:</span> <span class="string">//cdn.bootcss.com/velocity/1.2.1/velocity.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.2.1</span></span><br><span class="line"><span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">velocity_ui:</span> <span class="string">//cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 0.7.9</span></span><br><span class="line"><span class="comment"># See: https://faisalman.github.io/ua-parser-js/</span></span><br><span class="line"><span class="attr">ua_parser:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 4.6.2</span></span><br><span class="line"><span class="comment"># See: http://fontawesome.io/</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1</span></span><br><span class="line"><span class="comment"># https://www.algolia.com</span></span><br><span class="line"><span class="attr">algolia_instant_js:</span></span><br><span class="line"><span class="attr">algolia_instant_css:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.0.2</span></span><br><span class="line"><span class="comment"># See: https://github.com/HubSpot/pace</span></span><br><span class="line"><span class="comment"># Or use direct links below:</span></span><br><span class="line"><span class="comment"># pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="comment"># pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line"><span class="attr">pace:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="attr">pace_css:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/themes/black/pace-theme-minimal.min.css</span></span><br></pre></td></tr></table></figure><p>打开速度明显可以提升。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>此处没有更多小结，域名没法备案啊，没有暂住证没有居住证👿….</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>判断一个整数是不是2的整数次方</title>
    <url>/p/c03.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>今天看到一个这样的题目：<strong>判断一个整数是不是 2 的整数次方?</strong></p><p>大学竞赛好像还真见过，现在已经忘得一干二净了。现在看到一个解法还真的挺溜。</p><p>首先按照二进制找规律</p><ul><li>2 =&gt; 10</li><li>4 =&gt; 100</li><li>8 =&gt; 1000</li><li>16=&gt; 10000</li><li>…</li></ul><p>下面就不写了，第一位为 1 后面全是 0，这样的数就是 2 的整数次方数。</p><p>二进制算法中还有一个规律</p><ul><li><p>8 =&gt; 1000</p><p>7 =&gt; 0111</p></li></ul><ul><li><p>16=&gt; 10000</p><p>15=&gt; 01111</p></li></ul><p>N 和 N-1 的区别是最低位的 1 变成 0，最低位后面的 0 全变成 1，并且 N&amp;(N-1)可以恰好为 0。</p><p>如果 N=1100，N&amp;(N-1) = 1100&amp;1011 != 0，所以 N 不是 2 的整数次数。</p><p>综上所述 ：判断一个整数是不是 2 的整数次方，只需要判断 N&amp;(N-1) 是否为 0。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>macbook pro 时间不准</title>
    <url>/p/303.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>从春节至现在3月份了，我还没有抢到口罩。🙄🙄</p><p>每次准点抢的时候我对一下我的电脑，发现时间总是慢 10s 左右，我在网上搜索真的有很多人和我一样，在某个知乎帖子下面有个大佬给了一个建议，可以通过定时任务去执行一个命令强制从更新苹果的服务器校准时间。我觉得他的想法相当好，而且我很变态的让系统每小时执行一次校准时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo cron -e</span><br><span class="line">---</span><br><span class="line">55 * * * * sudo /usr/bin/sntp -sS time.apple.com</span><br></pre></td></tr></table></figure><p>这里的添加定时任务必须添加 sudo ，否则任务里面有 sudo 其实是不执行的。测试了很多次。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul><li><a href="https://www.zhihu.com/question/37349985" target="_blank" rel="noopener">知乎热帖</a></li><li><a href="https://time.is/zh/" target="_blank" rel="noopener">时间校准网站</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>VPC内网通信</title>
    <url>/p/bd3e.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>前面<a href="https://blog.zoulux.top/p/79fa.html">有篇文章</a>记录了我在迁移 redis 过程。但是在总结的时候对解决问题中的阿里云内网地址充满了兴趣，阿里云到底是怎么实现内网互联？容器中为什么也可以访问阿里云内网？</p><h1 id="阿里云内网互联"><a href="#阿里云内网互联" class="headerlink" title="阿里云内网互联"></a>阿里云内网互联</h1><p>要说清阿里云的整个 vpc 体系我现在怕是做不到，但是我本着根据实际现象做联想，我应该可以，至少可以在较长时间内可以满足我的知识图谱，如果哪天要是有机会碰上王坚博士，不对叫王坚院士，再和他一探究竟。</p><p>很多科学也是，在很长一段时间内都不会被证伪，说明这个科学理论是正确的，如果很长时间之后被证伪，说明证伪的部分也是这个科学理论的一部分，将知识串联起来比知识的真像更重要，发现了前面不对，也不必完全推翻，将 bug 修复了，将新的知识替换上去，将新老知识串联起来。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>概念这块我查阅了阿里云官方文档，以及查看了很多相关博客。</p><h3 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h3><p>专有网络（Virtual Private Cloud，简称VPC）是用户独有的云上私有网络，用户可以将购买的服务器、数据库、负载均衡都添加到这个专有网络，以达到内部互联互通。</p><p><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/1309756751/p2749.png" alt="专有网络"></p><p>阿里云建议一个地域下面只需要一个 VPC，不同地域之间的 VPC 是可以通过 vpn 或者隧道技术联通。</p><h4 id="vpc-原理"><a href="#vpc-原理" class="headerlink" title="vpc 原理"></a>vpc 原理</h4><p>基于目前主流的隧道技术，专有网络隔离了虚拟网络。每个VPC都有一个独立的隧道号，一个隧道号对应着一个虚拟化网络。一个VPC内的ECS（Elastic Compute Service）实例之间的传输数据包都会加上隧道封装，带有唯一的隧道ID标识，然后送到物理网络上进行传输。不同VPC内的ECS实例因为所在的隧道ID不同，本身处于两个不同的路由平面，所以不同VPC内的ECS实例无法进行通信，天然地进行了隔离。</p><p>基于隧道技术和软件定义网络（Software Defined Network，简称SDN）技术，阿里云的研发在硬件网关和自研交换机设备的基础上实现了VPC产品。</p><h4 id="vpc-逻辑架构"><a href="#vpc-逻辑架构" class="headerlink" title="vpc 逻辑架构"></a>vpc 逻辑架构</h4><p>如下图所示，VPC包含交换机、网关和控制器三个重要的组件。交换机和网关组成了数据通路的关键路径，控制器使用自研的协议下发转发表到网关和交换机，完成了配置通路的关键路径。整体架构里面，配置通路和数据通路互相分离。交换机是分布式的结点，网关和控制器都是集群部署并且是多机房互备的，并且所有链路上都有冗余容灾，提升了VPC产品的整体可用性。<br><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/2428/15662966115013_zh-CN.png" alt=""></p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器（VRouter）是专有网络的枢纽。路由器可以连接专有网络的各个交换机，同时也是连接专有网络与其它网络的网关设备。路由器根据路由条目来转发网络流量。这里路由器是一个抽象概念。</p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>路由表（Route Table）是指路由器上管理路由条目的列表，路由表绑定了VPC和交换机 。可以想象成 excel 里面的一张张 sheet</p><h4 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a>路由条目</h4><p>路由条目（Route Entry）是指路由表中的每一条路由信息。路由条目定义了通向指定目标网段的网络流量的下一跳地址。路由条目包括系统路由和自定义路由两种类型。可以想象成 excel 里面的一张 sheet 中的每一行。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机（VSwitch）是组成专有网络的基础网络设备。交换机可以连接不同的云资源。在专有网络内创建云资源时，必须指定云资源所连接的交换机。默认一个可用区会有一台交换机，每台交换机都是 vpc 所定义的一个子网。</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关其实也是一个抽象概念，可以想象中现实中的海关，如果一个用户不出国，就接触不到海关，但是一个用户想要出国，就必须从海关通过，网关管理着内外网的联系。其实我一直不太理解路由器和网关的关系，觉得他们有关系但是不知道到底是怎样的关系，直到我看到知乎上的一段回复：</p><blockquote><p>首先‘网关’一个大概念，不具体特指一类产品，只要连接两个不同的网络的设备都可以叫网关；而‘路由器’一般特指能够实现路由寻找和转发的特定类产品，路由器很显然能够实现网关的功能。当然电信行业说的‘路由器’又和家用的‘路由器’两个概念，这个暂且不表。回到题目中你说问的默认网关是什么，默认网关事实上不是一个产品而是一个网络层的概念，PC本身不具备路由寻址能力，所以PC要把所有的IP包发送到一个默认的中转地址上面进行转发，也就是默认网关。这个网关可以在路由器上，可以在三层交换机上，可以在防火墙上，可以在服务器上，所以和物理的设备无关。</p></blockquote><p>简单一句话总结就是：</p><p>网关是连接了两个网络的设备，路由器是连接了局域网和广域网，<strong>路由器算网关</strong>。</p><h4 id="NET-网关"><a href="#NET-网关" class="headerlink" title="NET 网关"></a>NET 网关</h4><p>这里我特地想介绍一下阿里云 <code>net 网关</code>，因为这个设备我一直和网关混淆，阿里云整套系统都是基于软件定义，这里的 <code>net网关</code>其实就是将内(网)外的端口或者地址转发的到外(内)网一个设备。</p><p>net 网关提供 SNAT 和 DNAT 功能，</p><ul><li>DNAT是NAT网关上的一张配置表，用于NAT网关上的DNAT功能配置。可以实现端口映射（Port mapping）和IP映射（IP mapping），将NAT网关上的公网IP映射给ECS实例。</li></ul><ul><li>SNAT是NAT网关上的一张配置表，用于NAT网关上的SNAT功能配置。可以以交换机和ECS为粒度进行SNAT规则配置，以交换机为粒度：指定交换机下的所有ECS实例均使用指定的公网IP访问互联网，以ECS为粒度：指定的ECS实例使用指定的公网IP访问互联网。</li></ul><p>可以看到 net 网关也是网关的一种而已。</p><h3 id="弹性IP"><a href="#弹性IP" class="headerlink" title="弹性IP"></a>弹性IP</h3><p>弹性公网IP（Elastic IP Address，简称EIP）是可以独立购买和持有的公网IP地址资源。EIP可绑定到专有网络类型的ECS实例、专有网络类型的私网SLB实例、专有网络类型的辅助弹性网卡、NAT网关和高可用虚拟IP上。</p><p>EIP是一种NAT IP。它实际位于阿里云的公网网关上，通过NAT方式映射到了被绑定的资源上。和云资源绑定后，云资源可以通过EIP与公网通信.。</p><p>可以看出 EIP 也完全是一种抽象的概念，世界上本没有<code>弹性 IP</code>，阿里云这样的公司真是厉害，通过将阿里云公网上的 ip 以 net网关的形式映射到用户的绑定的资源上。</p><h2 id="补充网络协议"><a href="#补充网络协议" class="headerlink" title="补充网络协议"></a>补充网络协议</h2><p><img src="/images/pasted-12.png" alt="upload successful"></p><h1 id="容器内访问阿里云内网"><a href="#容器内访问阿里云内网" class="headerlink" title="容器内访问阿里云内网"></a>容器内访问阿里云内网</h1><blockquote><p>这部分内容有个前提，就是在阿里云的 ECS 里面已经可以和 rds 之类的服务连通。</p></blockquote><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>一般我们获得阿里云内网地址的时候，都会得到 <code>rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</code> 类似的链接。</p><p>这里使用 <a href="https://man.linuxde.net/dig" target="_blank" rel="noopener">dig</a> 命令获取对应内网地址所对应的 ip。</p><p>缺少 dig 命令的？ubuntu 系统</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install dnsutils</span><br></pre></td></tr></table></figure><h3 id="宿主机测试访问内网地址"><a href="#宿主机测试访问内网地址" class="headerlink" title="宿主机测试访问内网地址"></a>宿主机测试访问内网地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.8-Ubuntu &lt;&lt;&gt;&gt; rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48397</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com. 60 IN	A 192.168.0.250</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 127.0.0.53<span class="comment">#53(127.0.0.53)</span></span><br><span class="line">;; WHEN: Thu Dec 19 16:24:40 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 93</span><br></pre></td></tr></table></figure><p>可以看到这里的 dns 是 <code>127.0.0.53</code> ，这个地址 ubuntu 默认的 dns 的 ip，<br><code>rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</code> 对应的 ip 是<br><code>192.168.0.250</code>。</p><h3 id="容器内测试访问内网地址"><a href="#容器内测试访问内网地址" class="headerlink" title="容器内测试访问内网地址"></a>容器内测试访问内网地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.5-P4-5.1-Debian &lt;&lt;&gt;&gt; rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 57655</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">; COOKIE: 6cc1d7afb7bf77ce8f82d65a5dfb3603e95f17f7eeb8a82a (good)</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com. 60 IN	A 192.168.0.250</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 127.0.0.11<span class="comment">#53(127.0.0.11)</span></span><br><span class="line">;; WHEN: Thu Dec 19 08:34:11 UTC 2019</span><br><span class="line">;; MSG SIZE  rcvd: 121</span><br></pre></td></tr></table></figure><p>这里的 dns 是 <code>127.0.0.11</code>，这个是 docker 默认的 dns 所对应的 ip，但是这里的得到的 ip 还是 <code>192.168.0.250</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实这里的测试结果还很令我惊奇的，为什么在容器里面也可以得到和宿主机同样的 ip 呢？以前我也一直这样使用，直到上次迁移 redis 我才想起问为什么。</p><p>容器中的DNS名称解析优先级顺序为：</p><ul><li>内置DNS服务器127.0.0.11。</li><li>通过–dns等参数为容器配置的DNS服务器。</li><li>docker守护进程的–dns服务配置（默认为8.8.8.8和8.8.4.4）</li><li>宿主机上的DNS设置。</li></ul><p>由于默认情况是没有第二步和第三步，所以在向 docker 内部 dns 服务器请求 <code>rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</code> 的时候，内部 dns 是无法给到地址的，所以这个地址又交回到宿主机了。宿主机也不知道地址，随即通过交换机递交到路由器，路由器当然是知道这个地址是多少，就将 <code>192.168.0.250</code> 返回了。我们在购买 rds 服务的时候需要选择一个可用区，而这个 rds 就是挂在这个可用区所对应的交换机上。</p><h2 id="继续探讨"><a href="#继续探讨" class="headerlink" title="继续探讨"></a>继续探讨</h2><p>这里容器内已经获得 rds 所对应的 ip 了，但是在容器内如何能访问到 <code>192.168.0.250</code> 这个地址呢？<br>我们可以先获取容器的 ip 地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect <span class="variable">$CONTAINER</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="string">"Gateway"</span>: <span class="string">"192.168.64.1"</span>,</span><br><span class="line"><span class="string">"IPAddress"</span>: <span class="string">"192.168.64.5"</span>,</span><br></pre></td></tr></table></figure><p>现在问题变成 <code>192.168.64.5</code> 想去连接 <code>192.168.0.250</code>。<br><code>192.168.64.5</code> 发现自己和 <code>192.168.0.250</code> 不在一个子网内.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ route -n</span><br><span class="line"></span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.0.253   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">192.168.16.0    0.0.0.0         255.255.240.0   U     0      0        0 br-317146d44671</span><br><span class="line">192.168.32.0    0.0.0.0         255.255.240.0   U     0      0        0 br-dcf4529fa753</span><br><span class="line">192.168.48.0    0.0.0.0         255.255.240.0   U     0      0        0 br-a5d4178cf1f7</span><br><span class="line">192.168.64.0    0.0.0.0         255.255.240.0   U     0      0        0 br-568ac4a0657a</span><br><span class="line">192.168.200.0   0.0.0.0         255.255.255.0   U     0      0        0 docker0</span><br></pre></td></tr></table></figure><p>把请求交给了 <code>192.168.0.0</code> 处理，这样 <code>192.168.64.5</code> 终于连上了 <code>192.168.0.250</code> 。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://help.aliyun.com/document_detail/34221.html?spm=a2c4g.11186623.6.546.599b6c16I4cskX" target="_blank" rel="noopener">阿里云专有网络 VPC文档</a></li><li><a href="http://dockone.io/article/2316" target="_blank" rel="noopener">docker内置dnsserver工作机制</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>vpc</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云redis服务迁移记录</title>
    <url>/p/79fa.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><h2 id="总有那么一段废话"><a href="#总有那么一段废话" class="headerlink" title="总有那么一段废话"></a>总有那么一段废话</h2><p>因为某个项目前期数据量比较小，所以就直接使用 docker 起的 redis 服务，由于现在的业务规模上升，原有的 reids 服务不能进行数据监控以及不方便数据管理和维护，所以在阿里云单独买了一个云 redis 服务，我前期为了安全，也没有将 redis 服务的端口映射到宿主机，所以给我的迁移也带来了挑战。</p><h2 id="正式步骤"><a href="#正式步骤" class="headerlink" title="正式步骤"></a>正式步骤</h2><h3 id="开启宿主机端口映射"><a href="#开启宿主机端口映射" class="headerlink" title="开启宿主机端口映射"></a>开启宿主机端口映射</h3><p>在 <code>docker-compose.yml</code> 文件下修改 <strong>redis</strong> service，增加 ports 字段。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">redis:</span><br><span class="line">  container_name: redis-pro</span><br><span class="line">  image: redis:<span class="number">4.0</span><span class="number">.10</span></span><br><span class="line">  sysctls:</span><br><span class="line">    net.core.somaxconn: <span class="number">65535</span></span><br><span class="line">  ports:</span><br><span class="line">    - <span class="string">"6380:6379"</span></span><br><span class="line">  networks:</span><br><span class="line">    - backend</span><br><span class="line">  restart: always</span><br></pre></td></tr></table></figure><p>更新 redis 服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up -d redis</span><br></pre></td></tr></table></figure><p>查看端口映射状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose ps</span><br><span class="line"></span><br><span class="line">redis   docker-entrypoint.sh redis ...   Up      0.0.0.0:6380-&gt;6379/tcp</span><br></pre></td></tr></table></figure><h3 id="开启阿里云-DTS-服务"><a href="#开启阿里云-DTS-服务" class="headerlink" title="开启阿里云 DTS 服务"></a>开启阿里云 DTS 服务</h3><p>选择和宿主机以及 redis 在同一个地域的<code>数据传输服务</code>，理论上这样的服务会延迟更低，稳定性更好。</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p>分别配置好源库信息和目标库信息，阿里云还是很贴心，测试连接如果都是通过就可以下一步下一步了。</p><p>等待到全量更新为 「100%」就说明本次迁移已完成很大一部分了。</p><blockquote><p>为什么要使用 DTS 服务，而不是自己将 redis 保存成文件，导入到新的 redis 服务呢？主要是 DTS 服务支持增量更新，后面可能会持续有数据的读写覆盖等，这些 DTS 服务会一条龙服务解决掉。</p></blockquote><h3 id="配置-redis-地址"><a href="#配置-redis-地址" class="headerlink" title="配置 redis 地址"></a>配置 redis 地址</h3><h4 id="开启云-reids-外网地址"><a href="#开启云-reids-外网地址" class="headerlink" title="开启云 reids 外网地址"></a>开启云 reids 外网地址</h4><blockquote><p>实际过程中我是直接用的内网地址，发现内网根本连不上。</p></blockquote><p>这里直接说外网地址，保证系统先调通，这里注意两点。</p><ul><li>购买的 reids 版本，阿里云 Redis4.0 及以上版本密码格式为“账号:密码”，其他版本就只有密码，没有账户概念，当然我是追求极致体验全部选最新。</li><li>点击申请外网链接，是需要等待 20 秒左右才能使用的，不是立即生效。</li></ul><p><img src="/images/pasted-9.png" alt="upload successful"></p><h4 id="修改-web-服务中的-redis-地址"><a href="#修改-web-服务中的-redis-地址" class="headerlink" title="修改 web 服务中的 redis 地址"></a>修改 web 服务中的 redis 地址</h4><p>因为我在使用 swoft，直接修改 redis 的配置文件 <code>config/pro/redis.php</code>。</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p>将代码部署到线上，发现服务正常运行。如果你能接受外网访问，那么到这里就可以结束了，我一个追求极致的人，当然是不能容忍线上服务就这么暴露在外网中，即使有白名单机制。</p><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><p>主要是 redis 配置这块碰到了一个大坑，和阿里云的技术客服来来去去聊了一天，他们每半小时或者一个小时才给我回复一条消息，到晚上才给我解决，感觉白天的阿里云客服技术水平完全是值班的，一些很简单的问题和我绕了半天，结果道歉说他弄错了，是在怀疑我不专业吗？不过最后那个技术客服一下就能抓住重点，问题一下就解决了。给了我一个文档也不知道是哪位大佬的博客，是这位客服自己的么？🙃🙃</p><p>我在使用内网地址的时候一直会反馈一个错误。发现 redis 连接一直超时。<br>然后我去 ping 了一下他的地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping r-xxxxxxxxxx.redis.rds.aliyuncs.com</span><br><span class="line"></span><br><span class="line">Destination Host Unreachable</span><br></pre></td></tr></table></figure><p>给我反馈的 <code>Destination Host Unreachable</code> 就是这个错误，简单的说就是 dns 解析不到，网络无法连通。我开始以为这个可能是阿里云故意关闭了 ping 所需要的 icmp 包。</p><p>我就使用 reids 客户端去实验，参数 h 是地址，参数 a 是密码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h r-xxxxxxxxxx.redis.rds.aliyuncs.com -a xxxxx</span><br><span class="line"></span><br><span class="line">Name or service not known</span><br></pre></td></tr></table></figure><p>发现这个内网真的访问不上，和阿里云客服百般沟通之后，提供的解决方案来看，是通信的网卡走错了。</p><h4 id="配置-docker"><a href="#配置-docker" class="headerlink" title="配置 docker"></a>配置 docker</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi  /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>daemon.json 文件里面增加一个网段信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"bip"</span>: <span class="string">"192.168.200.1/24"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 docker 服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><p>但是我这里重启 docker 服务还是报错了，最后不得已重启了机器。</p><p>ping 了一下地址确实是能 ping 到，重新配置了 reids 的内网地址，一切都恢复正常了。</p><h3 id="关闭阿里云-DTS-服务"><a href="#关闭阿里云-DTS-服务" class="headerlink" title="关闭阿里云 DTS 服务"></a>关闭阿里云 DTS 服务</h3><p>因为 DTS 服务是收费服务，线上既然可以正常运行，就可以先暂停服务，然后释放掉就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个总结我研究了好几天，感觉还是不要总结了，因为有些知识还是需要我去发掘，因为对于这个内网地址我实在有点不太明白，它的原理是什么，为什么我在使用 <code>dns 8.8.8.8</code> 的时候，还是可以解析到内网地址?</p><p>后面我会补充一篇内容专门讨论阿里云的内网技术。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.chenxie.net/archives/2049.html" target="_blank" rel="noopener">阿里大佬提供的解决方案</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>reids</tag>
        <tag>redis迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>swoft时间戳问题</title>
    <url>/p/1da.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>swoft 这个框架我是越用越烦了，缺少了关联模型的 Eloquent 用起来总是蹩手蹩脚，下次让我选择一个 swoole 框架我一定会选择 <a href="https://www.hyperf.io/" target="_blank" rel="noopener">hyperf</a>。</p><p>关于 swoft 自动写入时间戳，在刚开始一直没有弄对，最早是怎么都不更新，后来我发现可以用 int 类型，所以数据库里面的 创建时间和更新时间都是 int 类型，但是我这边收到的需求是要根据年月进行筛选，int 类型就要搞死我。</p><p><a href="https://en.swoft.org/docs/2.x/zh-CN/db/model.html#%E8%87%AA%E5%8A%A8%E5%86%99%E5%85%A5%E6%97%B6%E9%97%B4%E6%88%B3" target="_blank" rel="noopener">官网介绍自动写入时间戳</a>，我觉得作者没有说清楚，到底应该怎么弄，我在自己的摸索下，发现只需要把时间戳声明 string 类型即可解决。</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>数据库中的类型记得声明成 timestamp 类型</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p>头疼🙃🙃</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>swoft</category>
      </categories>
  </entry>
  <entry>
    <title>v2ray入门</title>
    <url>/p/a001.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>前端时间朋友一直在安利 v2ray，他们公司 CTO 是个搭梯高手，各种 ss v2ray 给他们免费使用实在不要太爽。我很早就听说过 v2ray，但是也一直没有尝试过，感觉每次看到 v2ray 教程都是很大篇幅，也没什么耐心去看，就像上个网搞这么麻烦，但是作为一个资深 docker 使用者来说，没有什么程序是一个 docker 镜像解决不了的，如果有那就是镜像写的不好。</p><p>无论这个东西怎么复杂，我们先让车上路，废话少说。</p><h2 id="安装-v2ray-服务端"><a href="#安装-v2ray-服务端" class="headerlink" title="安装 v2ray 服务端"></a>安装 v2ray 服务端</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>docker 安装什么的我直接略过了，都是一句话的事，直接进入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull v2ray/official</span><br></pre></td></tr></table></figure><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>这边我在官网下载了一个配置，这应该是最简配置了吧。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">10086</span>, <span class="comment">// 服务器监听端口，必须和上面的一样</span></span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"clients"</span>: [&#123; <span class="string">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"outbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将文件存储为 <code>config.json</code> 即可。</p><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p>很想给官方镜像写个 readme，啥也没有，全靠自己悟性呢，这是？</p><p>我看了一下它的 <a href="https://hub.docker.com/r/v2ray/official/dockerfile" target="_blank" rel="noopener">dockerfile</a>， 看到他 copy 了一个文件 <code>COPY config.json /etc/v2ray/config.json</code>，看到这稳了，我只需要把外面的文件挂载到容器里面就好了。配置文件中端口是 10086，所以这里直接映射到宿主机上。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --name=v2 -p 10086:10086 -v <span class="variable">$PWD</span>:/etc/v2ray -d  v2ray/official</span><br></pre></td></tr></table></figure><h2 id="安装-v2ray-客户端"><a href="#安装-v2ray-客户端" class="headerlink" title="安装 v2ray 客户端"></a>安装 v2ray 客户端</h2><h3 id="准备配置文件-1"><a href="#准备配置文件-1" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>客户端这块也是下载一个配置文件，存储为 <code>config.json</code> 即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">1080</span>,  <span class="comment">// SOCKS 代理端口，在浏览器中需配置代理并指向这个端口</span></span><br><span class="line">    <span class="string">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"socks"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"udp"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"outbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"vnext"</span>: [&#123;</span><br><span class="line">        <span class="string">"address"</span>: <span class="string">"server"</span>, <span class="comment">// 服务器地址，请修改为你自己的服务器 ip 或域名</span></span><br><span class="line">        <span class="string">"port"</span>: <span class="number">10086</span>,  <span class="comment">// 服务器端口</span></span><br><span class="line">        <span class="string">"users"</span>: [&#123; <span class="string">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span> &#125;]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="string">"tag"</span>: <span class="string">"direct"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"routing"</span>: &#123;</span><br><span class="line">    <span class="string">"domainStrategy"</span>: <span class="string">"IPOnDemand"</span>,</span><br><span class="line">    <span class="string">"rules"</span>: [&#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">      <span class="string">"ip"</span>: [<span class="string">"geoip:private"</span>],</span><br><span class="line">      <span class="string">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mac-、"><a href="#mac-、" class="headerlink" title="mac 、"></a>mac 、</h3><p>github 上面直接下载 <a href="https://github.com/yanue/V2rayU/releases" target="_blank" rel="noopener">V2rayU客户端</a> 这个客户端，我目前在用觉得还不错。</p><p>依次配置：服务器设置 - 导入模式 - 选择文件 - 选择 config.json ，</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>然后去手动模式里面检查检查，如果没有问题差不多就搞定了。</p><h3 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h3><p>手机上使用 <code>shadowrocket</code> ，图标是一个小火箭，中国区的 App Store 现在应该下载不到了，可以去 google 上搜索大佬提供的 App Store 香港的账户，上面是可以下载。</p><p>打开 shadowrocket，选择右上角添加，然后底部打开 <code>扫码二维码</code>，mac 上面的 V2rayU 选择分享二维码接口完成 shadowrocket 添加。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器打开 <code>google.com</code> ，又可以愉快的看国外的文档了。如果遇到问题，可以联系我，v2ray 基础功能差不多是可以的，更复杂的功能我也继续在看文档。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>有个小技巧可以提高 v2ray 的效率，打开 mux 接口，这个功能也是 v2ray 独有的。</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.v2ray.com/" target="_blank" rel="noopener">v2ray 官网</a></li><li><a href="https://hub.docker.com/r/v2ray/official" target="_blank" rel="noopener">docker 镜像</a></li><li><a href="https://github.com/yanue/V2rayU" target="_blank" rel="noopener">V2rayU</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>swoft 入门</title>
    <url>/p/aa25.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对比了几个基于 swoole 的框架，swoft 在 github 上面 star 数量遥遥领先的，所以准备基于 swoft 开始一个小项目。</p><h2 id="swoft目录"><a href="#swoft目录" class="headerlink" title="swoft目录"></a>swoft目录</h2><p>对于一个 laravel 老玩家，看这个目录还是比较简单的，env 配置文件使用的时候 copy 一遍，不同的是他这边配置是分为 env、config、bean 三部分，主要开发的代码在 app 下，bin 下放了一些可执行文件。<br><img src="/images/pasted-2.png" alt="upload successful"></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>我是将它作为一个 http 的服务，所以最重要的目录 app/Http/Controller ，每一条 http 请求对应一个 Controller 中的方法。所有 Controller 都需要 <strong>@Swoft\Http\Server\Annotation\Mapping\Controller</strong> 注解（注释），<code>后面所有提到的注释和注解意义相同，注解是 java 中的称呼，是一些有意义的代码级别含义的标志</code>，方法都需要添加 <strong>@Swoft\Http\Server\Annotation\Mapping\RequestMapping</strong> 注解</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$request = Context::get()-&gt;getRequest();</span><br><span class="line">$key = $request-&gt;post(<span class="string">'key'</span>);</span><br><span class="line">$method = $request-&gt;getMethod();</span><br><span class="line">$headers = $request-&gt;getHeaders();</span><br><span class="line">$some = $request-&gt;query(<span class="string">'key'</span>, <span class="string">'default value'</span>)</span><br></pre></td></tr></table></figure><p>这里 $request 可以类比 laravel 对象，</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>这种大而全的框架其实都是有很多方法获取常见的 request 以及 response 对象的。</p><h3 id="全局context获取"><a href="#全局context获取" class="headerlink" title="全局context获取"></a>全局context获取</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$response=Context::mustGet()-&gt;getResponse()</span><br></pre></td></tr></table></figure><h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequestMapping</span>("index")</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Response $response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ReflectionException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ContainerException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">(Response $response)</span>: <span class="title">Response</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $response = $response-&gt;withContent(<span class="string">'&lt;html lang="en"&gt;&lt;h1&gt;Swoft framework&lt;/h1&gt;&lt;/html&gt;'</span>);</span><br><span class="line">    $response = $response-&gt;withContentType(ContentType::HTML);</span><br><span class="line">    <span class="keyword">return</span> $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用了 param 注解，并声明 Response 类型。</p><h2 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h2><p>和 laravel 中一样使用 Eloquent 模型操作数据，但是我没有找到我想要的关联模型相关的方式，例如：<code>belongsTo</code>、<code>morphTo</code> 等。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$user = User::query()</span><br><span class="line">         -&gt;where(<span class="string">'mobile'</span>, $mobile)</span><br><span class="line">         -&gt;first();</span><br></pre></td></tr></table></figure><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这类框架真的互相一大抄，使用的是著名的扩展 predis，毫无悬念。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$value = Redis::get(<span class="string">'some'</span>);</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p>其实到这里才是我想说有点坑的地方。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php bin/swoft http:start</span><br></pre></td></tr></table></figure><p>好！稍等片刻，项目是跑起来了，但是我修改代码的时候居然不更新，需要切断进程重新跑。</p><h3 id="swoftcli"><a href="#swoftcli" class="headerlink" title="swoftcli"></a>swoftcli</h3><p>这也是官方提供的一个工具，可以 watch 文件的变化，然后可以自动重启服务，cli 在老版本是内置的，新版本的 swoft 踢除了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php bin/swoftcli run -b bin/swoft /var/www/swoft</span><br></pre></td></tr></table></figure><p>不得不说真香，但是在 MacBook 下面修改代码到服务重启成功总是慢半拍，但是试了在 linux 下确实可以做到同步。</p><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>终于要讲到我的大杀器，官方也是提供 Dockerfile 和 docker-compose 的，改了一下 command 就可以正常运行了。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>-<a href="https://www.swoft.org/docs" target="_blank" rel="noopener">官方文档</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>swoft</tag>
        <tag>swoole</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的左关联</title>
    <url>/p/7d06.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>可能是 laravel 中的 eloquent 模型查询用的实在太爽，感觉自己都不太会写 sql 语句了😅😅。现在回想自己的 sql 技术的顶峰应该就是大学的课堂了，老师带着大家建表，学生表、班级表、成绩表想想还有点记忆尤新，那时候数据库连接都是直接终端敲命令的，机房的数据库密码统一是 <code>wodexinmima</code>，转眼四年有余了。</p><p>现在的框架确实封装程度太高，大大降低了各种技术的门槛，大大提高了代码的维护性，否则一个十几乃至几十行的 sql 语句，谁能看得懂，但是又从反面暴露一件事，sql 的基础查询都快丢了，吓得我立马温习了一遍 mysql 查询。</p><p>进入正题。</p><p>最近有这么一个业务出现了 bug，用户在观看视频的时候会生成一条观看记录，观看记录的顺序始终是最近观看的视频放在最前面，但是如果用户看过视频两次，第二次看的记录并没有显示在最前面，反而还是以第一次观看的时间为准。</p><p>先看三张表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">users 表</span><br><span class="line">id name</span><br><span class="line"></span><br><span class="line">videos 表</span><br><span class="line">id name</span><br><span class="line"></span><br><span class="line">watch_records 表</span><br><span class="line">id user_id video_id created_at</span><br></pre></td></tr></table></figure><p>假如现在有这样几条数据</p><p>users 表</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>Jake</td></tr></tbody></table><p>videos 表</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>11</td><td>面试技巧</td></tr><tr><td>22</td><td>快消行业介绍</td></tr><tr><td>33</td><td>职场礼仪</td></tr></tbody></table><p>watch_records 表</p><table><thead><tr><th>id</th><th>user_id</th><th>video_id</th><th>created_at</th></tr></thead><tbody><tr><td>111</td><td>1</td><td>11</td><td>2019-07-01 05:31:59</td></tr><tr><td>222</td><td>1</td><td>22</td><td>2019-07-02 05:31:59</td></tr><tr><td>333</td><td>1</td><td>33</td><td>2019-07-03 05:31:59</td></tr><tr><td>444</td><td>1</td><td>11</td><td>2019-07-04 05:31:59</td></tr></tbody></table><p>现在要求查出的 watch_records 数据应该是 444 &gt; 333 &gt; 222 ，id 11 的视频因为最近再次观看取 444 这条记录而非 111 这一条。之前的 bug 是因为我直接 <code>groupBy(&#39;video_id&#39;)</code> ，从而得到的结果为 333 &gt; 222 &gt; 111。这个问题我研究了很长时间在我请教了一位朋友之后他说可以尝试「分组排序取前n」，这个关键字确实得到了很多答案，我试了几个查询没有得到合理答案，他直接给了我一段 sql ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m1.*</span><br><span class="line"><span class="keyword">FROM</span> watch_records  m1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> watch_records  m2</span><br><span class="line"><span class="keyword">ON</span> (m1.user_id = m2.user_id <span class="keyword">and</span> m1.video_id=m2.video_id <span class="keyword">AND</span> m1.created_at &lt; m2.created_at) <span class="keyword">WHERE</span> m2.id <span class="keyword">is</span> <span class="literal">NULL</span> <span class="keyword">and</span> m1.user_id=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_at <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>没有想到确实就查出了结果。</p><p>这段 sql 的点睛之笔在于 <code>m2.id is NULL</code> ，两张表左关联，右边表的创建时间比左边的大，只有左边是最大的时候，右边才会没有对应的记录，那也就是 <code>m2.id is NULL</code> ，巧妙利用了左关联，就做到了 「分组排序取前1」。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>left join</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel中实现微信公众号登录</title>
    <url>/p/6ae1.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>一般公司都会使用微信扫码登录，通过 PC 端打开</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</span></span><br></pre></td></tr></table></figure><p>然后用户扫描网页上的二维码，手机端确认，即可在网页上登录。</p><p>但是这样的登录方式越来越不适用于这个流量时代，都希望可以通过关注公众号登录，这样不仅可以给公众号引流，还可以通过公众号推文或者模板消息等其他诱导方式，再次吸引用户重新打开网页。</p><p>so …</p><p>找到了<a href="https://www.kanzhun.com/login/?ka=head-signin" target="_blank" rel="noopener">看准网</a>就实现了关注服务号自动登录，我很好奇的去看了一下他们的网络请求。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl &#39;https:&#x2F;&#x2F;www.kanzhun.com&#x2F;scan?wxScanId&#x3D;2Lhy8vtcRg~~&amp;_&#x3D;1561996681530&#39;</span><br></pre></td></tr></table></figure><p>删除了其他参数，只留下核心的两个参数，<code>wxScanId</code> 是后端随机返回一个字符串，<code>_</code> 貌似是一个计数器，暂时不深究，这个接口也很奇怪，每次都要 pending 30s 左右，我在思考这是 「长连接」？google 了一番，原来这里是一个专有名词 「长轮询」。</p><p><strong>长轮询</strong>必然会对应<strong>短轮询</strong>,正常的 http 请求，一个 request 到后端服务器，这时候做相应的一个数据处理然后就立即返回了，对于刚才扫码登录这个业务所以<strong>短轮询</strong>会一遍一遍去查询服务器，当前这个 code 是否已经扫码。但是<strong>长轮询</strong>会将 request 发到服务端，这时候服务端会 hold 这个请求，通过后端去查询，没查到继续去查，查到可立即返回到客户端，大大降低了客户端的响应时间。</p><p>大致的流程：</p><ol><li>服务端生成一个随机数 A</li><li>通过微信公众平台生成带 A 参数的二维码</li><li>将 A 存入到 redis 中，key 为 A ，value 为 false</li><li>将 A 和 二维码 url 返回到前端</li><li>客户端通过长轮询不断查询</li><li>用户扫描二维码可获取到 随机数对应的 openid</li><li>将 openid 存入到redis 中，key 为 A ，value 为 openid</li><li>客户端查询到结果通过 openId 登录</li></ol><p>show me the code 。。。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> $ttl = <span class="number">30</span>; <span class="comment">// 30秒 每秒查询一次</span></span><br><span class="line"> <span class="keyword">while</span> ($ttl--) &#123;</span><br><span class="line">     $openId = Cache::get(WeixinService::LOGIN_KEY_PREFIX . $request-&gt;code);</span><br><span class="line">      <span class="keyword">if</span> ($openId === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 还未扫码 继续查询</span></span><br><span class="line">      &#125; <span class="keyword">elseif</span> ($openId) &#123;</span><br><span class="line">         <span class="comment">// 已经扫码，拿到 openId</span></span><br><span class="line">         <span class="keyword">return</span> $openId;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 码已经过期，或者无效码</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;response-&gt;errorBadRequest(<span class="string">'二维码已经过期，或者无效'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口的目的就是实现了上面的逻辑，因为我将数据放到 redis 中，这样服务端可以每隔 1s 查询一次，如果用户已经扫码，则微信服务器会将事件推送到我们自己的服务器，这时候拿到 openid，配置到 redis 中，从而长轮询取到 openid ，后面的就是简单的登录流程，直接省略了。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://mp.weixin.qq.com/wiki?action=doc&id=mp1443433542&t=0.2205841058645851" target="_blank" rel="noopener">生成带参数的二维码</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>长轮询</tag>
        <tag>微信公众号登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel中获取真实ip</title>
    <url>/p/705c.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在开发微信支付，微信扫码付以及微信公众号支付对接都是比较顺利，因为 laravel 中 <a href="https://github.com/yansongda/pay" target="_blank" rel="noopener">laravel-pay</a> 用起来实在太爽，但是在对接微信的 H5 支付时却怎么也过不了，一直提示「网络环境未能通过安全验证，请稍后再试」。</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><p>搜素发现<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4" target="_blank" rel="noopener">支付常见问题</a>中提到了这个错误，其实简单点就是下单 ip 和支付 ip 不是同一个导致的，只是微信支付只是在 H5 支付环节对 spbill_create_ip 参数进行了校验，而源码中 spbill_create_ip 是通过如下代码获得：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;payload = [</span><br><span class="line">         <span class="string">'appid'</span>            =&gt; $config-&gt;get(<span class="string">'app_id'</span>, <span class="string">''</span>),</span><br><span class="line">         <span class="string">'mch_id'</span>           =&gt; $config-&gt;get(<span class="string">'mch_id'</span>, <span class="string">''</span>),</span><br><span class="line">         <span class="string">'nonce_str'</span>        =&gt; Str::random(),</span><br><span class="line">         <span class="string">'notify_url'</span>       =&gt; $config-&gt;get(<span class="string">'notify_url'</span>, <span class="string">''</span>),</span><br><span class="line">         <span class="string">'sign'</span>             =&gt; <span class="string">''</span>,</span><br><span class="line">         <span class="string">'trade_type'</span>       =&gt; <span class="string">''</span>,</span><br><span class="line">         <span class="string">'spbill_create_ip'</span> =&gt; Request::createFromGlobals()-&gt;getClientIp(), <span class="comment">// 重点！！！</span></span><br><span class="line">     ];</span><br></pre></td></tr></table></figure><p>这里是 Request 是来自 <code>Symfony\Component\HttpFoundation\Request</code> ，createFromGlobals 方法恰巧是通过 php 中全局的 <code>$_GET</code>, <code>$_POST</code>,<code>$_COOKIE</code>, <code>$_FILES</code>, <code>$_SERVER</code> 变量构造的，而 <code>$_SERVER</code> 中包含了大量的由 php-fpm 注入的参数。</p><blockquote><p>顺便提一下，laravel 中的 request 也是继承这个 <code>Symfony\Component\HttpFoundation\Request</code> 类</p></blockquote><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>但是通过这个方法无论如何也拿不到真实的用户 ip，由于后台的服务是由 docker 部署，api 服务是通过多个 proxy 代理到最终的 laravel 上，所以在 laravel 上始终获得的 ip 都是其中某个代理的 ip。</p><p>翻阅文档，laravel 中有个 <code>TrustProxies</code> 中间件是专门处理 ip 的问题，默认是没有代理是直接读取 <code>REMOTE_ADDR</code> 的头，如果有代理的情况可以填充代理的 ip，但是如果不知道中间代理的 ip 时，可以作如下修改：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> $proxies = <span class="string">'*'</span>;</span><br></pre></td></tr></table></figure><h2 id="深入问题"><a href="#深入问题" class="headerlink" title="深入问题"></a>深入问题</h2><p>可是问题还是没有得到解决，🤣🤣🤣<br>发现源码中 getClientIp 方法是取得 getClientIps 的第 0 个 ip 地址，那么 getClientIps 方法是可以获取所有的 ip 地址，该方法是从 <code>HTTP_X_FORWARDED_FOR</code> 中拿到所有代理的 ip ，<code>HTTP_X_FORWARDED_FOR</code> 参数是由 nginx 转发时通过 <code>proxy_set_header</code> 添加上去， nginx 的原则是每次在尾部追加代理的ip：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">HTTP_X_FORWARDED_FOR:真实ip,proxy1,proxy2</span><br></pre></td></tr></table></figure><p><strong>BUT</strong> getClientIps 返回的 ip 地址数组却变成了：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[proxy2,proxy1,真实ip]</span><br></pre></td></tr></table></figure><p>所以 getClientIp 每次获取第 0 个参数其实是最后一个代理的 ip。</p><h2 id="伪解决问题"><a href="#伪解决问题" class="headerlink" title="伪解决问题"></a>伪解决问题</h2><p>我在php的入口函数 index.php 的顶部加入了如下一段：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个很奇怪很奇怪的问题，可能是 laravel5.7  的bug，也可能是 TrustProxies 的 bug ，获取到的IP顺序是反的</span></span><br><span class="line"><span class="keyword">if</span> ($_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>]) &#123;</span><br><span class="line">    $_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>] = implode(<span class="string">','</span>, array_reverse(explode(<span class="string">','</span>, $_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序执行到这里的时候我将 <code>HTTP_X_FORWARDED_FOR</code> 中的 ip 进行倒序，getClientIp 拿到的第 0 个 ip 即为真实 ip 。</p><blockquote><p>虽然没有完美解决这个问题，但在使用中也没有发现其他 bug ，如果你有更多发现，欢迎联系我：<code>jake.zou.me@gmail.com</code></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>pay</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel开发碰到的坑</title>
    <url>/p/81b0.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><h2 id="获取-Redis-对象"><a href="#获取-Redis-对象" class="headerlink" title="获取 Redis 对象"></a>获取 Redis 对象</h2><p>最开始是这么脑残的写</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$redis = cache()-&gt;getRedis();</span><br><span class="line">$redis-&gt;hSet($hash, $field, $now);</span><br></pre></td></tr></table></figure><p>然后发现可以这么写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redis::hSet($hash, $field, $now);</span><br></pre></td></tr></table></figure><p>然后会发现如果导错包的话会抛一个异常 <strong>Redis 没有静态方法hSet</strong></p><p>其实只需要将包 <code>\Redis</code> 修改为 <code>use Illuminate\Support\Facades\Redis;</code> 即可</p><h2 id="Eloquent-Builder-中的-find-方法"><a href="#Eloquent-Builder-中的-find-方法" class="headerlink" title="Eloquent Builder 中的 find 方法"></a>Eloquent Builder 中的 find 方法</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">User:find(<span class="number">1</span>)-&gt;where(<span class="string">'status'</span>,<span class="number">1</span>)-&gt;first()</span><br></pre></td></tr></table></figure><p>发现 find方法不生效</p><p>查阅源码之后才发现 find 返回一个 Eloquent 实例或者 Eloquent 实例数组，所以其后的查询条件都不会和前面的查询发生联系，Eloquent 能够用链式查询的魅力在于每个函数都是返回的 $this 也就是 Builder 对象。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Access-Control-Allow-Credentials</title>
    <url>/p/5f34.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>前后端分离的项目中肯定会碰到跨域的问题，究其原因还是为了安全。我在一个前端工程调试过程中发现，即使我后端已经允许了跨域，但是前端依然报一个跨域错误。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost&#x2F;api&#x2F;admin&#x2F;authorizations&#39; from origin &#39;http:&#x2F;&#x2F;localhost:9528&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: The value of the &#39;Access-Control-Allow-Credentials&#39; header in the response is &#39;&#39; which must be &#39;true&#39; when the request&#39;s credentials mode is &#39;include&#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure><p>尝试了很多网上的方法也都没有弄清原因在哪里。索性就仔细研究一下 <code>Access-Control-Allow-Credentials</code> 这个头的作用，果然药到病除。这个是服务端下发到客户端的 response 中头部字段，意义是允许客户端携带验证信息，例如 cookie 之类的。这样客户端在发起跨域请求的时候，不就可以携带允许的头，还可以携带验证信息的头，又由于客户端是请求框架是 axios，并且手残的设置了 <code>withCredentials: true</code>，意思是客户端想要携带验证信息头，但是我的服务端设置是 <code>&#39;supportsCredentials&#39; =&gt; false,</code> ，表示不允许携带信息头，好了，错误找到了。</p><p>我们的客户端和服务端交互的时候使用的是 token，通过 Authorization头发送到服务端，并没有使用到 cookie，所以客户端没有必要设置 <code>withCredentials: true</code>，一顿操作猛如虎🤣🤣。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">mozilla的HTTP访问控制</a></li><li><a href="https://harttle.land/2016/12/28/cors-with-cookie.html" target="_blank" rel="noopener">介绍了跨域中其他的头信息</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>git 批量删除分支</title>
    <url>/p/c93.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch | grep &quot;fix-bug-*&quot; | xargs git branch -d</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>jenkins设置时区为北京时间</title>
    <url>/p/65f0.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><ul><li>方案一</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在【系统管理】-【脚本命令行】里运行</span><br><span class="line">System.setProperty(&#39;org.apache.commons.jelly.tags.fmt.timeZone&#39;, &#39;Asia&#x2F;Shanghai&#39;)</span><br></pre></td></tr></table></figure><p>比较高分的回答，但是方案一是无效的</p><ul><li>方案二</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run ... -e JAVA_OPTS&#x3D;-Duser.timezone&#x3D;Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><p>没有测试，只要我的容器已经run起来了，不想重新跑一个。</p><ul><li>方案三</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -it --user&#x3D;root laradock_jenkins_1 bash</span><br><span class="line">$ echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone</span><br></pre></td></tr></table></figure><p>方案三 我自己想的，直接改 linux 时区，然后重启即可。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins-docker 第一步</title>
    <url>/p/f123.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>jenkins 一个非常强大的持续集成，自动化部署的解决方案，但是部署起来异常麻烦，但是在这个时代幸好我们有 docker。<br>这篇文章不准备介绍如何安装 docker，如何拉一个 jenkins 镜像然后 run 起来，网上的文章实在太多。</p><p>聊一聊我所理解的更深层的东西，因为是 docker 里面起的 jenkins，那么 jenkins 操作的 shell 执行命令的时候，是无法访问到外界的文件的，除非你挂载一个卷，但是挂载的卷，还必须授予 linux 下为 jenkins user 的访问权限。</p><p>上面的问题都还是可以解决的，但是现在我的 php 代码同样是运行在 docker 中，那么就出现了 php-docker 和 jenkins-docker 是并列的一个关系，我想在 jenkins-docker 中执行 composer 、php artisan 等相关命令，因为根本不在一个空间下，部署构建工程变得尤为困难。</p><p>所以这里又出现了解决方案 <strong>docker-in-docker</strong>，它允许你在容器里再创建容器，但是由于存在重复嵌套等问题，现在已经很少使用。</p><p>新的解决方案是将宿主机的 docker-sock 挂载到 jenkins-docker 内部，所以在 jenkins-docker 内部操作 docker 命令的时候感觉和在外部是一样的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -v /var/run/docker.sock:/var/run/docker.sock ...</span><br></pre></td></tr></table></figure><p>然而故事并没有这么圆满！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">exec</span> --user root jenkins bash</span><br></pre></td></tr></table></figure><p>这样进入容器，docker 命令是可以正常执行的，但是</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">exec</span>  jenkins bash</span><br></pre></td></tr></table></figure><p>这样是不行的，因为默认是以 –user jenkins 进入的，在 jenkins 中的 shell 中也都是 jenkins 用户，一旦执行 docker 等相关操作，立马会报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br></pre></td></tr></table></figure><p>–user jenkins 是没有权限访问到 <code>var/run/docker.sock</code>，折腾一下午，网上很多方法也都是没法用的，因为 docker 容器里面很多命令都被阉割掉了，最终在 github 上面发现了一个简短又适用的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod 777 /var/run/docker.sock</span><br></pre></td></tr></table></figure><p>完美解决我的问题，特此记录！</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/27208085" target="_blank" rel="noopener">使用 Docker-in-Docker 来运行 CI 或集成测试环境？三思！</a></li><li><a href="https://github.com/jenkinsci/docker/issues/263" target="_blank" rel="noopener">github issues</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>在线视频播放心得</title>
    <url>/p/2e80.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>最近公司准备上一套视频播放的项目，对此我很兴奋，视频播放一直是技术中比较热门板块，并且又是一个比较老的板块。想要一个视频可以成功在网页中播放，我从一个懵逼状态到到真的实现播放总结了如下几个步骤。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>正常情况需要有一段可以播放的视频，视频格式其实无所谓， <code>.mp4</code> <code>.avi</code> 都可以，一般保证在上传的时候保证第一手视频是非常清晰的原视频。但是如果视频太大的话就是上传的时候会慢点。由于<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛</a>的各项费用我觉得都还不是特步贵，所以依然选择了七牛。这里涉及的其实是七牛的对象存储，七牛对于上传提供两种方式<a href="https://developer.qiniu.com/kodo/manual/1272/form-upload" target="_blank" rel="noopener">表单上传</a>和<a href="https://developer.qiniu.com/kodo/manual/1650/chunked-upload" target="_blank" rel="noopener">分片上传</a>，如果上传的资源文件小于 1gb，前者就行了，如果要使用分片上传最好是使用七牛的 sdk 了。这里我上传资源时后端接口返回到前端一个 token 和 key ，前端直接用 form 上传到七牛就行。</p><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><p>这块其实是我研究很久的一块，<strong>视频为什么需要转码？</strong>这个问题不太好回答，那么接着问自己，<strong>什么是视频？</strong>如果我说视频是一张张连续播放的带着背景音乐的图片可能很多人也不会反对。那肯定会有这样的问题， <strong>什么是图片？</strong>，图片又是一个很有意思的话题，如果以后专门有研究再开篇说图片，计算机世界里面这些视频和图片都是一堆有组织有预谋有规律的文件，前期按照一定的规则进行编码存储，后期按一定的编码打开，其实这里面还少一个阶段那就是现在的互联网时代，还会产生一个从服务端到客户端按一定编码进行传输。</p><p><a href="https://baike.baidu.com/item/视频编码" target="_blank" rel="noopener">百度百科-视频编码</a> 洋洋洒洒几千字，反正最终胜出者是 <code>H.264</code>，这是一个非常了不起的编码标准，它是集编码效率高，占用空间小，清晰度高等多个特性与一身，所以现在世面上大多数视频都是采用了这个标准。目前有个最新编码是 <code>H.265</code>，貌似又是一个非常厉害的编码格式有一统视频编码的趋势，但是由于并非所有浏览器都兼容，所以不得已选择了更为稳健的 <code>H.264</code>，如果时间充裕，后期可以考虑上多个源，前端自由搭配。</p><p>其实转码就是将原视频先解码再编码成合适的视频源，七牛和又拍云上一直提示转码的功能，我开始很懵逼，难道一定需要用他们自家的转码转的视频才能在网页上播放吗，转码到底是为播放准备些什么，不过写到这里问题肯定都是迎刃而解了。公司目前有人负责视频上传，对上传者有转码的培训和要求，所以转码可以在上传前就完成，但是如果播放的时候需要选择多个视频源，要求高清、2k、4k，这时候本地转码就显得效率低下了，使用云转码显然要便捷太多。</p><p>顺便普及一下视频清晰度，网络视频清晰和模糊会取决于多个因素，但是最重要的因为应该是网络带宽与速度、视频的编码以及视频的分辨率。网速暂且不论，编码无非是 <code>H.264</code> 和<code>H.265</code>，那最后的视频分辨率其实是代表视频画面的宽高，标准如下。</p><table><thead><tr><th>分辨率</th><th>别名</th><th>宽高</th></tr></thead><tbody><tr><td>4K</td><td>4K</td><td>3840x2160</td></tr><tr><td>2K</td><td>2K</td><td>2560x1440</td></tr><tr><td>FHD</td><td>1080P、超清</td><td>1920x1080</td></tr><tr><td>HD</td><td>720P、高清</td><td>1280x720</td></tr><tr><td>LD</td><td>-</td><td>960x540</td></tr><tr><td>SD</td><td>标准</td><td>640x480</td></tr></tbody></table><p>分辨率越高视频细节就越丰富，需要传输的内容也就越多。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>通过上面转码后的视频原则上就已经可以支持播放了，但是为什么会有切片这个过程？是因为往往一个 50mb 的视频文件，需要下载完成后才能进行播放，那么下载的过程就让用户白白等待了，为了打破视频下载中不能播放的情况，<code>m3u8</code> 应运而生，简单点说就是对一个特别长的视频进行分块切片，切成一段一段的，最终生成一堆的 .ts 文件和一个 .m3u8 的目录文件，播放视频的时候，只需要接入 m3u8 的地址，播放的时候会自动检索需要下载的片段，这样就完美解决了边下边播的问题了。</p><p>其实这里还想补充一个小插曲，就是放在七牛上的视频，不进行切片也是可以“分片播放”的，这个当时确实有点惊呆了，难道七牛自动给我切片了，还是什么原因，打开 chrome 的控制台，发现浏览器一直在发送 http 请求，返回的结果 http code 都是 206，追寻着这个足迹，又去研究了下什么是 206 请求，原来是七牛服务器做的断点续传，每次请求返回都是源文件的一个片段，客户端这边对这一个片段进行解码播放就 ok 了，我觉得这个也算一个伪切片的功能。</p><h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><p>使用 html5 的 video 标签就可以进行各种视频的播放了,或者 video.js 等其他播放器。如果用到视频加密，可以选择一些定制化视频播放器，视频加密后，通过特殊播放器解密。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://www.sohu.com/a/224199309_825275" target="_blank" rel="noopener">H.264和H.265对比</a></li><li><a href="https://blog.csdn.net/xiangzhihong8/article/details/84376103" target="_blank" rel="noopener">H.265/HEVC在Web视频播放的实践</a></li><li><a href="https://www.upyun.com/products/process#section-pricing" target="_blank" rel="noopener">分辨率与视频宽高</a></li><li><a href="https://blog.csdn.net/xiaofei0859/article/details/52883500" target="_blank" rel="noopener">Http 206 文件断点续传下载原理</a></li><li><a href="https://www.bbsmax.com/A/WpdKqqaXJV/" target="_blank" rel="noopener">HTML5 video标签播放视频下载原理</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>视频播放</tag>
      </tags>
  </entry>
  <entry>
    <title>关于go并发的优越性</title>
    <url>/p/aa7b.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>这篇文章本来想好好解释一下 go 并发的优越性，但是看到一个博客讲的实在太好，例子解释的太过清楚，给作者点赞。以前觉得 nodejs 里面的并发是用 async/await 这种形式才是优雅，但是不足之处也很明显，太过于粗粒度控制并发了，go 的并发在手动控制上表现力更强。</p><p>不过 go 里面的 <code>if err !=nil</code> 实在是忍受不了，最近在研究 rust ，上手有点难度🤣。</p><p>参考</p><ul><li><a href="https://juejin.im/entry/5ab893375188251fc32942fe" target="_blank" rel="noopener">用Promise实现并发 vs Go goroutine</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>git checkout 妙用</title>
    <url>/p/4ba1.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>git 上面创建一个分支是 <code>git branch fix-target</code> ，其实这个命令我还测试了一下，因为我已经忘了这个命令，一直使用的 <code>git checkout -b fix-target</code>。</p><p>这个命令优秀之处在于会创建一个分支，并切换到这个分支，但是有时候 <code>fix-target</code> 如果已经存在这个命令就会出错，蠢笨的我已经操作了 <code>git branch -D fix-target</code>，然后<br><code>git checkout -b fix-target</code> 半年了。</p><p>这里一定要注意我这里是强制删除，因为我已经确认我不需要旧分支上任何数据了，就想要个名。</p><p>今天突然发现 <code>git checkout -B fix-target</code>，正是我所想要的。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>七牛数据从一个桶转移到另一个桶</title>
    <url>/p/f6a9.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>因为七牛临时域名的原因，一些老的数据连接都对不上，我们这边需要将一个 bucketA 到另外一个 bucketB 中。操作步骤如下</p><h1 id="下载并-qshell"><a href="#下载并-qshell" class="headerlink" title="下载并 qshell"></a>下载并 qshell</h1><p><a href="https://developer.qiniu.com/kodo/tools/1302/qshell" target="_blank" rel="noopener">七牛官方下载页面</a>下载可执行文件，因为我是 mac ，所以选择 qshell_darwin_x64，找个合适的路径，我的习惯是 $HOME/bin，配置好 PATH。</p><h1 id="设置-account"><a href="#设置-account" class="headerlink" title="设置 account"></a>设置 account</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qshell account AK SK name</span><br></pre></td></tr></table></figure><p>新版本有个 name，老版本是没有的。有找个参数可以更好的作区分。</p><h1 id="列出-bucket"><a href="#列出-bucket" class="headerlink" title="列出 bucket"></a>列出 bucket</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qshell listbucket bucketA -o srccopy.txt</span><br><span class="line"></span><br><span class="line">xx简历.png	500071	FuEnT1v7oou7--ahA5gO1VIy4EHY	15283671101562504	image/png	0</span><br></pre></td></tr></table></figure><p>将 bucket 中的所有文件信息导出，<strong>BUT</strong>，这里我对七牛这点不满意，应该有个参数可以配置可以输出哪些文件信息，一股脑所有信息都抛出来了，但是这里是用 <code>\t</code> 分割的，那么我们做个切分也就 ok 了。</p><h1 id="处理文件列表"><a href="#处理文件列表" class="headerlink" title="处理文件列表"></a>处理文件列表</h1><p>来喽！这里突发奇想，来个 lua 脚本。就是爱折腾<br></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">split</span><span class="params">( str,reps )</span></span></span><br><span class="line">    <span class="keyword">local</span> resultStrList = &#123;&#125;</span><br><span class="line">    <span class="built_in">string</span>.<span class="built_in">gsub</span>(str,<span class="string">'[^'</span>..reps..<span class="string">']+'</span>,<span class="function"><span class="keyword">function</span> <span class="params">( w )</span></span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(resultStrList,w)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">return</span> resultStrList</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">sourceFile = <span class="built_in">io</span>.<span class="built_in">open</span> (<span class="string">"srccopy.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">toFile = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"tocopy.txt"</span> ,<span class="string">"w"</span>);</span><br><span class="line">y=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sourceFile:<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	arr=split(line,<span class="string">"\t"</span>)</span><br><span class="line">	name=arr[<span class="number">1</span>]</span><br><span class="line">	toFile:<span class="built_in">write</span>(name..<span class="string">"\n"</span>)</span><br><span class="line">	y=y+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">sourceFile:<span class="built_in">close</span>()</span><br><span class="line">toFile:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p></p><h1 id="copy-bucket"><a href="#copy-bucket" class="headerlink" title="copy bucket"></a>copy bucket</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qshell batchcopy --force  --failure-list failure-list.txt bucketA bucketB -i tocopy.txt</span><br></pre></td></tr></table></figure><p>处理失败的我们可以记录下来，大部分是文件名已存在，我这里选择不覆盖，如果需要覆盖添加上 <code>--overwrite</code> 参数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是第一次对 lua 的使用，感觉还挺轻量，以后还可以多使用 lua。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/qiniu/qshell" target="_blank" rel="noopener">qshell</a></li><li><a href="https://blog.csdn.net/forestsenlin/article/details/50590577" target="_blank" rel="noopener">lua切割字符串</a></li><li><a href="https://blog.csdn.net/wangbin_jxust/article/details/11810353" target="_blank" rel="noopener">lua读写文件</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>git-stash的妙用</title>
    <url>/p/a56c.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>今天一路 <code>git stash drop</code>，本地暂存的数据全被我删掉了，然后 sb 的发现，<code>Dropped refs/stash@{0} (534cb702c00f36afd4297e6328557cabead9600c)</code> 是我早上刚写的，难道几百行的代码就没了吗?</p><p>git 里面有个特点，总有 <strong>后悔药</strong>，只要能找到这个 id，肯定就能将数据恢复过来。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash pop 534cb702c00f36afd4297e6328557cabead9600c</span><br><span class="line"><span class="string">'534cb702c00f36afd4297e6328557cabead9600c'</span> is not a stash reference</span><br></pre></td></tr></table></figure><p>不料行不通！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash apply 534cb702c00f36afd4297e6328557cabead9600c</span><br></pre></td></tr></table></figure><p>果然药到病除！</p><p>从这里也发现 <code>git stash pop</code> 和 <code>git stash apply</code> 是稍微有点区别的，如果 stash-list 里面包含了这个 commit 用法是一样的，否则 apply 可以将不在 stash-list 中的代码恢复到工作区。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>go版本Excel导入脚本</title>
    <url>/p/b6cc.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>一直挺想用 go 的，但是没想到能干啥，前段时间正好有个任务导入 Excel 到后台数据库，用 Python 的话我可能分分钟就写好了，但是作死的我就想试下 go，因为 go 可以打包成可执行程序包，然后就可以不依赖 go 的环境。</p><h1 id="直接编码"><a href="#直接编码" class="headerlink" title="直接编码"></a>直接编码</h1><h2 id="使用-flag-获取终端参数解析"><a href="#使用-flag-获取终端参数解析" class="headerlink" title="使用 flag 获取终端参数解析"></a>使用 flag 获取终端参数解析</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">path := flag.String(<span class="string">"path"</span>, <span class="string">""</span>, <span class="string">"excel 路径"</span>)</span><br><span class="line">url := flag.String(<span class="string">"url"</span>, <span class="string">"**"</span>, <span class="string">"服务器地址"</span>)</span><br><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure><p>这里定义了 path 路径和服务器地址 url，唯一需要注意的是，这里变量返回都是指针。flag 有个好处，他的参数都是形如($key,$defaultValue,$description)，所以在执行 <code>-h</code> 的时候，都会返回 key 以及对应的 description。</p><h2 id="使用-Luxurioust-excelize-读取Excel文件"><a href="#使用-Luxurioust-excelize-读取Excel文件" class="headerlink" title="使用 Luxurioust/excelize 读取Excel文件"></a>使用 Luxurioust/excelize 读取Excel文件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">xlsx, err := excelize.OpenFile(*path)</span><br><span class="line">rows := xlsx.GetRows(<span class="string">"Sheet1"</span>)</span><br><span class="line"><span class="keyword">for</span> r, row := <span class="keyword">range</span> rows &#123;</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	<span class="keyword">for</span> c, col := <span class="keyword">range</span> row &#123;</span><br><span class="line">		fmt.Println(c)</span><br><span class="line">		fmt.Println(col)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个包用起来还是很舒服，唯一一点只支持 <strong>xlsx</strong> 格式，对于老版本的 <strong>xls</strong> 格式可能需要先转化了才能使用。rows 为一个二维数组，参数为 <strong>sheet</strong> 名称，默认的名称都是 <strong>Sheet1</strong></p><h2 id="使用自带的-net-http-发送请求"><a href="#使用自带的-net-http-发送请求" class="headerlink" title="使用自带的 net/http 发送请求"></a>使用自带的 net/http 发送请求</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str, _ := json.Marshal(data)</span><br><span class="line">resp, err := http.Post(url,</span><br><span class="line">	<span class="string">"application/json"</span>,</span><br><span class="line">	strings.NewReader(<span class="keyword">string</span>(str)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure><p>go 自带的的 http 就是这么好用，post 形式发送了一个 json 包，这个 jsonEncode 用起来稍微有点不爽但是也还好。</p><h1 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build  main.go</span><br></pre></td></tr></table></figure><p>就可以将这个脚本打包成一个可执行文件了，但是发现文件还挺大的，我以为只有几百 k 呢，都 8m 多了</p><h1 id="压缩程序"><a href="#压缩程序" class="headerlink" title="压缩程序"></a>压缩程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install upx</span><br><span class="line">$ upx main</span><br></pre></td></tr></table></figure><p><a href="https://upx.github.io/" target="_blank" rel="noopener">upx</a> 是一个专门的压缩打包可执行文件的程序，可以优化包体积。</p><blockquote><p>这里压缩过的包不能使用了，暂时没有深究什么原因。所以寻找其他方式</p></blockquote><h1 id="再次优化"><a href="#再次优化" class="headerlink" title="再次优化"></a>再次优化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build -ldflags -w main.go</span><br></pre></td></tr></table></figure><p>发现这样弄就可以减少 1m 的体积，还是挺可观的，现在有一个可执行文件了，不用对方有 golang 环境，拿过去直接可以运行跑起来。go 就是优秀！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://studygolang.com/articles/9811" target="_blank" rel="noopener">Golang 读写 Excel</a></li><li><a href="https://www.jianshu.com/p/cd3c766b893c" target="_blank" rel="noopener">压缩go build打包的可执行文件</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>关于浏览器的强制刷新</title>
    <url>/p/7a43.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>经常出现浏览器将js缓存的问题</p><h1 id="Chrome-浏览器"><a href="#Chrome-浏览器" class="headerlink" title="Chrome 浏览器"></a>Chrome 浏览器</h1><p>Windows：Shift+F5</p><p>Linux: Ctrl+Shift+R</p><p>Mac OS: Cmd+Shft+R</p><h1 id="Safari浏览器"><a href="#Safari浏览器" class="headerlink" title="Safari浏览器"></a>Safari浏览器</h1><p>Cmd+Option+R</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>关于授权和认证</title>
    <url>/p/ec56.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>昨天看到一篇博客专门提到 *<em>认证 VS 授权 *</em> 。</p><ol><li>名字不同，认证 （Authentication） 和 授权 （Authorization）</li><li>认证需要输入用户名和密码，授权指需要授权服务提供给当前服务若干权限从而请求确认</li><li>HTTP状态码中有 <code>401</code> 和 <code>403</code> 都表示无权访问当前资源，<code>401</code> 表示则表示没有「认证」，<code>403</code> 表示没有『授权』</li></ol><p>参考</p><blockquote><ul><li><a href="https://laravel-china.org/articles/3869/one-minute-to-clear-authentication-and-authorization" target="_blank" rel="noopener">一分钟讲清楚 Authentication 和 Authorization</a></li></ul></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Laravel中的队列执行过慢</title>
    <url>/p/a1bc.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>本来不想水的，公司的白先生硬要我水一篇，那就简单记录一下。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>上周，系统出现了一个很要命的问题，后端用的 laravel 队列执行导表任务异常缓慢，以前几分钟就能出的报告，几个小时都没动静，因为业务需要，每次用户观看视频都需要计算一些非常耗时的任务。</p><h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p>后来调查尝试也确实是这块出了问题，laravel 文档中介绍了队列的优先级，提到参数顺序的问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php artisan queue:work --queue=high,low</span><br></pre></td></tr></table></figure><p><code>--queue</code> 为队列的名称，参数用 <code>,</code> 分割，排的越靠前优先级越高。所以将越耗时的任务的优先级设置越低，将位置设置越靠后就好了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>所以如果系统中存在耗时任务，造成整个队列都被卡住，应该按预计的执行耗时排序，将越耗时的任务提到越靠后的位置，这样就可以解决执行时间较短的任务优先执行</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ul><li><a href="https://laravel-china.org/docs/laravel/5.7/queues/2286#queue-priorities" target="_blank" rel="noopener">队列优先级</a></li></ul></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会用postman吗</title>
    <url>/p/ce3e.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p><a href="https://www.getpostman.com" target="_blank" rel="noopener">postman</a> 一个非常牛逼的 api 测试工具。如果仅仅是打个 api，还不如直接 curl 来的简单，所以这里提供一些高级的功能的参考。</p><h2 id="多级文件夹"><a href="#多级文件夹" class="headerlink" title="多级文件夹"></a>多级文件夹</h2><p>经常需要将 api 进行按功能模块进行分组，这种多级文件夹的形式正好可以满足我的需求，某个功能每个 api 一目了然。</p><h2 id="多种请求方法"><a href="#多种请求方法" class="headerlink" title="多种请求方法"></a>多种请求方法</h2><p>postman 有多达 <strong>15</strong> 种请求方法供选择，常用 GET、POST、PUT、DELET更是切换起来异常的方便。</p><h2 id="URL-参数拼接"><a href="#URL-参数拼接" class="headerlink" title="URL 参数拼接"></a>URL 参数拼接</h2><p>这里说的并不是简单的参数拼接 <code>a=b&amp;</code> 这种，而是比较高级的参数拼接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&#123;&#123;host&#125;&#125;&#x2F;api&#x2F;topics&#x2F;:tid&#x2F;replies&#x2F;:rid</span><br></pre></td></tr></table></figure><p>然后在底下就可以补全 <code>tid</code> 和 <code>rid</code> 就可以了。</p><h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><p>授权可以通过常规的在请求 <code>Headers</code> 中添加 <code>&quot;Authorization: balabala&quot;</code>，但是 postman 更为方便的是有个专门的 <strong>Authorization</strong> 的 Tab，切换到这个 Tab 下面有多种通用的授权模式，譬如 <code>Basic Auth</code> 、<code>Bearer Token</code> 、<code>OAuth 2.0</code> 等，这里postman会自动添加相关信息到头或者 url 中。</p><h2 id="Manage-Environment"><a href="#Manage-Environment" class="headerlink" title="Manage Environment"></a>Manage Environment</h2><p>这个功能非常实用，相当于全局定义的常量。譬如线下环境的域名是 <code>dev-api.zoulux.top</code> ，线上环境的域名是 <code>api.zoulux.top</code>，那么这边新建两个 <code>Environment</code> ，分别配置 host 为上面域名，然后在所有的接口上就可以实用如下方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&#123;&#123;host&#125;&#125;&#x2F;api&#x2F;topics&#x2F;:tid&#x2F;replies&#x2F;:rid</span><br></pre></td></tr></table></figure><p>很简单的就可以切换线上线下环境了，不仅可以配置 host ，很多公司线上线下接口的 secret 也不一样，都可以在不同的 <code>Environment</code> 中配置。</p><h2 id="Pre-request-Script"><a href="#Pre-request-Script" class="headerlink" title="Pre-request Script"></a>Pre-request Script</h2><p>如果上面定义的是全局常量，那么这里可以说是可以定义局部变量，注意这里说的是「可以」，所以功能肯定远远不止如此，此处的 <code>Script</code> 是一个 <code>JavaScript</code> 脚本。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>譬如后端要求前端每次打接口将本地的 <strong>timestamp</strong> 拼接到接口里面接口里面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ts=<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">pm.environment.set(<span class="string">"timestamp"</span>, ts);</span><br></pre></td></tr></table></figure><p><code>pm</code> 是 <code>postman</code> 提供的全局变量，可以用于设置局部变量，那么在 Params 的 Tab 下面就可以直接使用 timestamp 变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timestamp : &#123;&#123;timestamp&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>在对接百家云的时候，他们的接口是需要签名的，接口规则还蛮复杂，这里需要接口按 key 排序，还需要加密，这里是 js 的脚本，排序就用原生的 js 就能完成，但是还需要对 md5 加密，这就为难我胖虎了，不过 postman 早就考虑到加密的情况，所以默认已经引入了一些常用 package，CryptoJS中有丰富加密方法。</p><h2 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h2><p>这个模块可以对接口的进行测试，譬如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.test(<span class="string">"Status code is 200"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以查看接口返回的 <strong>status</strong> 是否是 200 。</p><h2 id="api文档"><a href="#api文档" class="headerlink" title="api文档"></a>api文档</h2><p>在左侧的工程目录上右键选择 <strong>Publish Docs</strong>，会弹出一个网页，点过去就可以看到一个很精美的api文档，如果平时注意多注释，文档里面都会显示出来，更加优秀的是这个api文档是实时更新的，有新的api的时候刷新就可以看到了。</p><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>其实 postman 还有很多优秀的功能，值得我去探究。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://dev.baijiayun.com/default/wiki/detail/11#h0-5" target="_blank" rel="noopener">百家云接口签名</a></p><p><a href="https://www.getpostman.com/docs/v6/postman/scripts/postman_sandbox" target="_blank" rel="noopener">Commonly used libraries and utilities</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>postman</tag>
      </tags>
  </entry>
  <entry>
    <title>视频日志记录</title>
    <url>/p/1b7c.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>视频记录是一件很麻烦的事情，之前是将一段视频十等分，学生每看完其中的一等分，在用户做相关操作的时候就会上传其中的几等分视频记录，相关操作包括：</p><ul><li>暂停视频</li><li>观看下节视频</li><li>拖动视频</li><li>关闭当前页面</li></ul><h1 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h1><p>调查了一下几个视频网站的记录方式，如下：</p><h2 id="优酷"><a href="#优酷" class="headerlink" title="优酷"></a>优酷</h2><p>log 接口 ： <code>http://yt1.mmstat.com/yt/vp.vtslog</code></p><p>发送频率： <code>5</code> 秒</p><p>body 日志 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: 0.5.78</span><br><span class="line">vid: 969664681</span><br><span class="line">uid: </span><br><span class="line">type: h5</span><br><span class="line">cf: 0</span><br><span class="line">cpt: 2</span><br><span class="line">full: 0</span><br><span class="line">pc: 0</span><br><span class="line">clb: 0</span><br><span class="line">playersid: 15408798967661cr1pik5u2fq2bZZx0WzQhD9</span><br><span class="line">abtest: b</span><br><span class="line">clientid: 125272a7921189a8</span><br><span class="line">iku: 125272a7921189a8</span><br><span class="line">sn: 1</span><br><span class="line">pt: 5</span><br><span class="line">hi: 5</span><br><span class="line">vvid: 8004d7c2ba930b672821e47ccf0bb8b7</span><br><span class="line">lang: 1</span><br><span class="line">r: 756681157</span><br><span class="line">cna: RSZYFOyl3CYCAWVR4r76Xboc</span><br><span class="line">speed: 1</span><br></pre></td></tr></table></figure><h2 id="腾讯视频"><a href="#腾讯视频" class="headerlink" title="腾讯视频"></a>腾讯视频</h2><p>log 接口 ： <code>https://apd-be31beb59d7da6eff28fb4bb69f24c0d.v.smtcdns.com/varietyts.tc.qq.com</code></p><p>发送频率： 不定时发送，打包一起发送</p><p>body 日志 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 23</span><br><span class="line">start: 241560</span><br><span class="line">end: 251560</span><br><span class="line">brs: 24702636</span><br><span class="line">bre: 25256859</span><br><span class="line">ver: 4</span><br></pre></td></tr></table></figure><h2 id="Bilibili"><a href="#Bilibili" class="headerlink" title="Bilibili"></a>Bilibili</h2><p>log 接口 ： <code>https://api.bilibili.com/x/report/web/heartbeat</code></p><p>发送频率： <code>15</code> 秒</p><p>body 日志 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aid: 34926550</span><br><span class="line">cid: 61188917</span><br><span class="line">mid: </span><br><span class="line">csrf: </span><br><span class="line">played_time: 139</span><br><span class="line">realtime: 139</span><br><span class="line">start_ts: 1540881600</span><br><span class="line">type: 3</span><br><span class="line">dt: 2</span><br><span class="line">play_type: 0</span><br></pre></td></tr></table></figure><h2 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h2><p>log 接口 ： <code>https://sb.scorecardresearch.com/p</code></p><p>发送频率： <code>10</code> 秒</p><p>body 日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c1: 2</span><br><span class="line">c2: 26181340</span><br><span class="line">ns_type: hidden</span><br><span class="line">ns_st_sv: 6.1.0.170130</span><br><span class="line">ns_st_smv: 5.8</span><br><span class="line">ns_st_it: r</span><br><span class="line">ns_st_id: 1540882415279</span><br><span class="line">ns_st_ec: 2</span><br><span class="line">ns_st_sp: 1</span><br><span class="line">ns_st_sc: 1</span><br><span class="line">ns_st_psq: 1</span><br><span class="line">ns_st_asq: 1</span><br><span class="line">ns_st_sq: 1</span><br><span class="line">ns_st_ppc: 1</span><br><span class="line">ns_st_apc: 1</span><br><span class="line">ns_st_spc: 1</span><br><span class="line">ns_st_cn: 1</span><br><span class="line">ns_st_ev: pause</span><br><span class="line">ns_st_po: 86868</span><br><span class="line">ns_st_cl: 5997951</span><br><span class="line">ns_st_mp: js_api</span><br><span class="line">ns_st_mv: 6.1.0.170130</span><br><span class="line">ns_st_pn: 1</span><br><span class="line">ns_st_tp: 0</span><br><span class="line">ns_st_ci: 1462694600</span><br><span class="line">ns_st_pt: 86868</span><br><span class="line">ns_st_dpt: 86868</span><br><span class="line">ns_st_ipt: 26853</span><br><span class="line">ns_st_et: 86868</span><br><span class="line">ns_st_det: 86868</span><br><span class="line">ns_st_upc: 86868</span><br><span class="line">ns_st_dupc: 86868</span><br><span class="line">ns_st_iupc: 26853</span><br><span class="line">ns_st_upa: 86868</span><br><span class="line">ns_st_dupa: 86868</span><br><span class="line">ns_st_iupa: 26853</span><br><span class="line">ns_st_lpc: 86868</span><br><span class="line">ns_st_dlpc: 86868</span><br><span class="line">ns_st_lpa: 86868</span><br><span class="line">ns_st_dlpa: 86868</span><br><span class="line">ns_st_pa: 86868</span><br><span class="line">ns_ts: 1540882532281</span><br><span class="line">ns_st_bc: 0</span><br><span class="line">ns_st_dbc: 0</span><br><span class="line">ns_st_bt: 0</span><br><span class="line">ns_st_dbt: 0</span><br><span class="line">ns_st_bp: 0</span><br><span class="line">ns_st_skc: 0</span><br><span class="line">ns_st_dskc: 0</span><br><span class="line">ns_st_ska: 0</span><br><span class="line">ns_st_dska: 0</span><br><span class="line">ns_st_skd: 0</span><br><span class="line">ns_st_skt: 0</span><br><span class="line">ns_st_dskt: 0</span><br><span class="line">ns_st_pc: 1</span><br><span class="line">ns_st_dpc: 1</span><br><span class="line">ns_st_pp: 1</span><br><span class="line">ns_st_br: 0</span><br><span class="line">ns_st_rt: 100</span><br><span class="line">ns_st_ub: 0</span><br><span class="line">ns_st_ki: 1200000</span><br><span class="line">ns_st_pr: 声林之王之林宥嘉萧敬腾1对1指导学员 巫启贤女儿唱约翰丹佛名作</span><br><span class="line">ns_st_sn: *null</span><br><span class="line">ns_st_en: 1</span><br><span class="line">ns_st_ep: 声林之王之林宥嘉萧敬腾1对1指导学员 巫启贤女儿唱约翰丹佛名作</span><br><span class="line">ns_st_ct: vc12</span><br><span class="line">ns_st_ge: 港台,音乐,真人秀</span><br><span class="line">ns_st_st: iqiyi</span><br><span class="line">ns_st_ce: 1</span><br><span class="line">ns_st_ia: 0</span><br><span class="line">ns_st_ddt: *null</span><br><span class="line">ns_st_tdt: *null</span><br><span class="line">ns_st_pu: *null</span><br><span class="line">c3: *null</span><br><span class="line">c4: 6</span><br><span class="line">c6: *null</span><br><span class="line">c7: https:&#x2F;&#x2F;www.iqiyi.com&#x2F;v_19rr6haox0.html</span><br><span class="line">c8: 声林之王之林宥嘉萧敬腾1对1指导学员 巫启贤女儿唱约翰丹佛名作-综艺-高清正版视频在线观看–爱奇艺</span><br><span class="line">c9: https:&#x2F;&#x2F;www.iqiyi.com&#x2F;</span><br></pre></td></tr></table></figure><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="定时日志"><a href="#定时日志" class="headerlink" title="定时日志"></a>定时日志</h2><p>上述的几个平台中除了 <strong>爱奇艺</strong> 传的数据太多，其他都很精简，总结一下关键信息我准备设计成如下几个字段：</p><ul><li>视频id</li><li>当前用户id</li><li>定时上传次数 index</li><li>随机数 random</li><li>视频开始位置</li><li>视频结束位置</li><li>开始时间戳</li><li>结束时间戳</li><li>播放倍速</li><li>播放设备平台</li><li>日志类型 ：timing</li></ul><p>日志包整理好了，就看日志日志发送频率了，除了<em>腾讯视频</em> 应该是有专门收集日志，有个统一的触发机制，一次性发送了多条日志，其他网站都是以单位时间的频率发送给服务端，考虑到实施的简便性，综合几个发送频率，暂定频率为 <code>10</code> 秒。随机数 <code>random</code> 每次打开视频都刷新，可以区分不同的 <code>log</code> 的日志链，定时上传次数 <code>index</code> 可以检查一段 <code>log</code> 的完整性。</p><p>我们的单个视频平均时长在<code>15分钟</code>,那么如果有一次发送log日志失败对总体进度影响是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 * 60 &#x3D;900 s</span><br><span class="line">10 &#x2F; 900 &#x3D; 0.011111111 &#x3D; 1.11%</span><br></pre></td></tr></table></figure><p>为了一次日志失败对总体进度的影响，所以频率确定为 <code>5</code> 秒，但是相对来说，数据库的需要的储存空间也需要扩大一倍</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 * 60 &#x3D;900 s</span><br><span class="line">5 &#x2F; 900 &#x3D; 0.005555556 &#x3D; 0.56%</span><br></pre></td></tr></table></figure><p>单条数据丢失对整体影响也直接降低一半。</p><h2 id="操作日志"><a href="#操作日志" class="headerlink" title="操作日志"></a>操作日志</h2><p>上面的几家平台都有做操作日志的记录，这里唯一添加一个 <code>random</code> 字段，取值和定时日志每次生成的随机值相同，这里操作日志分为以下几类</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：start</li></ul><h3 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：pause</li></ul><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：complete</li></ul><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：exit</li></ul><h3 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>视频原有位置</li><li>视频现有位置</li><li>时间戳</li><li>播放设备平台</li><li>日志类型 ：drag</li></ul><h3 id="倍速"><a href="#倍速" class="headerlink" title="倍速"></a>倍速</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>视频原有倍速</li><li>视频现有倍速</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：speed</li></ul><h1 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h1><ol><li>客户端每次将日志发送到服务端</li><li>如果成功，则本次日志提交结束</li><li>如果失败，则客户端需要将日志存储在本地</li><li>等待时机合适，重新提交日志</li><li>如果成功，删除本地存储日志，本次日志提交结束</li><li>如果失败，重复第 <code>4</code> 步</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上几个有趣的命令（一）</title>
    <url>/p/a074.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>首先我是一个 Mac 党，但是对于 Linux 也尤为喜爱，他们上面有那么一些命令总是那么饶有趣味，又由于都是类 Unix 系统，很多命令都是通用的，本文的代码也都是在 Mac 上面完成</p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>一个大名鼎鼎的命令，作为一个程序员，如果 <code>curl</code> 都不知道，那就真的很尴尬，主要是做网络请求</p><h3 id="直接返回下载文件内容到终端"><a href="#直接返回下载文件内容到终端" class="headerlink" title="直接返回下载文件内容到终端"></a>直接返回下载文件内容到终端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下载文件到指定文件"><a href="#下载文件到指定文件" class="headerlink" title="下载文件到指定文件"></a>下载文件到指定文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl baidu.com -o baidu.html</span><br><span class="line">$ cat baidu.html</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下载文件到默认文件"><a href="#下载文件到默认文件" class="headerlink" title="下载文件到默认文件"></a>下载文件到默认文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://nodejs.org/dist/v8.12.0/node-v8.12.0.pkg -O</span><br><span class="line">$ ls node-v8.12.0.pkg</span><br><span class="line">node-v8.12.0.pkg</span><br></pre></td></tr></table></figure><h3 id="查看返回头信息"><a href="#查看返回头信息" class="headerlink" title="查看返回头信息"></a>查看返回头信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -i baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Sat, 20 Oct 2018 14:30:47 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 81</span><br><span class="line">Cache-Control: max-age&#x3D;86400</span><br><span class="line">Expires: Sun, 21 Oct 2018 14:30:47 GMT</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="查看请求的整个过程"><a href="#查看请求的整个过程" class="headerlink" title="查看请求的整个过程"></a>查看请求的整个过程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -v baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Rebuilt URL to: baidu.com&#x2F;</span><br><span class="line">*   Trying 123.125.115.110...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to baidu.com (123.125.115.110) port 80 (#0)</span><br><span class="line">&gt; GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl&#x2F;7.54.0</span><br><span class="line">&gt; Accept: *&#x2F;*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP&#x2F;1.1 200 OK</span><br><span class="line">&lt; Date: Sat, 20 Oct 2018 14:40:22 GMT</span><br><span class="line">&lt; Server: Apache</span><br><span class="line">&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">&lt; ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: 81</span><br><span class="line">&lt; Cache-Control: max-age&#x3D;86400</span><br><span class="line">&lt; Expires: Sun, 21 Oct 2018 14:40:22 GMT</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Type: text&#x2F;html</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">* Connection #0 to host baidu.com left intact</span><br></pre></td></tr></table></figure><h3 id="发送-Post-请求"><a href="#发送-Post-请求" class="headerlink" title="发送 Post 请求"></a>发送 Post 请求</h3><h4 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST baidu.com</span><br></pre></td></tr></table></figure><h4 id="form形式"><a href="#form形式" class="headerlink" title="form形式"></a>form形式</h4><p>将以 <code>Content-Type: application/x-www-form-urlencoded</code> 形式提交</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -d <span class="string">'a=b'</span> baidu.com</span><br></pre></td></tr></table></figure><h4 id="json形式"><a href="#json形式" class="headerlink" title="json形式"></a>json形式</h4><p>将以 <code>Content-Type: application/json</code> 形式提交</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST baidu.com -H <span class="string">'content-type: application/json'</span> -d <span class="string">'&#123;"a":"b"&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="发送其他-method-请求"><a href="#发送其他-method-请求" class="headerlink" title="发送其他 method 请求"></a>发送其他 method 请求</h3><p>如果你们公司也在用 <code>restful api</code> ，很幸运的是 <code>curl</code> 会是一个好帮手</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X GET baidu.com</span><br><span class="line">$ curl -X POST baidu.com</span><br><span class="line">$ curl -X PUT baidu.com</span><br><span class="line">$ curl -X DELETE baidu.com</span><br></pre></td></tr></table></figure><h3 id="发送带自定义-header-请求"><a href="#发送带自定义-header-请求" class="headerlink" title="发送带自定义 header 请求"></a>发送带自定义 header 请求</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -H <span class="string">'custom-key: custom-value'</span> baidu.com</span><br></pre></td></tr></table></figure><h3 id="查看当前-ip"><a href="#查看当前-ip" class="headerlink" title="查看当前 ip"></a>查看当前 ip</h3><p>这算是一个非常实用的技巧了，因为我这里开了代理，所以网络 ip 显示的是美国</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl ip.cn</span><br><span class="line">当前 IP：138.128.193.*** 来自：美国</span><br></pre></td></tr></table></figure><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p><code>ping(packet internet groper)</code>通过发送<code>icmp(internet control messages protocol)</code>协议包查看当前机器和目标机器的连通性，mac上面如果不指定 <code>ping</code> 次数，则会一直执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping baidu.com</span><br></pre></td></tr></table></figure><p>ctrl-c 强行停止</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING baidu.com (123.125.115.110): 56 data bytes</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;0 ttl&#x3D;55 time&#x3D;111.843 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;113.706 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;26.261 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;3 ttl&#x3D;55 time&#x3D;25.522 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;4 ttl&#x3D;55 time&#x3D;26.935 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过 <code>-c</code> 指定执行次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping  -c3 baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING baidu.com (123.125.115.110): 56 data bytes</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;0 ttl&#x3D;55 time&#x3D;232.282 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;44.364 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;38.667 ms</span><br><span class="line"></span><br><span class="line">--- baidu.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0.0% packet loss</span><br><span class="line">round-trip min&#x2F;avg&#x2F;max&#x2F;stddev &#x3D; 38.667&#x2F;105.104&#x2F;232.282&#x2F;89.958 ms</span><br></pre></td></tr></table></figure><p>执行结束会一段对本次所以请求的汇报，发送了多少次包，多少返回了，多少丢失了，<code>round-trip time</code> 时间 <strong>最短/平均/最长/标准差</strong></p><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p><code>traceroute</code> 其实也是发送 <code>icmp</code> 协议报文查看到达目标 <code>ip</code> 中间经过所有的路由信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ traceroute www.baidu.com</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">traceroute: Warning: www.baidu.com has multiple addresses; using 61.135.169.121</span><br><span class="line">traceroute to www.a.shifen.com (61.135.169.121), 64 hops max, 52 byte packets</span><br><span class="line"> 1  * * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  * * *</span><br></pre></td></tr></table></figure><p>尴尬的是后面直接星号了，因为大多数网关都禁止对 <code>icmp</code> 报文作出响应</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
  </entry>
  <entry>
    <title>定制博客</title>
    <url>/p/4e.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>虽然默认的 next 主题已经很美了，但是网上有一堆对 next 进行定制的教程，本着优雅不炫技的原则，我对博客作了以下简单的优化：</p><h3 id="添加-hexo-admin-插件"><a href="#添加-hexo-admin-插件" class="headerlink" title="添加 hexo-admin 插件"></a>添加 hexo-admin 插件</h3><p><a href="https://github.com/jaredly/hexo-admin" target="_blank" rel="noopener">hexo-admin</a> 为一套hexo 博客管理工具，我准备将博客的开发环境也部署到服务器上，这样就不用开本地环境，有了它就可以在线编辑博客了，非常方便。</p><ol><li><p>安装依赖库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-admin</span><br></pre></td></tr></table></figure></li><li><p>启动本地博客，并在浏览器打开</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s </span><br><span class="line">$ open http://localhost:4000/admin</span><br></pre></td></tr></table></figure></li><li><p>如果不出错的话 admin 界面就已经展现在眼前，但是很多时候想配置账户密码去登录到这个管理后台，就需要接着配置</p></li><li><p>在 admin 的界面 ,前往<code>Settings &gt;Setup authentification</code> 可以看到<code>Username,Password,Secret</code> ，输入自己心仪的账户密码以及秘钥，拷贝 <code>hexo-admin authentification</code> 下的内容</p></li><li><p>在博客根目录下的 <code>_config.yml</code> 最底下粘贴如下配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password_hash:</span> <span class="string">$2a$10$L.XAIqIWgTc5S1zpvV3MEu7/rH34p4Is/nq824smv8EZ3lIPCp1su</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">wobuhuigaosunide</span></span><br></pre></td></tr></table></figure></li><li><p>重新执行第 <code>2</code> 步，发现这时候已经需要登录，输入配置中的账号和密码即可</p></li></ol><h3 id="添加-分类-和-标签"><a href="#添加-分类-和-标签" class="headerlink" title="添加 分类 和 标签"></a>添加 <strong>分类</strong> 和 <strong>标签</strong></h3><p>每篇文章可以有一个分类和多个标签，这也是分类和标签的最大的区别。</p><h4 id="创建-分类-选项"><a href="#创建-分类-选项" class="headerlink" title="创建 分类 选项"></a>创建 <strong>分类</strong> 选项</h4><ol><li><p>生成 <strong>分类</strong> 页并添加属性<code>type</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>找到上面提示的 <code>index.md</code> 文件路径 ，打开发现是这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-10-17 00:33:17</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>将其修改为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-10-17 00:33:17</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>博客根目录下依次打开 <code>source &gt;_post</code> 找一篇博客打开，顶部有一些文章的配置信息，为 <code>categories</code> 字段添加属性</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="string">3eeb</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">随笔</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-10</span><span class="number">-15</span> <span class="number">16</span><span class="string">:27:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p>一篇文章只有一个分类，如果需要二级分类的话可以如下修改，可以参考<a href="https://hexo.io/zh-cn/docs/front-matter#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">hexo 分类和标签</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="string">3eeb</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">web开发</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ruby</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-10</span><span class="number">-15</span> <span class="number">16</span><span class="string">:27:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="创建-标签-选项"><a href="#创建-标签-选项" class="headerlink" title="创建 标签 选项"></a>创建 <strong>标签</strong> 选项</h4><ol><li><p>生成 <strong>标签</strong> 页并添加属性<code>type</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure></li><li><p>找到上面提示的 <code>index.md</code> 文件路径 ，打开发现是这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-10-20 14:33:17</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>将其修改为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-10-20 14:33:17</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>博客根目录下依次打开 <code>source &gt;_post</code> 找一篇博客打开，顶部有一些文章的配置信息，为 <code>tags</code> 字段添加属性</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="string">3eeb</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-admin</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">随笔</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-10</span><span class="number">-15</span> <span class="number">16</span><span class="string">:27:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p>打开上面的文章底部，就可以看到标签</p><p><img src="/images/material/WechatIMG51504.png" alt="标签"></p></li></ol><h3 id="添加加载进度条"><a href="#添加加载进度条" class="headerlink" title="添加加载进度条"></a>添加加载进度条</h3><p>修改 <code>pace: true</code> 并设置自己喜欢的 <code>pace_theme</code>，可以每个都测试一下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-flash</span></span><br></pre></td></tr></table></figure><h3 id="添加赞赏"><a href="#添加赞赏" class="headerlink" title="添加赞赏"></a>添加赞赏</h3><ol><li><p>修改自己的微信或者支付宝的图片</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward</span></span><br><span class="line"><span class="attr">reward_comment:</span> <span class="string">坚持原创技术分享，您的支持将鼓励我继续创作！</span></span><br><span class="line"><span class="comment">#wechatpay: /images/wechatpay.jpg</span></span><br><span class="line"><span class="attr">alipay:</span> <span class="string">/images/alipay.png</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure></li><li><p>但是打开发现赞赏的按钮上面的文字是 <code>Donate</code>,看着很奇怪，编辑 <code>themes/next/layout/_macro/reward.swig</code> 文件中第 4 行，将 <code>Donate</code> 修改为 <code>赏</code></p></li></ol><h3 id="首页文章添加阅读全文"><a href="#首页文章添加阅读全文" class="headerlink" title="首页文章添加阅读全文"></a>首页文章添加阅读全文</h3><p>阅读原文有两种方法可以实现，一种是自动，根据文字长度自动切割，另一种是手动的，添加 <code>more</code> 标签，则此标签以下就会被隐藏掉</p><ol><li><p>自动，编辑 <code>_config.yml</code>，指定文字长度，默认是150</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure></li><li><p>手动，打开任意文章，在文章的任意行插入 <code>&lt;!-- more --&gt;</code> 观察效果</p></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>自定义GitHubPages的域名</title>
    <url>/p/a916.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><p>今天在配置 githubpages 自定义域名的时候怎么也连不通，通过搜素发现需要在 git 项目根目录下<code>setting</code>，配置<code>Custom domain</code>为自己的自定义域名，这时 github 配置了一个临时的<em>CNAME</em>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>重新部署之后，github 又会将<code>Custom domain</code>置为空，所以找到最终结局方法，在 hexo 项目的<code>source</code>目录下添加 <code>CNAME</code> 的文件，文件内容为自定义的域名：如 <code>blog.zoulux.top</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的删除git子模块</title>
    <url>/p/b63b.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><ol><li><p>git submodule deinit $mod // 逆初始化</p></li><li><p>git rm –cached $mode // 删除子模块缓存信息</p></li><li><p>git commit -am “Remove a $mode.” // 提交更改</p></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/p/3eeb.html</url>
    <content><![CDATA[<!-- build time:Mon Mar 16 2020 23:41:06 GMT+0800 (China Standard Time) --><h1 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h1><p>欢迎来到我的博客，希望我能勤快点，每周一更！</p><p>每学一门新语言的时候，我们总是希望能在控制台中快速输出<code>Hello world</code>，这次也不理外。</p><p>世界，你好，我来了！</p><blockquote><p>业精于勤荒于嬉，行成于思毁于随。共勉！</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
