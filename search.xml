<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql 中的悲观锁和乐观锁</title>
    <url>/p/bb5f.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>mysql 数据库自带了锁机制，从某种意义来说“悲观锁”才能称之为<strong>锁</strong>，“乐观锁”是人为添加的概念。在我们的查询中，可以通过 <code>explain</code> 查看 sql，如果查询语句走索引，那么 mysql 会将查询到的行锁住，如果查询语句不走索引，这时候就很危险，mysql 会将整个表锁住，所以这块没有处理好会非常危险。</p><p>mysql 的悲观锁有且仅有两种： 共享锁和排它锁，而且建议仅仅用这两个名词，很多地方有什么读锁和写锁的说法，完全是不合适的。</p><p>这边建一张 table <code>a</code>，有两个 field <code>id</code> 和 <code>name</code>，<code>id</code> 为主键。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 | aa   |</span><br><span class="line">|  2 | bb   |</span><br><span class="line">|  4 | dd   |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁指的是在一个事务开启后，再另一个事务中是可以进行读取数据：</p><ol><li><p>开启一个窗口A</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>  <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 | aa   |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>开启另一个窗口B</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>  <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 | aa   |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>id=1</code> 在另一个事务中也是可以查询到</p><ol start="3"><li>在窗口B 中执行更新操作</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> a <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"ab"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">... 漫长的等待</span><br><span class="line">ERROR 1205 (HY000): <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>这里可以发现在另一个事务中是无法更新数据。</p><ol start="4"><li>在窗口 A 中提交事务</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure><ol start="5"><li>在窗口 B 中再次发起更新<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> a <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"ab"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></li></ol><p>这一次发现已经成功。</p><ol start="6"><li>在窗口 B 中查看</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a;</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 | ab   |</span><br><span class="line">|  2 | bb   |</span><br><span class="line">|  4 | dd   |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h2><p>排它锁指的是在一个事务开启后，再另一个事务中是不可以进行读取其数据：</p><ol><li><p>开启一个窗口A</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>  <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 | ab   |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>开启另一个窗口B</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>  <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">... 漫长的等待</span><br><span class="line">ERROR 1205 (HY000): <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>这里可以看到 <code>id=1</code> 在另一个事务中是<strong>访问不到</strong>的。</p><ol start="3"><li>在窗口 A 中提交事务</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里可以发现在另一个事务中是无法更新数据。</p><ol start="4"><li>在窗口 B 中再次发起查询</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>  <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 | ab   |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到已经查询成功。</p><ol start="5"><li><p>在窗口 A 中发起更新操作</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> a <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"abc"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line">ERROR 1205 (HY000): <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>可以看到无法更新数据</p></li><li><p>在窗口 B 中提交事务</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="7"><li>在窗口 A 中更新<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> a <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"abc"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>更新成功</li></ol><h2 id="测试锁表"><a href="#测试锁表" class="headerlink" title="测试锁表"></a>测试锁表</h2><ol><li><p>开启一个窗口 A</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">name</span> =<span class="string">"bb"</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  2 | bb   |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>开启一个窗口 B</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>  <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">ERROR 1205 (HY000): <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br></pre></td></tr></table></figure></li><li><p>窗口 B 继续测试其他 id</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">2</span>  <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">ERROR 1205 (HY000): <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br></pre></td></tr></table></figure></li><li><p>窗口 B 更新数据</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> a <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"abcd"</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> =<span class="number">1</span>;</span><br><span class="line">ERROR 1205 (HY000): <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>可以看到都获取不到锁，无法完成查询以及更新，如果发生在生产环境那就是要出事故的。</p><ol start="5"><li>窗口 A 提交事务</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="6"><li>窗口 B 查询数据</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM a WHERE id =1  FOR UPDATE;</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">| id | name |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">|  1 | abc  |</span><br><span class="line">+<span class="comment">----+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>这里已经成功了。</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>前面的内容已经提到，乐观锁并不算锁，是人为添加的一个概念，这个概念是独立于数据库系统而是在应用层实现的一套锁机制，常见的实现方式有两种，根据<code>更新时间戳</code>或者增加一个字段<code>版本号</code>，一般的框架都会提供<code>版本号</code>方式的实现，laravel 中看到有 <a href="https://github.com/reshadman/laravel-optimistic-locking" target="_blank" rel="noopener">laravel-optimistic-locking</a> 这个库他的实现也很简洁，spring boot 中有一个 @Version 注解。</p><blockquote><p>在高并发的情况下，可能存在时间戳相同的情况，所以<code>更新时间戳</code>用的比较少。</p></blockquote><p>实现原理其实很简单，添加一个版本号，每次更新数据的时候带着版本号一起查询，然后将版本号<code>+1</code>，由于 mysql 更新的原子性，最终只有一条数据更新成功。</p><p>示例代码：</p><ol><li><p>查询表数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM a ;</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br><span class="line">| id | name | version |</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br><span class="line">|  1 | abc  |       1 |</span><br><span class="line">|  2 | bb   |       1 |</span><br><span class="line">|  4 | dd   |       1 |</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>发起更新</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> a <span class="keyword">SET</span> <span class="keyword">name</span>=<span class="string">"abcd"</span>,<span class="keyword">version</span>=<span class="number">2</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span>=<span class="number">1</span>;</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure></li><li><p>查询数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> a ;</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br><span class="line">| id | name | version |</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br><span class="line">|  1 | abcd |       2 |</span><br><span class="line">|  2 | bb   |       1 |</span><br><span class="line">|  4 | dd   |       1 |</span><br><span class="line">+<span class="comment">----+------+---------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>乐观锁这个想法既简单又实用。</p></li></ol><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>计算机的世界里，总是有一些晦涩的名词和高大上的术语，但也正是这些名词和术语将复杂逻辑进行抽象成简单概念，以区别我们懂行的和那些听不懂的。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://v2ex.com/t/595450" target="_blank" rel="noopener">https://v2ex.com/t/595450</a></li><li><a href="https://www.hollischuang.com/archives/934" target="_blank" rel="noopener">https://www.hollischuang.com/archives/934</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>乐观锁</tag>
        <tag>悲观锁</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 搭建 Apollo 配置中心</title>
    <url>/p/e65e.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>众所周知，携程的 <a href="https://github.com/ctripcorp/apollo/" target="_blank" rel="noopener">Apollo</a> 已经成为行业里非常流行的配置中心了，这个轮子的原理其实并不复杂，但是如果重新开发一套又需要考虑很多边界条件，Apollo 本身也是开源的，所以有问题的话热心的网友一定会很早就帮我们解决掉了。</p><p>前面也有考虑过直接使用 k8s 里面的 configMap，但是 configMap 只有在创建 pods 的时候会拉取，后面如果修改了 configMap ，其实是不会同步到 pods 中，如果手动去拉取 configMap 中的内容，这又和 Apollo 有什么区别呢，Apollo 还有审计还有灰度，还有历史变更记录，还有一套权限系统，所以不如直接使用 Apollo 了。</p><h1 id="Apollo配置中心设计"><a href="#Apollo配置中心设计" class="headerlink" title="Apollo配置中心设计"></a>Apollo配置中心设计</h1><h2 id="基础模型"><a href="#基础模型" class="headerlink" title="基础模型"></a>基础模型</h2><p><img src="https://upload-images.jianshu.io/upload_images/1196536-3d61a8d40c121684.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基础模型"></p><h2 id="软件架构图"><a href="#软件架构图" class="headerlink" title="软件架构图"></a>软件架构图</h2><p><img src="https://upload-images.jianshu.io/upload_images/1196536-6054f2bc75cc9c42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构图"></p><h1 id="kubernetes-部署"><a href="#kubernetes-部署" class="headerlink" title="kubernetes 部署"></a>kubernetes 部署</h1><p>Apollo 是由 java 语言编写，使用了 spring 框架，以及 Eureka 服务发现，如果使用 k8s 环境的话，当然是使用 k8s 自带的服务发现最佳，提升系统可读性，可维护性和稳定性。wiki 上已经有详细的文档，这里说一下重点步骤：</p><h2 id="添加数据库配置文件"><a href="#添加数据库配置文件" class="headerlink" title="添加数据库配置文件"></a>添加数据库配置文件</h2><p>首先下载 <a href="https://github.com/ctripcorp/apollo/tree/master/scripts/sql" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo/tree/master/scripts/sql</a> 两个 sql 文件，然后倒入到自己各个环境的数据库中。</p><p><code>apolloconfigdb.sql</code> 是各个环境都需要配置的 service 服务需要的数据库，<code>apolloportaldb.sql</code> 是 portal 管理端服务需要的数据库，如果暂时搞不清楚，两个文件可以都导入，后面再去理解原理。</p><blockquote><p>下面的描述中提到的 service 均指 configservice 和 adminservice 。</p></blockquote><h2 id="helm-添加-Apollo-的源"><a href="#helm-添加-Apollo-的源" class="headerlink" title="helm 添加 Apollo 的源"></a>helm 添加 Apollo 的源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ helm repo add apollo http://ctripcorp.github.io/apollo/charts</span><br><span class="line">$ helm search repo apollo</span><br><span class="line"></span><br><span class="line">NAME                 	CHART VERSION	APP VERSION	DESCRIPTION</span><br><span class="line">apollo/apollo-portal 	0.1.1        	1.7.1      	A Helm chart <span class="keyword">for</span> Apollo Portal</span><br><span class="line">apollo/apollo-service	0.1.1        	1.7.1      	A Helm chart <span class="keyword">for</span> Apollo Config Service and Apol...</span><br></pre></td></tr></table></figure><h2 id="拉取模板文件"><a href="#拉取模板文件" class="headerlink" title="拉取模板文件"></a>拉取模板文件</h2><p>这里拉取文件是为了可以详细的看下作者是如何设计这个 chart，已经可以拿到一封完整的 values.xml 文件。基于 k8s 的思想，配置都要留在文件里，helm 如果使用命令行的方式，可以测试使用，但是如果是线上环境那终究没有里面存档，命令行的参数过长也会造成阅读不遍。</p><blockquote><p>如果相信作者的话也可以直接使用下面我粘贴的 <code>apollo-portal-values.yaml</code> 和 <code>apollo-service-values.yaml</code> 文件</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ helm pull apollo/apollo-portal</span><br><span class="line">$ helm pull apollo/apollo-service</span><br><span class="line">$ ls -l</span><br><span class="line"></span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--  1 jake  staff  3568 Sep 16 17:01 apollo-portal-0.1.1.tgz</span><br><span class="line">-rw-r--r--  1 jake  staff  3478 Sep 16 17:00 apollo-service-0.1.1.tgz</span><br></pre></td></tr></table></figure><p>两个压缩文件，mac 中就点击下就可以直接解压了，然后两个 chart 根目录中的 values.yaml 文件可以复制出来，重命名一下备用。</p><h3 id="apollo-portal-values-yaml"><a href="#apollo-portal-values-yaml" class="headerlink" title="apollo-portal-values.yaml"></a>apollo-portal-values.yaml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">apollo-portal</span></span><br><span class="line"><span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">containerPort:</span> <span class="number">8070</span></span><br><span class="line"><span class="attr">image:</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">apolloconfig/apollo-portal</span></span><br><span class="line">  <span class="attr">pullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line"><span class="attr">imagePullSecrets:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">service:</span></span><br><span class="line">  <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8070</span></span><br><span class="line">  <span class="attr">targetPort:</span> <span class="number">8070</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">ClientIP</span></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">""</span></span><br><span class="line">      <span class="attr">paths:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">tls:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">liveness:</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">100</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">readiness:</span></span><br><span class="line">  <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># environment variables passed to the container, e.g. JAVA_OPTS</span></span><br><span class="line"><span class="attr">env:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">strategy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">nodeSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">tolerations:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">affinity:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line">  <span class="comment"># spring profiles to activate</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">"github,auth"</span></span><br><span class="line">  <span class="comment"># specify the env names, e.g. dev,pro</span></span><br><span class="line">  <span class="attr">envs:</span> <span class="string">""</span></span><br><span class="line">  <span class="comment"># specify the meta servers, e.g.</span></span><br><span class="line">  <span class="comment"># dev: http://apollo-configservice-dev:8080</span></span><br><span class="line">  <span class="comment"># pro: http://apollo-configservice-pro:8080</span></span><br><span class="line">  <span class="attr">metaServers:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="comment"># specify the context path, e.g. /apollo</span></span><br><span class="line">  <span class="attr">contextPath:</span> <span class="string">""</span></span><br><span class="line">  <span class="comment"># extra config files for apollo-portal, e.g. application-ldap.yml</span></span><br><span class="line">  <span class="attr">files:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">portaldb:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">apollo-portaldb</span></span><br><span class="line">  <span class="comment"># apolloportaldb host</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">dbName:</span> <span class="string">ApolloPortalDB</span></span><br><span class="line">  <span class="comment"># apolloportaldb user name</span></span><br><span class="line">  <span class="attr">userName:</span></span><br><span class="line">  <span class="comment"># apolloportaldb password</span></span><br><span class="line">  <span class="attr">password:</span></span><br><span class="line">  <span class="attr">connectionStringProperties:</span> <span class="string">characterEncoding=utf8</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="comment"># whether to create a Service for this host or not</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><h3 id="apollo-service-values-yaml"><a href="#apollo-service-values-yaml" class="headerlink" title="apollo-service-values.yaml"></a>apollo-service-values.yaml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">configdb:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">apollo-configdb</span></span><br><span class="line">  <span class="comment"># apolloconfigdb host</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">  <span class="attr">dbName:</span> <span class="string">ApolloConfigDB</span></span><br><span class="line">  <span class="comment"># apolloconfigdb user name</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">""</span></span><br><span class="line">  <span class="comment"># apolloconfigdb password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">connectionStringProperties:</span> <span class="string">characterEncoding=utf8</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="comment"># whether to create a Service for this host or not</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"></span><br><span class="line"><span class="attr">configService:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">apollo-configservice</span></span><br><span class="line">  <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">apolloconfig/apollo-configservice</span></span><br><span class="line">    <span class="attr">pullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">liveness:</span></span><br><span class="line">    <span class="attr">initialDelaySeconds:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">readiness:</span></span><br><span class="line">    <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="comment"># spring profiles to activate</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">"github,kubernetes"</span></span><br><span class="line">    <span class="comment"># override apollo.config-service.url: config service url to be accessed by apollo-client </span></span><br><span class="line">    <span class="attr">configServiceUrlOverride:</span> <span class="string">""</span></span><br><span class="line">    <span class="comment"># override apollo.admin-service.url: admin service url to be accessed by apollo-portal </span></span><br><span class="line">    <span class="attr">adminServiceUrlOverride:</span> <span class="string">""</span></span><br><span class="line">  <span class="comment"># environment variables passed to the container, e.g. JAVA_OPTS</span></span><br><span class="line">  <span class="attr">env:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">tolerations:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">adminService:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">apollo-adminservice</span></span><br><span class="line">  <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">replicaCount:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">containerPort:</span> <span class="number">8090</span></span><br><span class="line">  <span class="attr">image:</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">apolloconfig/apollo-adminservice</span></span><br><span class="line">    <span class="attr">pullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8090</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8090</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">liveness:</span></span><br><span class="line">    <span class="attr">initialDelaySeconds:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">readiness:</span></span><br><span class="line">    <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">periodSeconds:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="comment"># spring profiles to activate</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">"github,kubernetes"</span></span><br><span class="line">  <span class="comment"># environment variables passed to the container, e.g. JAVA_OPTS</span></span><br><span class="line">  <span class="attr">env:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">tolerations:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="部署核心文件"><a href="#部署核心文件" class="headerlink" title="部署核心文件"></a>部署核心文件</h2><p>由于 Apollo 的设计原则，可以一个 portal 管理多个 service，我们可以在各个环境（DEV，PRO）都部署一套 service，然后用 portal 单独去管理。</p><h3 id="配置-service"><a href="#配置-service" class="headerlink" title="配置 service"></a>配置 service</h3><p>我们的各个环境应该都有自己的一套数据库，Apollo 唯一的依赖也是 mysql，所以只需要修改 configdb 中的数据库字段</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">configdb:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">apollo-configdb</span></span><br><span class="line">  <span class="comment"># apolloconfigdb host</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">"mysql8"</span> <span class="comment"># 修改为自己的数据库地址</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span> <span class="comment"># 修改为自己的数据库端口</span></span><br><span class="line">  <span class="attr">dbName:</span> <span class="string">apolloconfigdb</span>  <span class="comment"># 修改为自己的数据库名字</span></span><br><span class="line">  <span class="comment"># apolloconfigdb user name</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">"root"</span>  <span class="comment"># 修改为自己的数据库用户</span></span><br><span class="line">  <span class="comment"># apolloconfigdb password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">"1"</span>  <span class="comment"># 修改为自己的数据库用户密码</span></span><br><span class="line">  <span class="attr">connectionStringProperties:</span> <span class="string">characterEncoding=utf8</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="comment"># whether to create a Service for this host or not</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure><p>可以将 <code>apollo-service-values.yaml</code> 中的其他内容都删除只保留一个 configdb， 其他属性会走默认的配置字段，如果有特殊需求就自行编辑。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">helm</span> <span class="string">install</span> <span class="string">-f</span> <span class="string">apollo-service-values.yaml</span> <span class="string">apollo-service</span> <span class="string">apollo/apollo-service</span> <span class="string">-n</span> <span class="string">sv-dev</span></span><br><span class="line"></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">NOTES:</span></span><br><span class="line"><span class="attr">Get meta service url for current release by running these commands:</span></span><br><span class="line">  <span class="string">echo</span> <span class="string">http://apollo-service-apollo-configservice.sv-dev:8080</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>我这里的 namespace 是 sv-dev， 核心的一段是 <code>http://apollo-service-apollo-configservice.sv-dev:8080</code>，需要暂时存储一下。</p><p>然后替换 configdb 中的数据库信息，将 apollo-service 配置到各个环境中去。</p><h3 id="配置-protal"><a href="#配置-protal" class="headerlink" title="配置 protal"></a>配置 protal</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">replicaCount:</span> <span class="number">1</span> <span class="comment"># **切记切记**，这里一定要写 1，如果有多个 protal ，使用的 session 之间不共享内存，导致我需要反复登录</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line">  <span class="comment"># spring profiles to activate</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">"github,auth"</span></span><br><span class="line">  <span class="comment"># specify the env names, e.g. dev,pro</span></span><br><span class="line">  <span class="attr">envs:</span> <span class="string">"dev,pro"</span> <span class="comment"># 如果是部署了多个环境，这里写多个环境以逗号隔开</span></span><br><span class="line">  <span class="comment"># specify the meta servers, e.g.</span></span><br><span class="line">  <span class="comment"># dev: http://apollo-configservice-dev:8080</span></span><br><span class="line">  <span class="comment"># pro: http://apollo-configservice-pro:8080</span></span><br><span class="line">  <span class="attr">metaServers:</span> </span><br><span class="line">       <span class="attr">dev:</span> <span class="string">"http://apollo-service-apollo-configservice.sv-dev:8080"</span> <span class="comment"># 这里填写上面 helm 部署成功得到的地址</span></span><br><span class="line">       <span class="attr">pro:</span> <span class="string">"http://apollo-service-apollo-configservice.sv-pro:8080"</span> <span class="comment"># 这里填写上面 helm 部署成功得到的地址</span></span><br><span class="line">  <span class="comment"># specify the context path, e.g. /apollo</span></span><br><span class="line">  <span class="attr">contextPath:</span> <span class="string">""</span></span><br><span class="line">  <span class="comment"># extra config files for apollo-portal, e.g. application-ldap.yml</span></span><br><span class="line">  <span class="attr">files:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">portaldb:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">apollo-portaldb</span></span><br><span class="line">  <span class="comment"># apolloportaldb host</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">""</span> <span class="comment"># 修改为自己的数据库地址</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3306</span> <span class="comment"># 修改为自己的数据库端口</span></span><br><span class="line">  <span class="attr">dbName:</span> <span class="string">ApolloPortalDB</span> <span class="comment"># 修改为自己的数据库名字</span></span><br><span class="line">  <span class="comment"># apolloportaldb user name</span></span><br><span class="line">  <span class="attr">userName:</span> <span class="string">""</span> <span class="comment"># 修改为自己的数据库用户</span></span><br><span class="line">  <span class="comment"># apolloportaldb password</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">""</span>  <span class="comment"># 修改为自己的数据库用户密码</span></span><br><span class="line">  <span class="attr">connectionStringProperties:</span> <span class="string">characterEncoding=utf8</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="comment"># whether to create a Service for this host or not</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fullNameOverride:</span> <span class="string">""</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"></span><br><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">"apollo.xxxx.com"</span> <span class="comment"># 选一个自己喜欢的域名，绑定一下</span></span><br><span class="line">      <span class="attr">paths:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="string">"/"</span></span><br><span class="line">  <span class="attr">tls:</span> <span class="string">[]</span></span><br></pre></td></tr></table></figure><p>无关的配置默认就好，我们可以直接删除掉，只保留核心的需要修改配置。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ helm install -f apollo-portal-values.yaml apollo-portal apollo/apollo-portal -n apollo</span><br></pre></td></tr></table></figure><p>这里我将 apollo-portal 部署到单独的一个 namespace 中。</p><h2 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h2><p>打开 <code>apollo.xxxx.com</code> 就可以打开管理页面<br><img src="https://upload-images.jianshu.io/upload_images/1196536-f667478896c35bfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>默认账户密码是 <code>apollo</code> 和 <code>admin</code>，登录进去就可以享受配置中心带来的便利了，到此搭建结束。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://github.com/ctripcorp/apollo/wiki/Apollo%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">Apollo配置中心设计</a></li><li><a href="https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97#24-kubernetes%E9%83%A8%E7%BD%B2" target="_blank" rel="noopener">基于Kubernetes原生服务发现</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>配置中心</tag>
        <tag>apollo</tag>
        <tag>helm</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes 配置 https 证书</title>
    <url>/p/93fd.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>上周在做主站从 http 迁移 https 的过程中发生了严重了事故，明明只设置了主域名生效 https 证书，但是最后问题是所有的子域名也都自动发起 https 请求，导致多个业务子域名无法正常访问。</p><p>先整理回忆一下整个迁移过程：</p><h2 id="申请-https-证书"><a href="#申请-https-证书" class="headerlink" title="申请 https 证书"></a>申请 https 证书</h2><p>我们的域名是在阿里云上采购的，也托管在阿里云上，对比了几个渠道的 https 的证书，价格也差不多，索引就在<a href="https://yundun.console.aliyun.com/" target="_blank" rel="noopener">阿里云</a> 上采购了，购买证书找个最便宜的就可以了，免费证书只能针对单域名，我们买了一个通配符域名，通配符域名有个小小的小坑，域名只能到子域名级，不能再到下一级，如果确实有需求，那要继续采购子域名的通配符域名。</p><blockquote><p>例如：<em>.aliyun.com的通配符证书只能对a.aliyun.com、b.aliyun.com域名进行保护。如果存在a.b.aliyun.com的域名需要购买</em>.b.aliyun.com的通配符证书</p></blockquote><p>托管服务就是可以在证书过期之前，自动更新证书，目前我也不清楚是下发一个新的证书，还是给老的证书续费，可以暂时不购买，意义不是特别大，我们选择成本最低的形式。</p><blockquote><p>还有一点 https 证书有效期都只有一年，如果有骗子说两年三年或者更多那骗术就毫无技术含量。</p></blockquote><p>采购成功需要填写申请的域名，这里有个域名所有权的问题，现在流行且方便的方法是添加一条 TXT 的 DNS 解析，如果是阿里云上采购的域名这里都是一键操作的很方便，申请成功后一般五分钟就能拿到证书。我们选择下载适配 nginx 的证书，后面备用。</p><h2 id="配置-ingress"><a href="#配置-ingress" class="headerlink" title="配置 ingress"></a>配置 ingress</h2><p>前面已经下载到 https 证书，在正式配置 ingress 之前，我们需要将证书的内容配置到配置到 kubernetes 的 secret 里面，当然有很多方法，我们选择最简单的方式，<code>kubectl create secret tls secret名字 --key key的路径 --cert pem路径</code>。</p><p>这里我的一个习惯是在给 secret 命名上，如果是单域名 <code>example-com-ingress-secret</code>，如果是多域名前面加上一个 <code>x</code>，后面 ingress 配置上需要用到这个自己命名的 key。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl create secret tls xxxx-com-ingress-secret --key xxx.com.key   --cert xxx.com.pem</span><br></pre></td></tr></table></figure><p>接下来就是配置 ingress 部分，我这里用的是 helm，直接修改 value 即可：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ingress:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">annotations:</span> <span class="string">&#123;&#125;</span></span><br><span class="line">    <span class="comment"># kubernetes.io/ingress.class: nginx</span></span><br><span class="line">    <span class="comment"># kubernetes.io/tls-acme: "true"</span></span><br><span class="line">  <span class="attr">hosts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">xxx.com</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">secretName:</span> <span class="string">xxxx-com-ingress-secret</span></span><br><span class="line">      <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">xxx.com</span></span><br></pre></td></tr></table></figure><p>如果是直接使用 ingress，那么 spec 如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">xxx.com</span></span><br><span class="line">      <span class="attr">http:</span></span><br><span class="line">        <span class="attr">paths:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">backend:</span></span><br><span class="line">              <span class="attr">serviceName:</span> <span class="string">xxx-svc</span></span><br><span class="line">              <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">xxx.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">xxxx-com-ingress-secret</span></span><br></pre></td></tr></table></figure><h2 id="面临两个问题"><a href="#面临两个问题" class="headerlink" title="面临两个问题"></a>面临两个问题</h2><h3 id="所有-http-协议的请求都无法正常访问，会-308-重定向到-https-协议上"><a href="#所有-http-协议的请求都无法正常访问，会-308-重定向到-https-协议上" class="headerlink" title="所有 http 协议的请求都无法正常访问，会 308 重定向到 https 协议上"></a>所有 http 协议的请求都无法正常访问，会 308 重定向到 https 协议上</h3><p>因为有很多项目都是跑在 http 协议上，直接重定向到 https 会导致很多 api 不可用，所以我们需要保留 http 和 https 协议并行的方式，然后逐步将 http 协议替换成 https</p><h3 id="所有子域名也都被-307-重定向到-https-协议上"><a href="#所有子域名也都被-307-重定向到-https-协议上" class="headerlink" title="所有子域名也都被 307 重定向到 https 协议上"></a>所有子域名也都被 307 重定向到 https 协议上</h3><blockquote><p>这里也想纠正一下域名的称呼，com 为一级域名，xxx.com 为二级域名，yyy.xxx.com 为xxx.com 的子域名，xxx.com 为 yyy.xxx.com 父域名。</p></blockquote><p>其实这里是最奇怪的一块，阿里云的 dns 解析只配置了 <code>@.xxx.com</code> 解析到 ingress 关联的 slb 的 ip，其他的子域名我都没有处理，难道 yy.xxx.com 的 dns 解析会先经过 xxx.com 的解析，去查了一些资料，这是不可能的情况。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="http-和-https-协议并行"><a href="#http-和-https-协议并行" class="headerlink" title="http 和 https 协议并行"></a>http 和 https 协议并行</h3><p>这里我联系了阿里云的技术，找到 nginx-ingress-controller 所关联的 configmap ，找到 key 为 <code>nginx-configuration</code> 的 configmap，添加两行 <code>force-ssl-redirect: &#39;false</code> 和 <code>ssl-redirect: &#39;false&#39;</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  proxy-body-size: 20m</span><br><span class="line">  force-ssl-redirect: &#39;false&#39;</span><br><span class="line">  ssl-redirect: &#39;false&#39;</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubectl.kubernetes.io&#x2F;last-applied-configuration: &#39;&#39;</span><br><span class="line">  labels:</span><br><span class="line">    app: ingress-nginx</span><br><span class="line">  name: nginx-configuration</span><br><span class="line">  namespace: kube-system</span><br></pre></td></tr></table></figure><h3 id="子域名不跳转-https"><a href="#子域名不跳转-https" class="headerlink" title="子域名不跳转 https"></a>子域名不跳转 https</h3><p><img src="https://upload-images.jianshu.io/upload_images/1196536-704358229830638f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/1196536-4259402baf3fcc22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>重新打开 Chrome，仔细分析发起的请求，看到一个关键词 <strong>HSTS</strong>，顺藤摸瓜看到了一个新的安全协议。这套协议让全站 https 变为了更为严格的模式 。</p><h2 id="为什么是-HSTS？"><a href="#为什么是-HSTS？" class="headerlink" title="为什么是 HSTS？"></a>为什么是 HSTS？</h2><p>在浏览器请求域名的时候，是会发起一个 http 请求，服务端接受到 http 请求再重定向到 https 协议上，后面的请求都建立于 https 协议上所以是安全的，但是问题在于发起的第一次 http 请求可能会被劫持，如果第一次请求被劫持了后面的内容也可能就不是从主站发过来的了。</p><p>为此 IETF 规定，在第一次成功发起 https 请求之后会在 response header 中添加一行 <code>strict-transport-security: max-age=15724800; includeSubDomains</code>，这就表明接下来浏览器如果访问 http 请求的时候<strong>不再向服务端发起</strong>而直接<strong>在本地重定向</strong>到 https 上，max-age 表示这个本地重定向的有效期，过期之后仍然会向服务端发起请求。<code>includeSubDomains</code> 这也是本次出问题的主凶，表明接下来这个域名的子域名也同样服从父域名的规则，<code>http://yyy.xxx.com</code> 也会本地直接重定向到 <code>https://yyy.xxx.com</code> ，所以就是这个原因感觉影响到了子域名的解析。</p><p>这里有杠精肯定想说我要是一次没有访问过 <code>xxx.com</code>，就拿不到第一次成功访问 https 的header，所以访问一个特别陌生网站还是可能被攻击，对！所以 IETF 又提供了一招，在浏览器里面内置了一系列 https 的网站的名单，如果访问这些网址是不需要像服务器发起一个 http 请求的，我们也可以向 <a href="https://hstspreload.org/" target="_blank" rel="noopener">https://hstspreload.org/</a> 提供自己的域名，hstspreload 上面的域名最终会被 Chrome、火狐等浏览器内置到内核当中。</p><h2 id="回头解决子域名不跳转-https"><a href="#回头解决子域名不跳转-https" class="headerlink" title="回头解决子域名不跳转 https"></a>回头解决子域名不跳转 https</h2><p>根据 ingress-nginx 官网提供的解决方案，可以添加 <code>hsts-include-subdomains</code> 字段，这样在第一次成功发起 https 请求之后会在 response header 中添加 <code>strict-transport-security: max-age=15724800</code>，没有 <strong>includeSubDomains</strong>，这样子域名就可以走自己的 dns 逻辑。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">proxy-body-size:</span> <span class="string">20m</span></span><br><span class="line">  <span class="attr">force-ssl-redirect:</span> <span class="string">'false'</span></span><br><span class="line">  <span class="attr">ssl-redirect:</span> <span class="string">'false'</span></span><br><span class="line">  <span class="attr">hsts-include-subdomains:</span> <span class="string">'false'</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">''</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">ingress-nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-configuration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>互联网领域是绝对的错综复杂，各种协议交互穿插，都是为了维护这个不安全不可信的网络</li><li>个人觉得对于 ingress-nginx 这个扩展还是很多改进的地方，不可以在单路的一个地方配置 https 证书，而是把证书配置分散在各个 ingress 文件中，从而不好管理证书</li><li>HSTS 协议简洁且强大，当然这些也都需要浏览器的配合，一个先进的浏览器本身就带着安全的光芒。</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><p><a href="https://blog.csdn.net/u014311799/article/details/79037717" target="_blank" rel="noopener">HSTS详解</a></p></li><li><p><a href="https://www.cnblogs.com/tugenhua0707/p/10945934.html" target="_blank" rel="noopener">nginx开启HSTS让浏览器强制跳转HTTPS访问</a></p></li><li><p><a href="https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/" target="_blank" rel="noopener">ingress-nginx-configmap</a></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>ingress</tag>
        <tag>hsts</tag>
        <tag>includeSubDomains</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 mysql 事务中的自增 id 的疑问</title>
    <url>/p/da75.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><ul><li>mysql 的自增 id 在事务回滚后会怎么样？</li><li>mysql 的自增 id 是什么时候生成 id 的？</li></ul><h1 id="开始一个试验："><a href="#开始一个试验：" class="headerlink" title="开始一个试验："></a>开始一个试验：</h1><h2 id="创建了一个表，并查看表结构"><a href="#创建了一个表，并查看表结构" class="headerlink" title="创建了一个表，并查看表结构"></a>创建了一个表，并查看表结构</h2><p>id 自增，name 为字符串类型</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt;  describe a;</span><br><span class="line">+-------+------------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra          |</span><br><span class="line">+-------+------------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int(10) unsigned | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(255)     | YES  |     | NULL    |                |</span><br><span class="line">+-------+------------------+------+-----+---------+----------------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure><h2 id="开启一个事务-a，并插入-name-aa"><a href="#开启一个事务-a，并插入-name-aa" class="headerlink" title="开启一个事务 a，并插入 name=aa"></a>开启一个事务 a，并插入 name=aa</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; begin;</span><br><span class="line"><span class="variable">$mysql</span>&gt; insert into a(`name`) values(<span class="string">'aa'</span>);</span><br></pre></td></tr></table></figure><h2 id="查看-table-中的数据"><a href="#查看-table-中的数据" class="headerlink" title="查看 table 中的数据"></a>查看 table 中的数据</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; select * from a;</span><br><span class="line">Empty <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>table 依然为空，开启事务后在没有 commit 的情况下，是没有修改 table 的。</p><h2 id="开启一另个事务-b，并插入-name-bb"><a href="#开启一另个事务-b，并插入-name-bb" class="headerlink" title="开启一另个事务 b，并插入 name=bb"></a>开启一另个事务 b，并插入 name=bb</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="variable">$mysql</span>&gt; insert into a(`name`) values(<span class="string">'bb'</span>);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="variable">$mysql</span>&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里将事务 b 直接提交</p><h2 id="查看-table-中的数据-1"><a href="#查看-table-中的数据-1" class="headerlink" title="查看 table 中的数据"></a>查看 table 中的数据</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; select * from a;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  2 | bb   |</span><br><span class="line">+----+------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>由于事务 b 提交了，插入了一行数据，id 为 2，所以这里生成 id 是在插入的时候。</p><h2 id="重新回到事务-a"><a href="#重新回到事务-a" class="headerlink" title="重新回到事务 a"></a>重新回到事务 a</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; begin;</span><br><span class="line"><span class="variable">$mysql</span>&gt; insert into a(`name`) values(<span class="string">'aa'</span>);</span><br><span class="line"><span class="variable">$mysql</span>&gt; commit;</span><br></pre></td></tr></table></figure><p>这个时候开始提交事务 a</p><h2 id="查看-table-中的数据-2"><a href="#查看-table-中的数据-2" class="headerlink" title="查看 table 中的数据"></a>查看 table 中的数据</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; select * from a;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | aa   |</span><br><span class="line">|  2 | bb   |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>事务 a 和 b 都提交成功，上一个事务 a 的插入的数据项也出现了。</p><h1 id="这里再做一轮实验"><a href="#这里再做一轮实验" class="headerlink" title="这里再做一轮实验"></a>这里再做一轮实验</h1><h2 id="开启一个事务-c，并插入-name-cc"><a href="#开启一个事务-c，并插入-name-cc" class="headerlink" title="开启一个事务 c，并插入 name=cc"></a>开启一个事务 c，并插入 name=cc</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; begin;</span><br><span class="line"><span class="variable">$mysql</span>&gt; insert into a(`name`) values(<span class="string">'cc'</span>);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="开启另一个事务-d，并插入-name-dd"><a href="#开启另一个事务-d，并插入-name-dd" class="headerlink" title="开启另一个事务 d，并插入 name=dd"></a>开启另一个事务 d，并插入 name=dd</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; begin;</span><br><span class="line"></span><br><span class="line"><span class="variable">$mysql</span>&gt; insert into a(`name`) values(<span class="string">'dd'</span>);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="variable">$mysql</span>&gt; commit;</span><br></pre></td></tr></table></figure><h2 id="查看-table"><a href="#查看-table" class="headerlink" title="查看 table"></a>查看 table</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; select * from a;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | aa   |</span><br><span class="line">|  2 | bb   |</span><br><span class="line">|  4 | dd   |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="回到事务-c，并进行回滚"><a href="#回到事务-c，并进行回滚" class="headerlink" title="回到事务 c，并进行回滚"></a>回到事务 c，并进行回滚</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; begin;</span><br><span class="line"><span class="variable">$mysql</span>&gt; insert into a(`name`) values(<span class="string">'cc'</span>);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="variable">$mysql</span>&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="查看-table-1"><a href="#查看-table-1" class="headerlink" title="查看 table"></a>查看 table</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mysql</span>&gt; select * from a;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | aa   |</span><br><span class="line">|  2 | bb   |</span><br><span class="line">|  4 | dd   |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>由于事务 c 回滚，事务 d 提交成功，所以 table 中确实是少了一行数据。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="mysql-的自增-id-是什么时候生成-id-的？"><a href="#mysql-的自增-id-是什么时候生成-id-的？" class="headerlink" title="mysql 的自增 id 是什么时候生成 id 的？"></a>mysql 的自增 id 是什么时候生成 id 的？</h2><p>自增 id，是在插入的时候就已经生成了，事务并不影响 id 的自增。</p><h2 id="mysql-的自增-id-在事务回滚后会怎么样？"><a href="#mysql-的自增-id-在事务回滚后会怎么样？" class="headerlink" title="mysql 的自增 id 在事务回滚后会怎么样？"></a>mysql 的自增 id 在事务回滚后会怎么样？</h2><p>如果事务回滚，table 对应的数据行就会缺失，id 也会缺失，自增 id 和事务是独立的，互不影响。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS之CNAME</title>
    <url>/p/b804.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>DNS 的原理就是一层层从根域名递归查询，其中让我觉得有疑问的就是 <strong>CNAME</strong>。</p><p>反复使用命令查询七牛的官网，我知道他们一定会使用 CDN，CDN 也是 CNAME 使用最多的场景。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig qiniu.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; qiniu.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 14562</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;qiniu.com.			IN	A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">qiniu.com.		212	IN	CNAME	mid-lvs-public.qiniu.com.</span><br><span class="line">mid-lvs-public.qiniu.com. 212	IN	CNAME	jjh-lvs-public.qiniu.com.</span><br><span class="line">jjh-lvs-public.qiniu.com. 212	IN	A	180.97.147.243</span><br><span class="line"></span><br><span class="line">;; Query time: 72 msec</span><br><span class="line">;; SERVER: 223.5.5.5<span class="comment">#53(223.5.5.5)</span></span><br><span class="line">;; WHEN: Mon Aug 10 18:41:59 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 101</span><br></pre></td></tr></table></figure><p>可以看到路径是这样子的 <code>qiniu.com.</code> =&gt; <code>mid-lvs-public.qiniu.com.</code> =&gt; <code>jjh-lvs-public.qiniu.com.</code> =&gt; 给了一个 A 记录 <code>180.97.147.243</code>。</p><p>最终我们的请求肯定也都是发到 A 记录上，也就是将 qiniu.com 交到 <code>180.97.147.243</code>，这个 IP 对应的服务接受到请求才开始往客户端吐数据。</p><p>CNAME 提供一个窍门将解析 A 记录的权利交到下一个域名上，具体下一个域名对应的 ip 可能以后会变，但是对于上一个域名所对应的域名不会变，这个点很像 JAVA 中的一个接口，接口的实现可能会变，但是接口名和方法名提前就确定好了。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://en.wikipedia.org/wiki/CNAME_record" target="_blank" rel="noopener">wiki</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener">DNS 原理入门-阮一峰</a></li><li><a href="https://draveness.me/dns-coredns/" target="_blank" rel="noopener">详解 DNS 与 CoreDNS 的实现原理</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>CNAME</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 horizon 多副本问题</title>
    <url>/p/f584.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>系统的数据量也比较小，所以 horizon 始终也只起了一份，也担心 horizon 起了多份会造成代码重复执行。</p><p>所以就做了如下实验：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose scale laravel-horizon=10</span><br></pre></td></tr></table></figure><p>本地的使用的是 laradock ，所以很容易就将 laravel-horizon 扩展了 10 个副本，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose ps</span><br><span class="line">           Name                          Command               State                    Ports</span><br><span class="line">---------------------------------------------------------------------------------------------------------------</span><br><span class="line">laradock_docker-in-docker_1   dockerd-entrypoint.sh            Up      2375/tcp</span><br><span class="line">laradock_laravel-horizon_1    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_10   /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_2    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_3    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_4    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_5    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_6    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_7    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_8    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_laravel-horizon_9    /usr/bin/supervisord -n -c ...   Up</span><br><span class="line">laradock_mysql_1              docker-entrypoint.sh mysqld      Up      0.0.0.0:3306-&gt;3306/tcp, 33060/tcp</span><br><span class="line">laradock_nginx_1              /bin/bash /opt/startup.sh        Up      0.0.0.0:443-&gt;443/tcp, 0.0.0.0:80-&gt;80/tcp</span><br><span class="line">laradock_php-fpm_1            docker-php-entrypoint php-fpm    Up      9000/tcp</span><br><span class="line">laradock_redis_1              docker-entrypoint.sh redis ...   Up      0.0.0.0:6379-&gt;6379/tcp</span><br><span class="line">laradock_workspace_1          /sbin/my_init                    Up      0.0.0.0:2222-&gt;22/tcp</span><br></pre></td></tr></table></figure><p>在工程里面 <code>php artisan make:job TestJob</code> 再定义一个 job：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Jobs</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Bus</span>\<span class="title">Queueable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Contracts</span>\<span class="title">Queue</span>\<span class="title">ShouldQueue</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Bus</span>\<span class="title">Dispatchable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">InteractsWithQueue</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Queue</span>\<span class="title">SerializesModels</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Redis</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestJob</span> <span class="keyword">implements</span> <span class="title">ShouldQueue</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Dispatchable</span>, <span class="title">InteractsWithQueue</span>, <span class="title">Queueable</span>, <span class="title">SerializesModels</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new job instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Execute the job.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        cache()-&gt;increment(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Job：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">dispatch(<span class="keyword">new</span> TestJob);</span><br></pre></td></tr></table></figure><p>通过 <code>$ docker-compose up -d redis-webui</code> 可以起一个 web 页面，页面中可以看到对应的 key 是每次都加一，而不是加十，所以这里推测是任务被一个 horizon 进程接受到了，就会加锁，防止其他进程继续去执行任务。</p><p><img src="https://upload-images.jianshu.io/upload_images/1196536-411574f08593d24d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>horizon</tag>
      </tags>
  </entry>
  <entry>
    <title>trap 命令</title>
    <url>/p/9c63.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>我在通过七牛给的可执行文件进行推送文件到 cdn 的时候，发现总是命令行总是返回 1。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qshell qupload2 --thread-count=5 --src-dir=.nuxt/dist/client --bucket=nalanda-cdn --overwrite=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Uploading ...</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> $? </span><br><span class="line">1</span><br></pre></td></tr></table></figure><blockquote><p>这里有个技巧 <code>$?</code> 可以输出上一条命令的返回值。</p></blockquote><p>我这边有个逻辑是在打包成功之后，将 <strong>.nuxt/dist/client</strong> 文件夹下面的内容上传到七牛的 cdn，静态文件可以更快的下载运行，但是脚本每次都返回 1，导致下面的脚本无法执行，所以我想要截获 exit 1 这个事件，巧好让我看到了 linux 中另外一个命令 <code>trap</code>。</p><p>trap 是可以捕获 exit 时候的信号，怪不得我以前碰到过执行 <strong>CTRL + C</strong>，后面还可以输出一段命令，提醒我退出成功；以及 skaffold dev 在我执行 <strong>CTRL + C</strong>，它会将已经部署的资源进行清理，原理都是劫持了信号量，可以做一些特殊的操作。</p><p>所以这里我就要劫持一下 qshell qupload2 执行成功的时候将 SIGHUP 变成正常的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">trap</span> <span class="string">"echo 'EXIT 1'"</span> SIGHUP</span><br></pre></td></tr></table></figure><p>第二个字段可以随便写一段脚本，什么都不执行，可以留空。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://blog.csdn.net/Maybe_Lee/article/details/78604927" target="_blank" rel="noopener">shell脚本中判断上一个命令是否执行成功</a></li><li><a href="https://man.linuxde.net/trap" target="_blank" rel="noopener">trap命令</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>trap</tag>
        <tag>skaffold</tag>
      </tags>
  </entry>
  <entry>
    <title>phpredis</title>
    <url>/p/7fed.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>php 中操作 redis 一般使用 phpredis 这个扩展，redis 中是可以执行 lua 脚本，今天接触的一个<code>分布式锁</code>框架正是利用了 lua 脚本操作 redis 可以保持原子性。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">unLock</span><span class="params">()</span> : <span class="title">bool</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $lua = <span class="string">&lt;&lt;&lt;LUA</span></span><br><span class="line"><span class="string">                local hashVal = redis.call("GET", KEYS[1]);</span></span><br><span class="line"><span class="string">                if (hashVal ~=  ARGV[1]) then</span></span><br><span class="line"><span class="string">                    return 0;</span></span><br><span class="line"><span class="string">                end;</span></span><br><span class="line"><span class="string">                </span></span><br><span class="line"><span class="string">                return redis.call("DEL", KEYS[1]);</span></span><br><span class="line"><span class="string">LUA;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            $eval = <span class="keyword">$this</span>-&gt;getConnection()-&gt;eval($lua, [<span class="keyword">$this</span>-&gt;key, <span class="keyword">$this</span>-&gt;value], <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ($eval) &#123;</span><br><span class="line">                CLog::debug(</span><br><span class="line">                    <span class="string">'worker[%s] co[%s]successful release unlock'</span>,</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;getWorkId(),</span><br><span class="line">                    Co::tid()</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> (bool) $eval;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">            CLog::error($e-&gt;getMessage());</span><br><span class="line">            <span class="keyword">throw</span> $e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>eval 正是执行 lua 脚本的方法，第一个参数为 lua 脚本，第二个参数是传进 lua 中的kv 参数，<strong>第三个参数表示有几对参数</strong>。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.cnblogs.com/taijun/p/5007329.html" target="_blank" rel="noopener">PHP中使用redis执行lua脚本示例</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Tengine中应用 ngx_http_limit_req_module</title>
    <url>/p/7de5.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>nginx 中安装 ngx_http_limit_req_module 模块各种源码编译安装还是比较复杂，既然有现成的 Tengine，故尝试使用 Tengine 替换 nginx。</p><p>由于 Tengine 完全兼容 nginx 语法，只需要额外调整个别参数就能变成一个高性能服务，官方文档比较坑，有个别地方写错了，这么多年过去了，也没人去修改。</p><p>重点：</p><ul><li><code>limit_req_zone</code> 需要放在 conf 的 http 下面。</li><li><code>limit_req</code> 需要放在 conf 的 location 下面。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line"># This number should be, at maximum, the number of CPU cores on your system.</span><br><span class="line">worker_processes auto; # Tengine 专有写法，等于 cpu 个进程</span><br><span class="line">worker_cpu_affinity auto; # Tengine 专有写法，自动绑定 cpu 进程亲和性</span><br><span class="line"></span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log error;</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    # The effective method, used on Linux 2.6+, optmized to serve many clients with each thread.</span><br><span class="line">    use epoll;</span><br><span class="line">    # Determines how many clients will be served by each worker process.</span><br><span class="line">    worker_connections 65535; # 建议调整最大</span><br><span class="line">    # Accept as many connections as possible, after nginx gets notification about a new connection.</span><br><span class="line">    multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #long time</span><br><span class="line">    check_shm_size 5M;</span><br><span class="line">    # Allow the server to close the connection after a client stops responding.</span><br><span class="line">    reset_timedout_connection on;</span><br><span class="line">    client_header_timeout 15;</span><br><span class="line">    # Send the client a &quot;request timed out&quot; if the body is not loaded by this time.</span><br><span class="line">    client_body_timeout 10;</span><br><span class="line">    # If the client stops reading data, free up the stale client connection after this much time.</span><br><span class="line">    send_timeout 15;</span><br><span class="line">    # Timeout for keep-alive connections. Server will close connections after this time.</span><br><span class="line">    keepalive_timeout 30;</span><br><span class="line">    # Number of requests a client can make over the keep-alive connection.</span><br><span class="line">    keepalive_requests 30;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    client_body_buffer_size 128k;</span><br><span class="line">    client_max_body_size 10m;</span><br><span class="line">    proxy_read_timeout 180s;</span><br><span class="line"></span><br><span class="line">    # Compression.</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 10240;</span><br><span class="line">    gzip_proxied expired no-cache no-store private auth;</span><br><span class="line">    gzip_types text&#x2F;plain text&#x2F;css text&#x2F;xml text&#x2F;javascript application&#x2F;x-javascript application&#x2F;xml;</span><br><span class="line">    gzip_disable &quot;msie6&quot;;</span><br><span class="line"></span><br><span class="line">    # Sendfile copies data between one FD and other from within the kernel.</span><br><span class="line">    sendfile on;</span><br><span class="line">    # Don&#39;t buffer data-sends (disable Nagle algorithm).</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    # Causes nginx to attempt to send its HTTP response head in one packet,  instead of using partial frames.</span><br><span class="line">    tcp_nopush on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # Hide web server information</span><br><span class="line">    server_tokens off;</span><br><span class="line">    server_info off;</span><br><span class="line">    server_tag off;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page</span><br><span class="line">    error_page 404             &#x2F;404.html;</span><br><span class="line">    error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line"></span><br><span class="line"># 定义一个空间变量，允许每秒请求 2 次，分配 100m 内存存储ip信息</span><br><span class="line">    limit_req_zone $binary_remote_addr $request_uri zone&#x3D;req_limit:100m rate&#x3D;2r&#x2F;s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># geo 定义 ip 地址 ，两种方法，一种是指定单个ip，另外一种是声明 ranges，指定ip范围</span><br><span class="line">    geo $white_ip_single &#123;</span><br><span class="line">        default 0;</span><br><span class="line">        39.156.69.79 1;</span><br><span class="line">        39.156.69.80 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    geo $white_ip_range &#123;</span><br><span class="line">        ranges;</span><br><span class="line">        default 0;</span><br><span class="line">        39.156.69.79~39.156.69.255 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    limit_req_whitelist geo_var_name&#x3D;white_ip_single geo_var_value&#x3D;1;</span><br><span class="line">    limit_req_whitelist geo_var_name&#x3D;white_ip_range geo_var_value&#x3D;1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    upstream swoft-upstream &#123;</span><br><span class="line">        server swoft:18316;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">            server_name &quot;localhost&quot;;</span><br><span class="line">            listen 80 default_server;</span><br><span class="line">            listen [::]:80 default_server ipv6only&#x3D;on;</span><br><span class="line">            index index.html index.htm;</span><br><span class="line">            charset utf-8;</span><br><span class="line"></span><br><span class="line">            location &#x2F; &#123;</span><br><span class="line">            	# 根据上面定义的 zone 限制请求 但是允许浮动 5个请求</span><br><span class="line">                limit_req zone&#x3D;req_limit burst&#x3D;5;</span><br><span class="line">                # proxy_redirect  off;</span><br><span class="line">                proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">                proxy_http_version 1.1;</span><br><span class="line">              #  proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">              #  proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">                proxy_set_header Connection &quot;keep-alive&quot;;</span><br><span class="line">                proxy_pass http:&#x2F;&#x2F;swoft-upstream;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            location ~ &#x2F;\.(?!well-known).* &#123;</span><br><span class="line">                deny all;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接粘贴 conf 文件了，不过多解释了。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="http://tengine.taobao.org/documentation_cn.html" target="_blank" rel="noopener">Tengine官方文档</a></li><li><a href="https://www.cnblogs.com/duanxz/p/3967033.html" target="_blank" rel="noopener">ngx_http_limit_req_module模块</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>Tengine</tag>
      </tags>
  </entry>
  <entry>
    <title>php7.4扩展开发</title>
    <url>/p/ca7e.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>php 的底层是由 c/c++ 实现的，所以 php 本身就是一层皮，而我们也可以通过开发一些扩展来增强 php。可以通过 <code>php -m</code> 或 <code>phpinfo()</code>来查看环境中已安装的扩展，目前最新的 php 版本为 7.4.6 ，所以直接以 php7.4 为例。</p><h1 id="查看-php-版本"><a href="#查看-php-版本" class="headerlink" title="查看 php 版本"></a>查看 php 版本</h1><p>因为本地的 php 运行环境是通过 docker 起的，这里也安利一波 <a href="https://laradock.io/" target="_blank" rel="noopener">laradock</a> 环境模板，本地的测试环境用起来实在是很舒服，又很自由。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">exec</span> workspace bash // 非 laradock 忽略</span><br><span class="line">$ php -v</span><br><span class="line"></span><br><span class="line">PHP 7.4.0 (cli) (built: Nov 28 2019 07:26:50) ( NTS )</span><br><span class="line">Copyright (c) The PHP Group</span><br><span class="line">Zend Engine v3.4.0, Copyright (c) Zend Technologies</span><br><span class="line">    with Zend OPcache v7.4.0, Copyright (c), by Zend Technologies</span><br></pre></td></tr></table></figure><p>这边确认一下自己的 php 版本确实为 7.4。</p><h1 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h1><p>我们需要下载 php 的官方源码，选择自己对应的版本。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -O https://www.php.net/distributions/php-7.4.6.tar.bz2</span><br></pre></td></tr></table></figure><blockquote><p>也可以通过官网去获取，<a href="https://www.php.net/downloads" target="_blank" rel="noopener">www.php.net</a>，锁定自己的大版本即可，例如 7.2、7.3、7.4。</p></blockquote><p>解压源码</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -jxvf php-7.4.6.tar.bz2</span><br></pre></td></tr></table></figure><h1 id="生成扩展"><a href="#生成扩展" class="headerlink" title="生成扩展"></a>生成扩展</h1><p>进入源码目录下 ext 目录，可以下面有个 <code>ext_skel.php</code> 文件，该文件是用来生成扩展工程的脚手架命令。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ext</span><br><span class="line">$ php ext_skel.php --ext foobar </span><br><span class="line"></span><br><span class="line">Copying config scripts... <span class="keyword">done</span></span><br><span class="line">Copying sources... <span class="keyword">done</span></span><br><span class="line">Copying tests... <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">Success. The extension is now ready to be compiled. To <span class="keyword">do</span> so, use the</span><br><span class="line">following steps:</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /path/to/php-src/foobar</span><br><span class="line">phpize</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">Don<span class="string">'t forget to run tests once the compilation is done:</span></span><br><span class="line"><span class="string">make test</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Thank you for using PHP!</span></span><br></pre></td></tr></table></figure><p>foobar 为扩展名称，foobar 文件夹就是骨架工程了，对于 php7 是不需要对 php_foobar.h 和 foobar.c 文件做任何其他变更，可以直接添加自己需要的函数。</p><p>打开 foobar.c 找一个有利的位置添加以下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PHP_FUNCTION(hello)</span><br><span class="line">&#123;</span><br><span class="line">    php_printf(<span class="string">"hello world2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实模仿上下的 foobar_test1 foobar_test2 也就大概知道放在什么位置了，PHP_FUNCTION 函数上下的注释目前我也不知道有啥用，经测试不影响代码运行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> zend_function_entry foobar_functions[] = &#123;</span><br><span class="line">	PHP_FE(hello,	<span class="literal">NULL</span>	) <span class="comment">// 增加这一行</span></span><br><span class="line">	PHP_FE(foobar_test1,		arginfo_foobar_test1)</span><br><span class="line">	PHP_FE(foobar_test2,		arginfo_foobar_test2)</span><br><span class="line">	PHP_FE_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个参数为函数名，第二个为函数参数吧(暂不确定)。</p><h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ phpize</span><br><span class="line">$ ./configure</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>一坨一坨输出飞过，留下了一个 so 文件，modules 文件夹下可以看到这个产物，如果 php 运行环境和上面的扩展生成环境是一样的，执行 <code>make install</code> ，会将 so 文件移动到 php 扩展的默认文件路径下。如果像我一样，他们不是一个环境也没有关系。</p><h1 id="ini-添加扩展"><a href="#ini-添加扩展" class="headerlink" title="ini 添加扩展"></a>ini 添加扩展</h1><p>打开 php.ini 配置文件最下面添加一行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension&#x3D;foobar.so &#x2F;&#x2F; make install 之后可以直接填写扩展的文件名 OR</span><br><span class="line">extension&#x3D;&#x2F;var&#x2F;www&#x2F;phpext&#x2F;ext&#x2F;foobar&#x2F;modules&#x2F;foobar.so &#x2F;&#x2F; 其实也可以写绝对路径</span><br></pre></td></tr></table></figure><h1 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h1><ul><li>cli 环境可以执行 <code>php -r &quot;hello();echo PHP_EOL;&quot;;</code></li><li>cgi 环境可以在代码中执行 hello();</li></ul><p>都可以看到最终 “hello world2” 输出，这就是通过 c 代码编写的输出结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只是一个练手项目和什么 pdo gd 类的扩展那不是一个层次的。有了扩展开发就能调用更底层的系统接口，和更复杂的计算型任务。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="http://lukachen.com/archives/248/" target="_blank" rel="noopener">php 扩展开发 从入门到放弃(一)</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>php扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>app中使用h5支付</title>
    <url>/p/58ad.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>因为苹果爸爸的各种封锁与限制，导致 app 中如果集成支付sdk上架会变得十分困难，总之是想办法去抽成。为了应对这种流氓政策，各小 app 公司纷纷偷梁换柱，通过 h5 支付从而绕开 sdk 支付。</p><p>常规的什么申请秘钥，配置回调地址等操作全部忽略了，直接进入核心步骤</p><h1 id="支付宝支付"><a href="#支付宝支付" class="headerlink" title="支付宝支付"></a>支付宝支付</h1><h2 id="使用支付宝-h5-支付"><a href="#使用支付宝-h5-支付" class="headerlink" title="使用支付宝 h5 支付"></a>使用支付宝 h5 支付</h2><p>支付宝的 h5 支付，返回一个 http 链接，是可以直接在 webview 中使用的，url 会重定向最终指向到支付宝的专属协议上。这里建议直接在 app 上直接通过 new webview 方式实现。</p><h1 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h1><h2 id="使用微信-h5-支付"><a href="#使用微信-h5-支付" class="headerlink" title="使用微信 h5 支付"></a>使用微信 h5 支付</h2><p>通过微信 h5 支付也是可以生成支付链接的，如果我们直接使用这个 url 的话，一定会抛一个错误“商家参数格式有误，请联系商家解决”，<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4" target="_blank" rel="noopener">微信支付的错误解决方案</a>中已经给出了原因，微信在这里校验了 http 请求中的 referer ，我们直接打开 url 请求头中是没有 referer 字段的，最容易想到的是通过 html 中的 a 标签跳转页面，a 标签会默认携带当前页面的主机地址。</p><h2 id="使用中转页面"><a href="#使用中转页面" class="headerlink" title="使用中转页面"></a>使用中转页面</h2><p>所以就写了一个简单的中转页面，逻辑很简单，在中转链接中添加一个 pay_url 字段，pay_url 就是微信 h5 支付生成的链接，需要进行 encode 编码一下，我们可以在 js 里面重新解码，设置 a 标签的 href 熟悉，执行点击进行跳转。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>正在支付<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  正在支付。。。</span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"a"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">getQueryVariable</span><span class="params">(variable)</span></span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> query = <span class="built_in">window</span>.location.search.substring(<span class="number">1</span>);</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">var</span> vars = query.split(<span class="string">"&amp;"</span>);</span></span><br><span class="line"><span class="actionscript">       <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;vars.length;i++) &#123;</span></span><br><span class="line"><span class="actionscript">               <span class="keyword">var</span> pair = vars[i].split(<span class="string">"="</span>);</span></span><br><span class="line"><span class="actionscript">               <span class="keyword">if</span>(pair[<span class="number">0</span>] == variable)&#123;<span class="keyword">return</span> pair[<span class="number">1</span>];&#125;</span></span><br><span class="line">       &#125;</span><br><span class="line"><span class="actionscript">       <span class="keyword">return</span>(<span class="literal">false</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> payUrl=getQueryVariable(<span class="string">'pay_url'</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> decodePayUrl=<span class="built_in">decodeURIComponent</span>(payUrl)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(payUrl)</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(decodePayUrl)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">'a'</span>).setAttribute(<span class="string">'href'</span>,decodePayUrl)</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">'a'</span>).click();</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="挂载中转网页"><a href="#挂载中转网页" class="headerlink" title="挂载中转网页"></a>挂载中转网页</h2><p>找个服务器或者 oss 将页面放过去，配置一个域名，因为微信的 h5 支付是绑定了一个主域名，二级域名其实都是可以使用，假如最终配置为<code>pay.abc.com</code>，那么我们最终的跳转链接为 <a href="http://pay.abc.com?pay_url=http://wechatpay.com?xxxxxx。" target="_blank" rel="noopener">http://pay.abc.com?pay_url=http://wechatpay.com?xxxxxx。</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>不管是微信支付还是支付宝支付，其实想从浏览器唤醒支付 app，都是通过特有 schema 唤醒的，支付宝的协议是 alipay://，微信的协议是 weixin://，其实和 http 协议一样，例如：<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a> ，浏览器会捕获 http 协议，支付宝和微信都会捕获属于自己的协议，这一点不管在 android 还是 ios 上，也正是利用了这一点，才使我们 app 中唤醒支付宝或者微信成为可能。当然后面很可能也被限制，在将来相当长的一段时间是不会的，正是这些协议使得 h5 和 app 进行交互才使得如今移动操作系统更加繁荣。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://opendocs.alipay.com/open/203/107090/" target="_blank" rel="noopener">支付宝h5支付</a></li><li><a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=9_20&index=1" target="_blank" rel="noopener">微信h5支付</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title>redis中列表过期技巧</title>
    <url>/p/6c36.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>在操作 redis 的 list 的时候，发现 list 不能设置过期时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LPUSH languages python</span><br></pre></td></tr></table></figure><p>LPUSH 将一个值推送到以 languages 为 key 的列表中，在 push 的时候是没有办法设置过期时间的。<br>所以需要在第一次 push 后设置过期时间。</p><p>写出伪代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$len&#x3D; LLEN languages</span><br><span class="line">if $len &#x3D;&#x3D; 0</span><br><span class="line">	LPUSH languages python</span><br><span class="line">	EXPIRE languages 100 </span><br><span class="line">ELSE</span><br><span class="line">	LPUSH languages python</span><br></pre></td></tr></table></figure><p>发现如果这样操作，每次都需要访问 redis 两遍，当 list 中数据过多时就会有性能问题，简单优化了一下，就可以少访问一遍 redis。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$len&#x3D; LPUSH languages python</span><br><span class="line">if $len &#x3D;&#x3D; 1</span><br><span class="line">	EXPIRE languages 100</span><br></pre></td></tr></table></figure><p>这里的核心点就是 push 函数会放会当前 list 中目前的列表长度。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="http://redisdoc.com/list/lpush.html" target="_blank" rel="noopener">LPUSH</a></li><li><a href="http://redisdoc.com/expire/expire.html" target="_blank" rel="noopener">EXPIRE</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器中文件下载</title>
    <url>/p/e350.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>“浏览器”堪称是计算机历史中一项伟大的发明！互联网早期的应用都是专有应用，都是针对某个领域特殊制作的特殊应用，自从有了浏览器，人们可以看到更轻便和更丰富的内容，这才算走入了寻常百姓家。</p><p>今天发现浏览器有个行为令我十分不解，有些文件的链接放在浏览器里面是直接下载的，而有些则被浏览器直接打开而没有下载。</p><ul><li><p>直接下载的链接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;qcloudoss.xunjiepdf.com&#x2F;xunjiepdf&#x2F;temp&#x2F;20200413&#x2F;1568610660.pdf</span><br></pre></td></tr></table></figure></li><li><p>直接打开的链接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;file.zhile88.com&#x2F;file&#x2F;LkHL6RvF4g5gD8I0_jianlitongguanbibei.pdf</span><br></pre></td></tr></table></figure></li></ul><p>大家都是 http 请求凭什么你比我优秀？<br>随后我分别 curl 了一下链接，分析了他们的区别</p><ul><li>直接下载的链接</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -I http://qcloudoss.xunjiepdf.com/xunjiepdf/temp/20200413/1568610660.pdf</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: TencentCOS</span><br><span class="line">x-cos-storage-class: STANDARD</span><br><span class="line">x-cos-hash-crc64ecma: 4085129986793626390</span><br><span class="line">Content-Type: application/pdf</span><br><span class="line">Content-Disposition: attachment; filename*=<span class="string">"UTF-8''1568610660.pdf"</span></span><br><span class="line">Content-Language: zh-CN</span><br><span class="line">ETag: 617eabf18fced6cd1202b86f3e36656c</span><br><span class="line">x-cos-object-type: normal</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Last-Modified: Mon, 13 Apr 2020 15:52:14 GMT</span><br><span class="line">x-cos-request-type: head</span><br><span class="line">Content-Length: 69626</span><br></pre></td></tr></table></figure><ul><li>直接打开的链接</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -I http://file.zhile88.com/file/LkHL6RvF4g5gD8I0_jianlitongguanbibei.pdf </span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Content-Type: application/pdf</span><br><span class="line">Content-Length: 1440571</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Mon, 13 Apr 2020 06:57:25 GMT</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Access-Control-Expose-Headers: X-Log, X-Reqid</span><br><span class="line">Access-Control-Max-Age: 2592000</span><br><span class="line">Cache-Control: public, max-age=36000000</span><br><span class="line">Content-Disposition: inline; filename=<span class="string">"LkHL6RvF4g5gD8I0_jianlitongguanbibei.pdf"</span>; filename*=utf-8<span class="string">''</span>LkHL6RvF4g5gD8I0_jianlitongguanbibei.pdf</span><br><span class="line">Content-Md5: HhhEZRBLWCJLirG+yhSOeg==</span><br><span class="line">Content-Transfer-Encoding: binary</span><br><span class="line">Etag: <span class="string">"Fpv0_h7Y9qe4Plhlp-UcAwMtqumy"</span></span><br><span class="line">Last-Modified: Mon, 13 Apr 2020 06:41:53 GMT</span><br><span class="line">... 省略无关的header</span><br></pre></td></tr></table></figure><p>头信息中 <code>Content-Disposition</code> 一下就吸引了我，一个是 inline，另一个是 attachment，根据 mozilla 官方文档我得到的信息如下：</p><blockquote><p>在HTTP场景中，第一个参数或者是inline（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是attachment（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将filename的值预填为下载后的文件名，假如它存在的话）。</p></blockquote><p>看到这里一下就解决了我的问题，浏览器自创建之初到现在，陆陆续续也添加着许许多多的约定参数。七牛对于需要下载的文件添加一个参数配置即可，七牛真🐂。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://www.bilibili.com/video/av97883778/" target="_blank" rel="noopener">userAgent 视频</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition" target="_blank" rel="noopener">mozilla doc</a></li><li><a href="https://developer.qiniu.com/kodo/manual/1659/download-setting" target="_blank" rel="noopener">七牛下载设置</a></li></ul><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>手摸手教你搭建 api 网关</title>
    <url>/p/dbb5.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>现在的项目有个需求，需要分析每一条 api 的请求时间，目前看到一套比较好的方案是 <code>kong + Prometheus + Grafana</code>，之前是听说过 kong 扩展性比较好，但一直没有实践的机会，借此机会来玩一玩核武器。</p><p>我熟悉的方式还是 docker，还是用它从头搭建这一套系统。</p><blockquote><p>立个 flag，今年必须学会 <strong>kubernetes</strong>。</p></blockquote><p>参考了多篇文章各取所长，理顺了各个软件之间关系之后，发现网上的这些方法都过于复杂，很多文章也是相互拼凑，容器化不像容器化，其实 kong、Prometheus、Grafana 之间的兼容性已经足够好了，我在操作过程中确实也踩了一些坑，但是我已经可以将他们彻底容器化部署了。</p><h1 id="运行-kong"><a href="#运行-kong" class="headerlink" title="运行 kong"></a>运行 kong</h1><h2 id="创建子网"><a href="#创建子网" class="headerlink" title="创建子网"></a>创建子网</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create kong-net</span><br></pre></td></tr></table></figure><h2 id="运行数据库"><a href="#运行数据库" class="headerlink" title="运行数据库"></a>运行数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e <span class="string">"POSTGRES_USER=kong"</span> \</span><br><span class="line">               -e <span class="string">"POSTGRES_DB=kong"</span> \</span><br><span class="line">               -e <span class="string">"POSTGRES_PASSWORD=kong"</span> \</span><br><span class="line">               postgres:9.6</span><br></pre></td></tr></table></figure><h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -e <span class="string">"KONG_DATABASE=postgres"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PG_HOST=kong-database"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PG_PASSWORD=kong"</span> \</span><br><span class="line">     -e <span class="string">"KONG_CASSANDRA_CONTACT_POINTS=kong-database"</span> \</span><br><span class="line">     kong:1.5 kong migrations bootstrap</span><br></pre></td></tr></table></figure><h2 id="运行-kong-1"><a href="#运行-kong-1" class="headerlink" title="运行 kong"></a>运行 kong</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name kong \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -e <span class="string">"KONG_DATABASE=postgres"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PG_HOST=kong-database"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PG_PASSWORD=kong"</span> \</span><br><span class="line">     -e <span class="string">"KONG_CASSANDRA_CONTACT_POINTS=kong-database"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PROXY_ACCESS_LOG=/dev/stdout"</span> \</span><br><span class="line">     -e <span class="string">"KONG_ADMIN_ACCESS_LOG=/dev/stdout"</span> \</span><br><span class="line">     -e <span class="string">"KONG_PROXY_ERROR_LOG=/dev/stderr"</span> \</span><br><span class="line">     -e <span class="string">"KONG_ADMIN_ERROR_LOG=/dev/stderr"</span> \</span><br><span class="line">     -e <span class="string">"KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl"</span> \</span><br><span class="line">     -p 8000:8000 \</span><br><span class="line">     -p 8443:8443 \</span><br><span class="line">     -p 8001:8001 \</span><br><span class="line">     -p 8444:8444 \</span><br><span class="line">     kong:1.5</span><br></pre></td></tr></table></figure><h2 id="运行-kong-gui"><a href="#运行-kong-gui" class="headerlink" title="运行 kong gui"></a>运行 kong gui</h2><h3 id="运行-kong-dashboard"><a href="#运行-kong-dashboard" class="headerlink" title="运行 kong-dashboard"></a><del>运行 kong-dashboard</del></h3><blockquote><p>建议直接跳过，dashboard 可以运行，但是前端尽是报错，github上面的issue也没人处理，应该是不维护了。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run 	--network=kong-net \</span><br><span class="line">			--name kong-dashboard \</span><br><span class="line">            -p 8080:8080 \</span><br><span class="line">            -d pgbi/kong-dashboard \</span><br><span class="line">            start --kong-url http://kong:8001 \</span><br><span class="line">            --basic-auth user1=password1</span><br></pre></td></tr></table></figure><h3 id="运行-konga"><a href="#运行-konga" class="headerlink" title="运行 konga"></a>运行 konga</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:1337 \</span><br><span class="line">           --network kong-net \</span><br><span class="line">           --name konga \</span><br><span class="line">           -e <span class="string">"NODE_ENV=production"</span> \</span><br><span class="line">           -d pantsel/konga:0.14.7</span><br></pre></td></tr></table></figure><h2 id="运行-prometheus"><a href="#运行-prometheus" class="headerlink" title="运行 prometheus"></a>运行 prometheus</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name prometheus \</span><br><span class="line">--network&#x3D;kong-net \</span><br><span class="line">-p 9090:9090 \</span><br><span class="line"> -v &#x2F;root&#x2F;prometheus&#x2F;prometheus.yml:&#x2F;etc&#x2F;prometheus&#x2F;prometheus.yml \</span><br><span class="line"> -d prom&#x2F;prometheus:v2.16.0</span><br></pre></td></tr></table></figure><p>prometheus.yml 文件配置如下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span> <span class="comment"># By default, scrape targets every 15 seconds.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Attach these labels to any time series or alerts when communicating with</span></span><br><span class="line">  <span class="comment"># external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['kong:8001']</span></span><br></pre></td></tr></table></figure><p>核心点就是上面的 targets，相信很多分析类的文章都没有提到。</p><h2 id="运行-grafana"><a href="#运行-grafana" class="headerlink" title="运行 grafana"></a>运行 grafana</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --network&#x3D;kong-net --name&#x3D;grafana -p 3000:3000 grafana&#x2F;grafana:6.6.2</span><br></pre></td></tr></table></figure><p>运行之后，直接添加一个 dashboard 即可。</p><h1 id="小节一下"><a href="#小节一下" class="headerlink" title="小节一下"></a>小节一下</h1><p>api 经过 kong，会留下日志，prometheus 通过 <code>kong:8001</code> 端点标准化采集的日志，<br>grafana 通过 prometheus 得到标准后的日志进行展示。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://konghq.com/" target="_blank" rel="noopener">kong 官网</a></li><li><a href="https://github.com/pantsel/konga" target="_blank" rel="noopener">konga github</a></li><li><a href="https://prometheus.io/docs/prometheus/latest/installation/" target="_blank" rel="noopener">Prometheus 安装</a></li><li><a href="">Grafana 官网</a></li><li><a href="https://blog.csdn.net/weixin_39560112/article/details/101849583" target="_blank" rel="noopener">Kong插件Prometheus的Grafana图形化展示</a></li><li><a href="https://www.cnblogs.com/xiao987334176/p/9930517.html" target="_blank" rel="noopener">基于docker 搭建Prometheus+Grafana</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>kong</tag>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
        <tag>konga</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机是如何存储数字的</title>
    <url>/p/bec1.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">1.234</span>;</span><br></pre></td></tr></table></figure><p>问：a 和 b 在计算机中到底是如何存储的？</p><p>答：转为二进制？</p><p>问：转成二进制就直接存储了？</p><p>答：…</p><p>问：小数 b 如何转成二进制的？</p><p>答：…</p><p>我们日常更多的时候都在使用十进制的数，要知道我们的祖先可厉害了，应该很长一段时间都在使用 16 进制。譬如一个成语叫“半斤八两”，解释：半斤、八两轻重相等，比喻彼此不相上下。等等！半斤和八两怎么相等，对的，宋代一斤就是等于十六两，当然半斤等于八两。</p><p>都知道计算机使用的是二进制，只用 0 和 1 就能表示数字，但是计算机到底是如何解决数字存储的问题？下面分别讨论整数和小数的存储：</p><h1 id="如何存储整数"><a href="#如何存储整数" class="headerlink" title="如何存储整数"></a>如何存储整数</h1><p>假设我们现在有一个 8 位的操作系统，最高位是符号位，1 表示负数，0 表示正数，所以能表示的最大的整数区间为 <strong>11111111 ~ 01111111 =&gt; -127 ~ 127</strong>。</p><p>但是在存储表达的时候会遇到一个问题，10000000 和 00000000 两个 0 的问题，+0 和 -0 应该也是相等的，这给电路设计上带来了很多麻烦和多余的计算规则。</p><h2 id="十进制转成二进制"><a href="#十进制转成二进制" class="headerlink" title="十进制转成二进制"></a>十进制转成二进制</h2><p>简单点的记忆就是：除 2 取余再倒序。</p><ul><li>12 / 2 = 6..0</li><li>6 / 2 = 3..0</li><li>3 / 2 = 1..1</li><li>1 / 2 = 0..1</li></ul><p>0011 倒序 即为 1100，转成八位即在前面补0，则结果为 0000_1100。</p><blockquote><p>0000_1100 是 java8 中的写法，我觉得看起来比较舒服且前后连贯，_ 是为了看起来比较清楚人为添加的，后面沿用这种写法，0000_1100 = 00001100= 0000 1100<br>都是相等。</p></blockquote><h2 id="一个天才的设计师"><a href="#一个天才的设计师" class="headerlink" title="一个天才的设计师"></a>一个天才的设计师</h2><p>看了很多的文档没有找到解决这个问题的作者是谁？不管是谁反正提出了<code>补码</code>这个概念，真的是有效的解决了这个问题，不仅解决了 0 这个问题还带来了一个更大的优点，后面补充。</p><h2 id="正数的原码、反码、补码"><a href="#正数的原码、反码、补码" class="headerlink" title="正数的原码、反码、补码"></a>正数的原码、反码、补码</h2><p>正数原码 = 反码 = 补码</p><ul><li>12 的原码是 0000_1100</li><li>12 的反码是 0000_1100</li><li>12 的补码是 0000_1100</li></ul><p>这里并没有废话，尽是科学。</p><h2 id="负数的原码、反码、补码"><a href="#负数的原码、反码、补码" class="headerlink" title="负数的原码、反码、补码"></a>负数的原码、反码、补码</h2><p>反码 = 原码符号位不变其他位取反</p><p>补码 = 反码 + 1</p><ul><li>-12 的原码是 1000_1100</li><li>-12 的反码是 1111_0011</li><li>-12 的补码是 1111_0100</li></ul><h2 id="0-的存储"><a href="#0-的存储" class="headerlink" title="0 的存储"></a>0 的存储</h2><h3 id="0"><a href="#0" class="headerlink" title="+0"></a>+0</h3><ul><li>原码：0000_0000</li><li>反码：0000_0000</li><li>补码：0000_0000</li></ul><h3 id="0-1"><a href="#0-1" class="headerlink" title="-0"></a>-0</h3><ul><li>原码：1000_0000</li><li>反码：1111_1111</li><li>补码：0000_0000</li></ul><p>这里应该把前面的问题都解决了吧，补码不仅解决了 +0 和 -0 的问题，还神奇的把符号位都去掉了，计算机在运行的过程中从而可以更简单的进行运算。</p><h2 id="减法运算"><a href="#减法运算" class="headerlink" title="减法运算"></a>减法运算</h2><p>为了效率，计算机底层计算的时候是没有减法运算，减法运算都转成加法运算。</p><p>12 - 12 =&gt; 12 + (-12) =&gt; 0000_1100 + 1111_0100 =&gt; 0000_0000</p><ul><li>0000_110<code>0</code> + 1111_010<code>0</code> = 0 + 0 = 0</li><li>0000_11<code>0</code>0 + 1111_01<code>0</code>0 = 0 + 0 = 0</li><li>0000_1<code>1</code>00 + 1111_0<code>1</code>00 = 1 + 1 = 0 进 1</li><li>0000_<code>1</code>100 + 1111_<code>0</code>100 = 1+ 0 + 进1= 0 进 1</li><li>000<code>0</code>_1100 + 111<code>1</code>_0100 = 0+ 1 + 进1= 0 进 1</li><li>00<code>0</code>0_1100 + 11<code>1</code>1_0100 = 0+ 1 + 进1= 0 进 1</li><li>0<code>0</code>00_1100 + 1<code>1</code>11_0100 = 0+ 1 + 进1= 0 进 1</li><li><code>0</code>000_1100 + <code>1</code>111_0100 = 0+ 1 + 进1= 0 进 1</li></ul><p>因为只能存储 8 位，最后一个进 1 爆掉就剩下 0000_0000 了。</p><blockquote><p>这里都是以 8 位计算机进行举例，现在的 32 位或者 64 位计算机都是同理的。</p></blockquote><h1 id="如何存储浮点数"><a href="#如何存储浮点数" class="headerlink" title="如何存储浮点数"></a>如何存储浮点数</h1><p>相信很多人小数转成二进制都是不知道如何运算的，更别谈存储了，下面我就娓娓道来。</p><blockquote><p>文章刚开始编辑的时候将浮点数称为小数，由于发现这样不专业，其实小数不一定都是浮点数，在那个没有标准各自为政的早计算机时代其实还是有定点数，感兴趣可以看参考文档。</p></blockquote><h2 id="浮点数转成二进制"><a href="#浮点数转成二进制" class="headerlink" title="浮点数转成二进制"></a>浮点数转成二进制</h2><p>1.234 在计算机中转成二进制是按照是分整数部分和小数部分进行的，整数部分上面以前讲到，这里说下小数部分 0.234 为例：</p><p>简单点的记忆就是：乘 2 取整再顺序。</p><ul><li>0.234 * 2 = 0.468 =&gt; 整数部分为 0 =&gt; 取 0</li><li>0.468 * 2 = 0.936 =&gt; 整数部分为 0 =&gt; 取 0</li><li>0.936 * 2 = 1.872 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.872 * 2 = 1.744 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.744 * 2 = 1.488 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.488 * 2 = 0.976 =&gt; 整数部分为 0 =&gt; 取 0</li><li>0.976 * 2 = 1.952 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.952 * 2 = 1.904 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.904 * 2 = 1.808 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.808 * 2 = 1.616 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.616 * 2 = 1.232 =&gt; 整数部分为 1 =&gt; 取 1 (并将整数部分抹去)</li><li>0.232 * 2 = 0.464 =&gt; 整数部分为 0 =&gt; 取 0</li><li>…</li></ul><p>下面就不写下去了结果是 0.001110111110…，写的越长精度越高。</p><p>可见浮点数存储必将是一个头疼的问题，浮点数底层的逻辑肯定也是比整数更为复杂。</p><h2 id="IEEE754-标准"><a href="#IEEE754-标准" class="headerlink" title="IEEE754 标准"></a>IEEE754 标准</h2><p>电气电子工程师学会（英语：Institute of Electrical and Electronics Engineers）简称为 IEEE，IEEE754是专门规定浮点数该如何存储的一个标准，规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。</p><h3 id="任意一个浮点数都可以表示为："><a href="#任意一个浮点数都可以表示为：" class="headerlink" title="任意一个浮点数都可以表示为："></a>任意一个浮点数都可以表示为：</h3><p>$$ V = (-1)^s \times M \times 2^E $$</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">-1</span>)^s 表示符号位，当 s=<span class="number">0</span>，V 为正数；当 s=<span class="number">1</span>，V 为负数。</span><br><span class="line">M 表示有效数字，大于等于 <span class="number">1</span>，小于 <span class="number">2</span>。</span><br><span class="line"><span class="number">2</span>^E 表示指数位。</span><br></pre></td></tr></table></figure><p>例子：V = 0.234(十进制) = 0.001110111110(二进制) = 1.110111110 * 2^-3 ，则 s=0 ，M= 1.110111110，E=-3。</p><h3 id="IEEE754-规定："><a href="#IEEE754-规定：" class="headerlink" title="IEEE754 规定："></a>IEEE754 规定：</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/General_floating_point_frac.svg/490px-General_floating_point_frac.svg.png" alt="IEEE 754浮点数的三个域
"></p><ul><li><p>对于 32 位的浮点数，最高的 1 位是符号位 s，接着的 8 位是指数 E，剩下的 23 位为有效数字 M。</p></li><li><p>对于 64 位的浮点数，最高的 1 位是符号位 s，接着的 11 位是指数 E，剩下的 52 位为有效数字 M。</p></li></ul><h3 id="IEEE754-还有一些特殊的规定："><a href="#IEEE754-还有一些特殊的规定：" class="headerlink" title="IEEE754 还有一些特殊的规定："></a>IEEE754 还有一些特殊的规定：</h3><h4 id="针对-M"><a href="#针对-M" class="headerlink" title="针对 M"></a>针对 M</h4><p>由于 1&lt;= M &lt;=2 ，所以 M 始终为 1.xxxx 形式，xxxx 表示小数，那些对于计算机底层严苛的设计师这时候又要将 1 这一位舍掉，只保留 xxxx 部分，这样的好处是可以多储存一位有效数字。</p><h4 id="针对-E"><a href="#针对-E" class="headerlink" title="针对 E"></a>针对 E</h4><p>由于 E 是一个 8 位的无符号存储，只能表示 0 ~ 255，现实中的指数还存在负数，所以规定：<strong>E必须再加上一个中间数，对于 8 位的 E，这个中间数是 127；对于 11 位的 E，这个中间数是 1023</strong>，这样就可以将指数的表达范围扩大到 <code>-127 ~ +128</code> 和 <code>-1023 ~ +1024</code>。</p><blockquote><p>实际中的取值范围是 <strong>-126~+127</strong>，-127 和 128 被用作特殊值处理，双精度同理。</p></blockquote><blockquote><p>阮一峰的博客中写的是 <em>减去一个中间数</em> 应该是有误的。</p></blockquote><p>举个例子，如果 E=17，则 17+127 =144 ，实际的存储指为 144。</p><p>针对 E 还有一些特殊值的情况</p><ol><li>如果指数 E 是 0 并且尾数的小数部分是 0，这个数是 ±0（和符号位相关）。</li><li>如果指数 E 是 1 并且尾数的小数部分是0，这个数是±∞（同样和符号位相关）</li><li>如果指数 E 是 1 并且尾数的小数部分非0，这个数表示为不是一个数（NaN）。</li></ol><h2 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h2><p>V = 0.234(十进制) = 0.00111011111001110110110010(二进制) = 1.11011111001110110110010 * 2^-3 ，则 s=0 ，M= 1.110111110，E=-3。</p><p>根据 IEEE754 标准转化 :</p><blockquote><p>以 单精度为例</p></blockquote><p>s 不变<br>E=-3+127=124(十进制) = 0111_1100(二进制)</p><p>M=110_1111_1001_1101_1011_0010</p><p>结果将他们连接 0_0111_1100_110_1111_1001_1101_1011_0010(s_E_M)</p><p>可以<a href="http://www.speedfly.cn/tools/hexconvert/" target="_blank" rel="noopener">在线校验结果</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这篇文章详细介绍了计算机如何存储整数以及浮点数，个人也是从朦胧状态到理解透彻，参考了众多大佬的文章，在此表示感谢。有问题的朋友可以通过邮箱联系到我 <code>jake.zou.me@gmail.com</code>。</p><p>计算机之美妙不可言啊！</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/61628231" target="_blank" rel="noopener">计算机存储整数和小数</a></li><li><a href="https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html" target="_blank" rel="noopener">浮点数的二进制表示</a></li><li><a href="https://medium.com/@saltedfishcaptain/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E6%95%B4%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A5-%E8%A1%A5%E7%A0%81-%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AD%98%E5%82%A8-ed8f6654eb3a" target="_blank" rel="noopener">计算机中整数为什么以补码形式存储</a></li><li><a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">维基百科.IEEE754</a></li><li><a href="https://www.zhihu.com/question/19848808" target="_blank" rel="noopener">为什么叫浮点数?</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>计算机原理</category>
      </categories>
  </entry>
  <entry>
    <title>北京时间</title>
    <url>/p/e249.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>北京时间？对，想说的就是北京时间。</p><p>首先北京时间是位于东八区的东经 120 度的标准时间，北京的经度是 116.4，北京时间与北京当地时间相差 14 分钟 28 秒。</p><p>其次是北京时间的国家授时中心位于陕西省蒲城县，陕西蒲城县位于东七区。中国幅员辽阔，东西跨度 5000 公里，国家授时中心每秒钟以无线电波的形式向半径 3000 公里的中国大地发送标准的北京时间。</p><h3 id="一句话小结"><a href="#一句话小结" class="headerlink" title="一句话小结"></a>一句话小结</h3><p>国家授时中心在蒲城县(东七区)发送北京时间(东八区)给到全国校准时间。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><p><a href="https://zh.wikipedia.org/zh-hans/%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">维基百科.北京时间</a></p></li><li><p><a href="https://new.qq.com/omn/20180622/20180622G17DC9.html" target="_blank" rel="noopener">“北京时间”确认过眼神——陕西就是那个对的地方</a></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>科普</category>
      </categories>
  </entry>
  <entry>
    <title>博客加载速度优化</title>
    <url>/p/6d58.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>博客加载一直很慢，昨晚折腾的事情如下：</p><h3 id="netlify"><a href="#netlify" class="headerlink" title="netlify"></a>netlify</h3><p>对接了 <a href="https://app.netlify.com/" target="_blank" rel="noopener">netlify</a>，可以试试打开他们家的主页，没有一分钟都加载不出来，比用 github page 都要慢，放弃！</p><blockquote><p>netlify 异常强大，后台可以直接注入 script，几行代码就可以搭建一套 cms。</p></blockquote><h3 id="zeit"><a href="#zeit" class="headerlink" title="zeit"></a>zeit</h3><ul><li>后来又搜索到一家服务商 <a href="https://zeit.co/" target="_blank" rel="noopener">zeit.co</a> 也提供了静态页部署的功能，速度那是杠杠的，基本秒开确实快，但是每次部署都要手动去网页上点击一个<strong>发布</strong>，这是一个免费就需要折磨的节奏吗？</li></ul><blockquote><p>netlify精简版</p></blockquote><h3 id="bootcdn"><a href="#bootcdn" class="headerlink" title="bootcdn"></a>bootcdn</h3><ul><li>还是老老实实的国内 coding 加国外 github，但是可以配置 js 的引用地址，测试了几个 cdn，还是 <a href="https://www.bootcdn.cn" target="_blank" rel="noopener">bootcdn</a> 快，将 <code>/next/_config.yml</code> 下面的 vendors 修改如下：</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 2.1.3</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">//cdn.bootcss.com/jquery/2.1.3/jquery.min.js</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 2.1.5</span></span><br><span class="line"><span class="comment"># See: http://fancyapps.com/fancybox/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="string">//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js</span></span><br><span class="line"><span class="attr">fancybox_css:</span> <span class="string">//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.0.6</span></span><br><span class="line"><span class="comment"># See: https://github.com/ftlabs/fastclick</span></span><br><span class="line"><span class="attr">fastclick:</span> <span class="string">//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.9.7</span></span><br><span class="line"><span class="comment"># See: https://github.com/tuupola/jquery_lazyload</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="string">//cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.2.1</span></span><br><span class="line"><span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">velocity:</span> <span class="string">//cdn.bootcss.com/velocity/1.2.1/velocity.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.2.1</span></span><br><span class="line"><span class="comment"># See: http://VelocityJS.org</span></span><br><span class="line"><span class="attr">velocity_ui:</span> <span class="string">//cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 0.7.9</span></span><br><span class="line"><span class="comment"># See: https://faisalman.github.io/ua-parser-js/</span></span><br><span class="line"><span class="attr">ua_parser:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 4.6.2</span></span><br><span class="line"><span class="comment"># See: http://fontawesome.io/</span></span><br><span class="line"><span class="attr">fontawesome:</span> <span class="string">//cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1</span></span><br><span class="line"><span class="comment"># https://www.algolia.com</span></span><br><span class="line"><span class="attr">algolia_instant_js:</span></span><br><span class="line"><span class="attr">algolia_instant_css:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Internal version: 1.0.2</span></span><br><span class="line"><span class="comment"># See: https://github.com/HubSpot/pace</span></span><br><span class="line"><span class="comment"># Or use direct links below:</span></span><br><span class="line"><span class="comment"># pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="comment"># pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css</span></span><br><span class="line"><span class="attr">pace:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/pace.min.js</span></span><br><span class="line"><span class="attr">pace_css:</span> <span class="string">//cdn.bootcss.com/pace/1.0.2/themes/black/pace-theme-minimal.min.css</span></span><br></pre></td></tr></table></figure><p>打开速度明显可以提升。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>此处没有更多小结，域名没法备案啊，没有暂住证没有居住证👿….</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>判断一个整数是不是2的整数次方</title>
    <url>/p/c03.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>今天看到一个这样的题目：<strong>判断一个整数是不是 2 的整数次方?</strong></p><p>大学竞赛好像还真见过，现在已经忘得一干二净了。现在看到一个解法还真的挺溜。</p><p>首先按照二进制找规律</p><ul><li>2 =&gt; 10</li><li>4 =&gt; 100</li><li>8 =&gt; 1000</li><li>16=&gt; 10000</li><li>…</li></ul><p>下面就不写了，第一位为 1 后面全是 0，这样的数就是 2 的整数次方数。</p><p>二进制算法中还有一个规律</p><ul><li><p>8 =&gt; 1000</p><p>7 =&gt; 0111</p></li></ul><ul><li><p>16=&gt; 10000</p><p>15=&gt; 01111</p></li></ul><p>N 和 N-1 的区别是最低位的 1 变成 0，最低位后面的 0 全变成 1，并且 N&amp;(N-1)可以恰好为 0。</p><p>如果 N=1100，N&amp;(N-1) = 1100&amp;1011 != 0，所以 N 不是 2 的整数次数。</p><p>综上所述 ：判断一个整数是不是 2 的整数次方，只需要判断 N&amp;(N-1) 是否为 0。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>macbook pro 时间不准</title>
    <url>/p/303.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>从春节至现在3月份了，我还没有抢到口罩。🙄🙄</p><p>每次准点抢的时候我对一下我的电脑，发现时间总是慢 10s 左右，我在网上搜索真的有很多人和我一样，在某个知乎帖子下面有个大佬给了一个建议，可以通过定时任务去执行一个命令强制从更新苹果的服务器校准时间。我觉得他的想法相当好，而且我很变态的让系统每小时执行一次校准时间。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo cron -e</span><br><span class="line">---</span><br><span class="line">55 * * * * sudo /usr/bin/sntp -sS time.apple.com</span><br></pre></td></tr></table></figure><p>这里的添加定时任务必须添加 sudo ，否则任务里面有 sudo 其实是不执行的。测试了很多次。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ul><li><a href="https://www.zhihu.com/question/37349985" target="_blank" rel="noopener">知乎热帖</a></li><li><a href="https://time.is/zh/" target="_blank" rel="noopener">时间校准网站</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>VPC内网通信</title>
    <url>/p/bd3e.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>前面<a href="https://blog.zoulux.top/p/79fa.html">有篇文章</a>记录了我在迁移 redis 过程。但是在总结的时候对解决问题中的阿里云内网地址充满了兴趣，阿里云到底是怎么实现内网互联？容器中为什么也可以访问阿里云内网？</p><h1 id="阿里云内网互联"><a href="#阿里云内网互联" class="headerlink" title="阿里云内网互联"></a>阿里云内网互联</h1><p>要说清阿里云的整个 vpc 体系我现在怕是做不到，但是我本着根据实际现象做联想，我应该可以，至少可以在较长时间内可以满足我的知识图谱，如果哪天要是有机会碰上王坚博士，不对叫王坚院士，再和他一探究竟。</p><p>很多科学也是，在很长一段时间内都不会被证伪，说明这个科学理论是正确的，如果很长时间之后被证伪，说明证伪的部分也是这个科学理论的一部分，将知识串联起来比知识的真像更重要，发现了前面不对，也不必完全推翻，将 bug 修复了，将新的知识替换上去，将新老知识串联起来。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>概念这块我查阅了阿里云官方文档，以及查看了很多相关博客。</p><h3 id="VPC"><a href="#VPC" class="headerlink" title="VPC"></a>VPC</h3><p>专有网络（Virtual Private Cloud，简称VPC）是用户独有的云上私有网络，用户可以将购买的服务器、数据库、负载均衡都添加到这个专有网络，以达到内部互联互通。</p><p><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/zh-CN/1309756751/p2749.png" alt="专有网络"></p><p>阿里云建议一个地域下面只需要一个 VPC，不同地域之间的 VPC 是可以通过 vpn 或者隧道技术联通。</p><h4 id="vpc-原理"><a href="#vpc-原理" class="headerlink" title="vpc 原理"></a>vpc 原理</h4><p>基于目前主流的隧道技术，专有网络隔离了虚拟网络。每个VPC都有一个独立的隧道号，一个隧道号对应着一个虚拟化网络。一个VPC内的ECS（Elastic Compute Service）实例之间的传输数据包都会加上隧道封装，带有唯一的隧道ID标识，然后送到物理网络上进行传输。不同VPC内的ECS实例因为所在的隧道ID不同，本身处于两个不同的路由平面，所以不同VPC内的ECS实例无法进行通信，天然地进行了隔离。</p><p>基于隧道技术和软件定义网络（Software Defined Network，简称SDN）技术，阿里云的研发在硬件网关和自研交换机设备的基础上实现了VPC产品。</p><h4 id="vpc-逻辑架构"><a href="#vpc-逻辑架构" class="headerlink" title="vpc 逻辑架构"></a>vpc 逻辑架构</h4><p>如下图所示，VPC包含交换机、网关和控制器三个重要的组件。交换机和网关组成了数据通路的关键路径，控制器使用自研的协议下发转发表到网关和交换机，完成了配置通路的关键路径。整体架构里面，配置通路和数据通路互相分离。交换机是分布式的结点，网关和控制器都是集群部署并且是多机房互备的，并且所有链路上都有冗余容灾，提升了VPC产品的整体可用性。<br><img src="http://static-aliyun-doc.oss-cn-hangzhou.aliyuncs.com/assets/img/2428/15662966115013_zh-CN.png" alt=""></p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由器（VRouter）是专有网络的枢纽。路由器可以连接专有网络的各个交换机，同时也是连接专有网络与其它网络的网关设备。路由器根据路由条目来转发网络流量。这里路由器是一个抽象概念。</p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>路由表（Route Table）是指路由器上管理路由条目的列表，路由表绑定了VPC和交换机 。可以想象成 excel 里面的一张张 sheet</p><h4 id="路由条目"><a href="#路由条目" class="headerlink" title="路由条目"></a>路由条目</h4><p>路由条目（Route Entry）是指路由表中的每一条路由信息。路由条目定义了通向指定目标网段的网络流量的下一跳地址。路由条目包括系统路由和自定义路由两种类型。可以想象成 excel 里面的一张 sheet 中的每一行。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机（VSwitch）是组成专有网络的基础网络设备。交换机可以连接不同的云资源。在专有网络内创建云资源时，必须指定云资源所连接的交换机。默认一个可用区会有一台交换机，每台交换机都是 vpc 所定义的一个子网。</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关其实也是一个抽象概念，可以想象中现实中的海关，如果一个用户不出国，就接触不到海关，但是一个用户想要出国，就必须从海关通过，网关管理着内外网的联系。其实我一直不太理解路由器和网关的关系，觉得他们有关系但是不知道到底是怎样的关系，直到我看到知乎上的一段回复：</p><blockquote><p>首先‘网关’一个大概念，不具体特指一类产品，只要连接两个不同的网络的设备都可以叫网关；而‘路由器’一般特指能够实现路由寻找和转发的特定类产品，路由器很显然能够实现网关的功能。当然电信行业说的‘路由器’又和家用的‘路由器’两个概念，这个暂且不表。回到题目中你说问的默认网关是什么，默认网关事实上不是一个产品而是一个网络层的概念，PC本身不具备路由寻址能力，所以PC要把所有的IP包发送到一个默认的中转地址上面进行转发，也就是默认网关。这个网关可以在路由器上，可以在三层交换机上，可以在防火墙上，可以在服务器上，所以和物理的设备无关。</p></blockquote><p>简单一句话总结就是：</p><p>网关是连接了两个网络的设备，路由器是连接了局域网和广域网，<strong>路由器算网关</strong>。</p><h4 id="NET-网关"><a href="#NET-网关" class="headerlink" title="NET 网关"></a>NET 网关</h4><p>这里我特地想介绍一下阿里云 <code>net 网关</code>，因为这个设备我一直和网关混淆，阿里云整套系统都是基于软件定义，这里的 <code>net网关</code>其实就是将内(网)外的端口或者地址转发的到外(内)网一个设备。</p><p>net 网关提供 SNAT 和 DNAT 功能，</p><ul><li>DNAT是NAT网关上的一张配置表，用于NAT网关上的DNAT功能配置。可以实现端口映射（Port mapping）和IP映射（IP mapping），将NAT网关上的公网IP映射给ECS实例。</li></ul><ul><li>SNAT是NAT网关上的一张配置表，用于NAT网关上的SNAT功能配置。可以以交换机和ECS为粒度进行SNAT规则配置，以交换机为粒度：指定交换机下的所有ECS实例均使用指定的公网IP访问互联网，以ECS为粒度：指定的ECS实例使用指定的公网IP访问互联网。</li></ul><p>可以看到 net 网关也是网关的一种而已。</p><h3 id="弹性IP"><a href="#弹性IP" class="headerlink" title="弹性IP"></a>弹性IP</h3><p>弹性公网IP（Elastic IP Address，简称EIP）是可以独立购买和持有的公网IP地址资源。EIP可绑定到专有网络类型的ECS实例、专有网络类型的私网SLB实例、专有网络类型的辅助弹性网卡、NAT网关和高可用虚拟IP上。</p><p>EIP是一种NAT IP。它实际位于阿里云的公网网关上，通过NAT方式映射到了被绑定的资源上。和云资源绑定后，云资源可以通过EIP与公网通信.。</p><p>可以看出 EIP 也完全是一种抽象的概念，世界上本没有<code>弹性 IP</code>，阿里云这样的公司真是厉害，通过将阿里云公网上的 ip 以 net网关的形式映射到用户的绑定的资源上。</p><h2 id="补充网络协议"><a href="#补充网络协议" class="headerlink" title="补充网络协议"></a>补充网络协议</h2><p><img src="/images/pasted-12.png" alt="upload successful"></p><h1 id="容器内访问阿里云内网"><a href="#容器内访问阿里云内网" class="headerlink" title="容器内访问阿里云内网"></a>容器内访问阿里云内网</h1><blockquote><p>这部分内容有个前提，就是在阿里云的 ECS 里面已经可以和 rds 之类的服务连通。</p></blockquote><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>一般我们获得阿里云内网地址的时候，都会得到 <code>rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</code> 类似的链接。</p><p>这里使用 <a href="https://man.linuxde.net/dig" target="_blank" rel="noopener">dig</a> 命令获取对应内网地址所对应的 ip。</p><p>缺少 dig 命令的？ubuntu 系统</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ apt install dnsutils</span><br></pre></td></tr></table></figure><h3 id="宿主机测试访问内网地址"><a href="#宿主机测试访问内网地址" class="headerlink" title="宿主机测试访问内网地址"></a>宿主机测试访问内网地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.8-Ubuntu &lt;&lt;&gt;&gt; rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48397</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 65494</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com. 60 IN	A 192.168.0.250</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 127.0.0.53<span class="comment">#53(127.0.0.53)</span></span><br><span class="line">;; WHEN: Thu Dec 19 16:24:40 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 93</span><br></pre></td></tr></table></figure><p>可以看到这里的 dns 是 <code>127.0.0.53</code> ，这个地址 ubuntu 默认的 dns 的 ip，<br><code>rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</code> 对应的 ip 是<br><code>192.168.0.250</code>。</p><h3 id="容器内测试访问内网地址"><a href="#容器内测试访问内网地址" class="headerlink" title="容器内测试访问内网地址"></a>容器内测试访问内网地址</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dig rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.5-P4-5.1-Debian &lt;&lt;&gt;&gt; rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 57655</span><br><span class="line">;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 4096</span><br><span class="line">; COOKIE: 6cc1d7afb7bf77ce8f82d65a5dfb3603e95f17f7eeb8a82a (good)</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com. IN A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com. 60 IN	A 192.168.0.250</span><br><span class="line"></span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 127.0.0.11<span class="comment">#53(127.0.0.11)</span></span><br><span class="line">;; WHEN: Thu Dec 19 08:34:11 UTC 2019</span><br><span class="line">;; MSG SIZE  rcvd: 121</span><br></pre></td></tr></table></figure><p>这里的 dns 是 <code>127.0.0.11</code>，这个是 docker 默认的 dns 所对应的 ip，但是这里的得到的 ip 还是 <code>192.168.0.250</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实这里的测试结果还很令我惊奇的，为什么在容器里面也可以得到和宿主机同样的 ip 呢？以前我也一直这样使用，直到上次迁移 redis 我才想起问为什么。</p><p>容器中的DNS名称解析优先级顺序为：</p><ul><li>内置DNS服务器127.0.0.11。</li><li>通过–dns等参数为容器配置的DNS服务器。</li><li>docker守护进程的–dns服务配置（默认为8.8.8.8和8.8.4.4）</li><li>宿主机上的DNS设置。</li></ul><p>由于默认情况是没有第二步和第三步，所以在向 docker 内部 dns 服务器请求 <code>rm-uf688k07qu8lt251p90130.mysql.rds.aliyuncs.com</code> 的时候，内部 dns 是无法给到地址的，所以这个地址又交回到宿主机了。宿主机也不知道地址，随即通过交换机递交到路由器，路由器当然是知道这个地址是多少，就将 <code>192.168.0.250</code> 返回了。我们在购买 rds 服务的时候需要选择一个可用区，而这个 rds 就是挂在这个可用区所对应的交换机上。</p><h2 id="继续探讨"><a href="#继续探讨" class="headerlink" title="继续探讨"></a>继续探讨</h2><p>这里容器内已经获得 rds 所对应的 ip 了，但是在容器内如何能访问到 <code>192.168.0.250</code> 这个地址呢？<br>我们可以先获取容器的 ip 地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker inspect <span class="variable">$CONTAINER</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="string">"Gateway"</span>: <span class="string">"192.168.64.1"</span>,</span><br><span class="line"><span class="string">"IPAddress"</span>: <span class="string">"192.168.64.5"</span>,</span><br></pre></td></tr></table></figure><p>现在问题变成 <code>192.168.64.5</code> 想去连接 <code>192.168.0.250</code>。<br><code>192.168.64.5</code> 发现自己和 <code>192.168.0.250</code> 不在一个子网内.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ route -n</span><br><span class="line"></span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.0.253   0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">192.168.0.0     0.0.0.0         255.255.255.0   U     0      0        0 eth0</span><br><span class="line">192.168.16.0    0.0.0.0         255.255.240.0   U     0      0        0 br-317146d44671</span><br><span class="line">192.168.32.0    0.0.0.0         255.255.240.0   U     0      0        0 br-dcf4529fa753</span><br><span class="line">192.168.48.0    0.0.0.0         255.255.240.0   U     0      0        0 br-a5d4178cf1f7</span><br><span class="line">192.168.64.0    0.0.0.0         255.255.240.0   U     0      0        0 br-568ac4a0657a</span><br><span class="line">192.168.200.0   0.0.0.0         255.255.255.0   U     0      0        0 docker0</span><br></pre></td></tr></table></figure><p>把请求交给了 <code>192.168.0.0</code> 处理，这样 <code>192.168.64.5</code> 终于连上了 <code>192.168.0.250</code> 。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://help.aliyun.com/document_detail/34221.html?spm=a2c4g.11186623.6.546.599b6c16I4cskX" target="_blank" rel="noopener">阿里云专有网络 VPC文档</a></li><li><a href="http://dockone.io/article/2316" target="_blank" rel="noopener">docker内置dnsserver工作机制</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>vpc</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云redis服务迁移记录</title>
    <url>/p/79fa.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><h2 id="总有那么一段废话"><a href="#总有那么一段废话" class="headerlink" title="总有那么一段废话"></a>总有那么一段废话</h2><p>因为某个项目前期数据量比较小，所以就直接使用 docker 起的 redis 服务，由于现在的业务规模上升，原有的 reids 服务不能进行数据监控以及不方便数据管理和维护，所以在阿里云单独买了一个云 redis 服务，我前期为了安全，也没有将 redis 服务的端口映射到宿主机，所以给我的迁移也带来了挑战。</p><h2 id="正式步骤"><a href="#正式步骤" class="headerlink" title="正式步骤"></a>正式步骤</h2><h3 id="开启宿主机端口映射"><a href="#开启宿主机端口映射" class="headerlink" title="开启宿主机端口映射"></a>开启宿主机端口映射</h3><p>在 <code>docker-compose.yml</code> 文件下修改 <strong>redis</strong> service，增加 ports 字段。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">redis:</span><br><span class="line">  container_name: redis-pro</span><br><span class="line">  image: redis:<span class="number">4.0</span><span class="number">.10</span></span><br><span class="line">  sysctls:</span><br><span class="line">    net.core.somaxconn: <span class="number">65535</span></span><br><span class="line">  ports:</span><br><span class="line">    - <span class="string">"6380:6379"</span></span><br><span class="line">  networks:</span><br><span class="line">    - backend</span><br><span class="line">  restart: always</span><br></pre></td></tr></table></figure><p>更新 redis 服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose up -d redis</span><br></pre></td></tr></table></figure><p>查看端口映射状态</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose ps</span><br><span class="line"></span><br><span class="line">redis   docker-entrypoint.sh redis ...   Up      0.0.0.0:6380-&gt;6379/tcp</span><br></pre></td></tr></table></figure><h3 id="开启阿里云-DTS-服务"><a href="#开启阿里云-DTS-服务" class="headerlink" title="开启阿里云 DTS 服务"></a>开启阿里云 DTS 服务</h3><p>选择和宿主机以及 redis 在同一个地域的<code>数据传输服务</code>，理论上这样的服务会延迟更低，稳定性更好。</p><p><img src="/images/pasted-8.png" alt="upload successful"></p><p>分别配置好源库信息和目标库信息，阿里云还是很贴心，测试连接如果都是通过就可以下一步下一步了。</p><p>等待到全量更新为 「100%」就说明本次迁移已完成很大一部分了。</p><blockquote><p>为什么要使用 DTS 服务，而不是自己将 redis 保存成文件，导入到新的 redis 服务呢？主要是 DTS 服务支持增量更新，后面可能会持续有数据的读写覆盖等，这些 DTS 服务会一条龙服务解决掉。</p></blockquote><h3 id="配置-redis-地址"><a href="#配置-redis-地址" class="headerlink" title="配置 redis 地址"></a>配置 redis 地址</h3><h4 id="开启云-reids-外网地址"><a href="#开启云-reids-外网地址" class="headerlink" title="开启云 reids 外网地址"></a>开启云 reids 外网地址</h4><blockquote><p>实际过程中我是直接用的内网地址，发现内网根本连不上。</p></blockquote><p>这里直接说外网地址，保证系统先调通，这里注意两点。</p><ul><li>购买的 reids 版本，阿里云 Redis4.0 及以上版本密码格式为“账号:密码”，其他版本就只有密码，没有账户概念，当然我是追求极致体验全部选最新。</li><li>点击申请外网链接，是需要等待 20 秒左右才能使用的，不是立即生效。</li></ul><p><img src="/images/pasted-9.png" alt="upload successful"></p><h4 id="修改-web-服务中的-redis-地址"><a href="#修改-web-服务中的-redis-地址" class="headerlink" title="修改 web 服务中的 redis 地址"></a>修改 web 服务中的 redis 地址</h4><p>因为我在使用 swoft，直接修改 redis 的配置文件 <code>config/pro/redis.php</code>。</p><p><img src="/images/pasted-10.png" alt="upload successful"></p><p>将代码部署到线上，发现服务正常运行。如果你能接受外网访问，那么到这里就可以结束了，我一个追求极致的人，当然是不能容忍线上服务就这么暴露在外网中，即使有白名单机制。</p><h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><p>主要是 redis 配置这块碰到了一个大坑，和阿里云的技术客服来来去去聊了一天，他们每半小时或者一个小时才给我回复一条消息，到晚上才给我解决，感觉白天的阿里云客服技术水平完全是值班的，一些很简单的问题和我绕了半天，结果道歉说他弄错了，是在怀疑我不专业吗？不过最后那个技术客服一下就能抓住重点，问题一下就解决了。给了我一个文档也不知道是哪位大佬的博客，是这位客服自己的么？🙃🙃</p><p>我在使用内网地址的时候一直会反馈一个错误。发现 redis 连接一直超时。<br>然后我去 ping 了一下他的地址</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping r-xxxxxxxxxx.redis.rds.aliyuncs.com</span><br><span class="line"></span><br><span class="line">Destination Host Unreachable</span><br></pre></td></tr></table></figure><p>给我反馈的 <code>Destination Host Unreachable</code> 就是这个错误，简单的说就是 dns 解析不到，网络无法连通。我开始以为这个可能是阿里云故意关闭了 ping 所需要的 icmp 包。</p><p>我就使用 reids 客户端去实验，参数 h 是地址，参数 a 是密码。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-cli -h r-xxxxxxxxxx.redis.rds.aliyuncs.com -a xxxxx</span><br><span class="line"></span><br><span class="line">Name or service not known</span><br></pre></td></tr></table></figure><p>发现这个内网真的访问不上，和阿里云客服百般沟通之后，提供的解决方案来看，是通信的网卡走错了。</p><h4 id="配置-docker"><a href="#配置-docker" class="headerlink" title="配置 docker"></a>配置 docker</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vi  /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>daemon.json 文件里面增加一个网段信息</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"bip"</span>: <span class="string">"192.168.200.1/24"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 docker 服务</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure><p>但是我这里重启 docker 服务还是报错了，最后不得已重启了机器。</p><p>ping 了一下地址确实是能 ping 到，重新配置了 reids 的内网地址，一切都恢复正常了。</p><h3 id="关闭阿里云-DTS-服务"><a href="#关闭阿里云-DTS-服务" class="headerlink" title="关闭阿里云 DTS 服务"></a>关闭阿里云 DTS 服务</h3><p>因为 DTS 服务是收费服务，线上既然可以正常运行，就可以先暂停服务，然后释放掉就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个总结我研究了好几天，感觉还是不要总结了，因为有些知识还是需要我去发掘，因为对于这个内网地址我实在有点不太明白，它的原理是什么，为什么我在使用 <code>dns 8.8.8.8</code> 的时候，还是可以解析到内网地址?</p><p>后面我会补充一篇内容专门讨论阿里云的内网技术。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.chenxie.net/archives/2049.html" target="_blank" rel="noopener">阿里大佬提供的解决方案</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>reids</tag>
        <tag>redis迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>swoft时间戳问题</title>
    <url>/p/1da.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>swoft 这个框架我是越用越烦了，缺少了关联模型的 Eloquent 用起来总是蹩手蹩脚，下次让我选择一个 swoole 框架我一定会选择 <a href="https://www.hyperf.io/" target="_blank" rel="noopener">hyperf</a>。</p><p>关于 swoft 自动写入时间戳，在刚开始一直没有弄对，最早是怎么都不更新，后来我发现可以用 int 类型，所以数据库里面的 创建时间和更新时间都是 int 类型，但是我这边收到的需求是要根据年月进行筛选，int 类型就要搞死我。</p><p><a href="https://en.swoft.org/docs/2.x/zh-CN/db/model.html#%E8%87%AA%E5%8A%A8%E5%86%99%E5%85%A5%E6%97%B6%E9%97%B4%E6%88%B3" target="_blank" rel="noopener">官网介绍自动写入时间戳</a>，我觉得作者没有说清楚，到底应该怎么弄，我在自己的摸索下，发现只需要把时间戳声明 string 类型即可解决。</p><p><img src="/images/pasted-6.png" alt="upload successful"></p><p>数据库中的类型记得声明成 timestamp 类型</p><p><img src="/images/pasted-7.png" alt="upload successful"></p><p>头疼🙃🙃</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>swoft</category>
      </categories>
  </entry>
  <entry>
    <title>v2ray入门</title>
    <url>/p/a001.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>前端时间朋友一直在安利 v2ray，他们公司 CTO 是个搭梯高手，各种 ss v2ray 给他们免费使用实在不要太爽。我很早就听说过 v2ray，但是也一直没有尝试过，感觉每次看到 v2ray 教程都是很大篇幅，也没什么耐心去看，就像上个网搞这么麻烦，但是作为一个资深 docker 使用者来说，没有什么程序是一个 docker 镜像解决不了的，如果有那就是镜像写的不好。</p><p>无论这个东西怎么复杂，我们先让车上路，废话少说。</p><h2 id="安装-v2ray-服务端"><a href="#安装-v2ray-服务端" class="headerlink" title="安装 v2ray 服务端"></a>安装 v2ray 服务端</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>docker 安装什么的我直接略过了，都是一句话的事，直接进入</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull v2ray/official</span><br></pre></td></tr></table></figure><h3 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>这边我在官网下载了一个配置，这应该是最简配置了吧。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">10086</span>, <span class="comment">// 服务器监听端口，必须和上面的一样</span></span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"clients"</span>: [&#123; <span class="string">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"outbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将文件存储为 <code>config.json</code> 即可。</p><h3 id="启动镜像"><a href="#启动镜像" class="headerlink" title="启动镜像"></a>启动镜像</h3><p>很想给官方镜像写个 readme，啥也没有，全靠自己悟性呢，这是？</p><p>我看了一下它的 <a href="https://hub.docker.com/r/v2ray/official/dockerfile" target="_blank" rel="noopener">dockerfile</a>， 看到他 copy 了一个文件 <code>COPY config.json /etc/v2ray/config.json</code>，看到这稳了，我只需要把外面的文件挂载到容器里面就好了。配置文件中端口是 10086，所以这里直接映射到宿主机上。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run --name=v2 -p 10086:10086 -v <span class="variable">$PWD</span>:/etc/v2ray -d  v2ray/official</span><br></pre></td></tr></table></figure><h2 id="安装-v2ray-客户端"><a href="#安装-v2ray-客户端" class="headerlink" title="安装 v2ray 客户端"></a>安装 v2ray 客户端</h2><h3 id="准备配置文件-1"><a href="#准备配置文件-1" class="headerlink" title="准备配置文件"></a>准备配置文件</h3><p>客户端这块也是下载一个配置文件，存储为 <code>config.json</code> 即可。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">1080</span>,  <span class="comment">// SOCKS 代理端口，在浏览器中需配置代理并指向这个端口</span></span><br><span class="line">    <span class="string">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"socks"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"udp"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"outbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"vnext"</span>: [&#123;</span><br><span class="line">        <span class="string">"address"</span>: <span class="string">"server"</span>, <span class="comment">// 服务器地址，请修改为你自己的服务器 ip 或域名</span></span><br><span class="line">        <span class="string">"port"</span>: <span class="number">10086</span>,  <span class="comment">// 服务器端口</span></span><br><span class="line">        <span class="string">"users"</span>: [&#123; <span class="string">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span> &#125;]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="string">"tag"</span>: <span class="string">"direct"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"routing"</span>: &#123;</span><br><span class="line">    <span class="string">"domainStrategy"</span>: <span class="string">"IPOnDemand"</span>,</span><br><span class="line">    <span class="string">"rules"</span>: [&#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">      <span class="string">"ip"</span>: [<span class="string">"geoip:private"</span>],</span><br><span class="line">      <span class="string">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mac-、"><a href="#mac-、" class="headerlink" title="mac 、"></a>mac 、</h3><p>github 上面直接下载 <a href="https://github.com/yanue/V2rayU/releases" target="_blank" rel="noopener">V2rayU客户端</a> 这个客户端，我目前在用觉得还不错。</p><p>依次配置：服务器设置 - 导入模式 - 选择文件 - 选择 config.json ，</p><p><img src="/images/pasted-4.png" alt="upload successful"></p><p>然后去手动模式里面检查检查，如果没有问题差不多就搞定了。</p><h3 id="ios"><a href="#ios" class="headerlink" title="ios"></a>ios</h3><p>手机上使用 <code>shadowrocket</code> ，图标是一个小火箭，中国区的 App Store 现在应该下载不到了，可以去 google 上搜索大佬提供的 App Store 香港的账户，上面是可以下载。</p><p>打开 shadowrocket，选择右上角添加，然后底部打开 <code>扫码二维码</code>，mac 上面的 V2rayU 选择分享二维码接口完成 shadowrocket 添加。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>浏览器打开 <code>google.com</code> ，又可以愉快的看国外的文档了。如果遇到问题，可以联系我，v2ray 基础功能差不多是可以的，更复杂的功能我也继续在看文档。</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>有个小技巧可以提高 v2ray 的效率，打开 mux 接口，这个功能也是 v2ray 独有的。</p><p><img src="/images/pasted-5.png" alt="upload successful"></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.v2ray.com/" target="_blank" rel="noopener">v2ray 官网</a></li><li><a href="https://hub.docker.com/r/v2ray/official" target="_blank" rel="noopener">docker 镜像</a></li><li><a href="https://github.com/yanue/V2rayU" target="_blank" rel="noopener">V2rayU</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>v2ray</tag>
      </tags>
  </entry>
  <entry>
    <title>swoft 入门</title>
    <url>/p/aa25.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对比了几个基于 swoole 的框架，swoft 在 github 上面 star 数量遥遥领先的，所以准备基于 swoft 开始一个小项目。</p><h2 id="swoft目录"><a href="#swoft目录" class="headerlink" title="swoft目录"></a>swoft目录</h2><p>对于一个 laravel 老玩家，看这个目录还是比较简单的，env 配置文件使用的时候 copy 一遍，不同的是他这边配置是分为 env、config、bean 三部分，主要开发的代码在 app 下，bin 下放了一些可执行文件。<br><img src="/images/pasted-2.png" alt="upload successful"></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><p>我是将它作为一个 http 的服务，所以最重要的目录 app/Http/Controller ，每一条 http 请求对应一个 Controller 中的方法。所有 Controller 都需要 <strong>@Swoft\Http\Server\Annotation\Mapping\Controller</strong> 注解（注释），<code>后面所有提到的注释和注解意义相同，注解是 java 中的称呼，是一些有意义的代码级别含义的标志</code>，方法都需要添加 <strong>@Swoft\Http\Server\Annotation\Mapping\RequestMapping</strong> 注解</p><p><img src="/images/pasted-3.png" alt="upload successful"></p><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$request = Context::get()-&gt;getRequest();</span><br><span class="line">$key = $request-&gt;post(<span class="string">'key'</span>);</span><br><span class="line">$method = $request-&gt;getMethod();</span><br><span class="line">$headers = $request-&gt;getHeaders();</span><br><span class="line">$some = $request-&gt;query(<span class="string">'key'</span>, <span class="string">'default value'</span>)</span><br></pre></td></tr></table></figure><p>这里 $request 可以类比 laravel 对象，</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>这种大而全的框架其实都是有很多方法获取常见的 request 以及 response 对象的。</p><h3 id="全局context获取"><a href="#全局context获取" class="headerlink" title="全局context获取"></a>全局context获取</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$response=Context::mustGet()-&gt;getResponse()</span><br></pre></td></tr></table></figure><h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@RequestMapping</span>("index")</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Response $response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ReflectionException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ContainerException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">(Response $response)</span>: <span class="title">Response</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $response = $response-&gt;withContent(<span class="string">'&lt;html lang="en"&gt;&lt;h1&gt;Swoft framework&lt;/h1&gt;&lt;/html&gt;'</span>);</span><br><span class="line">    $response = $response-&gt;withContentType(ContentType::HTML);</span><br><span class="line">    <span class="keyword">return</span> $response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到使用了 param 注解，并声明 Response 类型。</p><h2 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h2><p>和 laravel 中一样使用 Eloquent 模型操作数据，但是我没有找到我想要的关联模型相关的方式，例如：<code>belongsTo</code>、<code>morphTo</code> 等。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$user = User::query()</span><br><span class="line">         -&gt;where(<span class="string">'mobile'</span>, $mobile)</span><br><span class="line">         -&gt;first();</span><br></pre></td></tr></table></figure><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>这类框架真的互相一大抄，使用的是著名的扩展 predis，毫无悬念。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$value = Redis::get(<span class="string">'some'</span>);</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="直接运行"><a href="#直接运行" class="headerlink" title="直接运行"></a>直接运行</h3><p>其实到这里才是我想说有点坑的地方。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php bin/swoft http:start</span><br></pre></td></tr></table></figure><p>好！稍等片刻，项目是跑起来了，但是我修改代码的时候居然不更新，需要切断进程重新跑。</p><h3 id="swoftcli"><a href="#swoftcli" class="headerlink" title="swoftcli"></a>swoftcli</h3><p>这也是官方提供的一个工具，可以 watch 文件的变化，然后可以自动重启服务，cli 在老版本是内置的，新版本的 swoft 踢除了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php bin/swoftcli run -b bin/swoft /var/www/swoft</span><br></pre></td></tr></table></figure><p>不得不说真香，但是在 MacBook 下面修改代码到服务重启成功总是慢半拍，但是试了在 linux 下确实可以做到同步。</p><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><p>终于要讲到我的大杀器，官方也是提供 Dockerfile 和 docker-compose 的，改了一下 command 就可以正常运行了。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>-<a href="https://www.swoft.org/docs" target="_blank" rel="noopener">官方文档</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>swoft</tag>
        <tag>swoole</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的左关联</title>
    <url>/p/7d06.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>可能是 laravel 中的 eloquent 模型查询用的实在太爽，感觉自己都不太会写 sql 语句了😅😅。现在回想自己的 sql 技术的顶峰应该就是大学的课堂了，老师带着大家建表，学生表、班级表、成绩表想想还有点记忆尤新，那时候数据库连接都是直接终端敲命令的，机房的数据库密码统一是 <code>wodexinmima</code>，转眼四年有余了。</p><p>现在的框架确实封装程度太高，大大降低了各种技术的门槛，大大提高了代码的维护性，否则一个十几乃至几十行的 sql 语句，谁能看得懂，但是又从反面暴露一件事，sql 的基础查询都快丢了，吓得我立马温习了一遍 mysql 查询。</p><p>进入正题。</p><p>最近有这么一个业务出现了 bug，用户在观看视频的时候会生成一条观看记录，观看记录的顺序始终是最近观看的视频放在最前面，但是如果用户看过视频两次，第二次看的记录并没有显示在最前面，反而还是以第一次观看的时间为准。</p><p>先看三张表：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">users 表</span><br><span class="line">id name</span><br><span class="line"></span><br><span class="line">videos 表</span><br><span class="line">id name</span><br><span class="line"></span><br><span class="line">watch_records 表</span><br><span class="line">id user_id video_id created_at</span><br></pre></td></tr></table></figure><p>假如现在有这样几条数据</p><p>users 表</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>Jake</td></tr></tbody></table><p>videos 表</p><table><thead><tr><th>id</th><th>name</th></tr></thead><tbody><tr><td>11</td><td>面试技巧</td></tr><tr><td>22</td><td>快消行业介绍</td></tr><tr><td>33</td><td>职场礼仪</td></tr></tbody></table><p>watch_records 表</p><table><thead><tr><th>id</th><th>user_id</th><th>video_id</th><th>created_at</th></tr></thead><tbody><tr><td>111</td><td>1</td><td>11</td><td>2019-07-01 05:31:59</td></tr><tr><td>222</td><td>1</td><td>22</td><td>2019-07-02 05:31:59</td></tr><tr><td>333</td><td>1</td><td>33</td><td>2019-07-03 05:31:59</td></tr><tr><td>444</td><td>1</td><td>11</td><td>2019-07-04 05:31:59</td></tr></tbody></table><p>现在要求查出的 watch_records 数据应该是 444 &gt; 333 &gt; 222 ，id 11 的视频因为最近再次观看取 444 这条记录而非 111 这一条。之前的 bug 是因为我直接 <code>groupBy(&#39;video_id&#39;)</code> ，从而得到的结果为 333 &gt; 222 &gt; 111。这个问题我研究了很长时间在我请教了一位朋友之后他说可以尝试「分组排序取前n」，这个关键字确实得到了很多答案，我试了几个查询没有得到合理答案，他直接给了我一段 sql ：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> m1.*</span><br><span class="line"><span class="keyword">FROM</span> watch_records  m1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> watch_records  m2</span><br><span class="line"><span class="keyword">ON</span> (m1.user_id = m2.user_id <span class="keyword">and</span> m1.video_id=m2.video_id <span class="keyword">AND</span> m1.created_at &lt; m2.created_at) <span class="keyword">WHERE</span> m2.id <span class="keyword">is</span> <span class="literal">NULL</span> <span class="keyword">and</span> m1.user_id=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_at <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p>没有想到确实就查出了结果。</p><p>这段 sql 的点睛之笔在于 <code>m2.id is NULL</code> ，两张表左关联，右边表的创建时间比左边的大，只有左边是最大的时候，右边才会没有对应的记录，那也就是 <code>m2.id is NULL</code> ，巧妙利用了左关联，就做到了 「分组排序取前1」。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>left join</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel中实现微信公众号登录</title>
    <url>/p/6ae1.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>一般公司都会使用微信扫码登录，通过 PC 端打开</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//open.weixin.qq.com/connect/qrconnect?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</span></span><br></pre></td></tr></table></figure><p>然后用户扫描网页上的二维码，手机端确认，即可在网页上登录。</p><p>但是这样的登录方式越来越不适用于这个流量时代，都希望可以通过关注公众号登录，这样不仅可以给公众号引流，还可以通过公众号推文或者模板消息等其他诱导方式，再次吸引用户重新打开网页。</p><p>so …</p><p>找到了<a href="https://www.kanzhun.com/login/?ka=head-signin" target="_blank" rel="noopener">看准网</a>就实现了关注服务号自动登录，我很好奇的去看了一下他们的网络请求。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl &#39;https:&#x2F;&#x2F;www.kanzhun.com&#x2F;scan?wxScanId&#x3D;2Lhy8vtcRg~~&amp;_&#x3D;1561996681530&#39;</span><br></pre></td></tr></table></figure><p>删除了其他参数，只留下核心的两个参数，<code>wxScanId</code> 是后端随机返回一个字符串，<code>_</code> 貌似是一个计数器，暂时不深究，这个接口也很奇怪，每次都要 pending 30s 左右，我在思考这是 「长连接」？google 了一番，原来这里是一个专有名词 「长轮询」。</p><p><strong>长轮询</strong>必然会对应<strong>短轮询</strong>,正常的 http 请求，一个 request 到后端服务器，这时候做相应的一个数据处理然后就立即返回了，对于刚才扫码登录这个业务所以<strong>短轮询</strong>会一遍一遍去查询服务器，当前这个 code 是否已经扫码。但是<strong>长轮询</strong>会将 request 发到服务端，这时候服务端会 hold 这个请求，通过后端去查询，没查到继续去查，查到可立即返回到客户端，大大降低了客户端的响应时间。</p><p>大致的流程：</p><ol><li>服务端生成一个随机数 A</li><li>通过微信公众平台生成带 A 参数的二维码</li><li>将 A 存入到 redis 中，key 为 A ，value 为 false</li><li>将 A 和 二维码 url 返回到前端</li><li>客户端通过长轮询不断查询</li><li>用户扫描二维码可获取到 随机数对应的 openid</li><li>将 openid 存入到redis 中，key 为 A ，value 为 openid</li><li>客户端查询到结果通过 openId 登录</li></ol><p>show me the code 。。。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> $ttl = <span class="number">30</span>; <span class="comment">// 30秒 每秒查询一次</span></span><br><span class="line"> <span class="keyword">while</span> ($ttl--) &#123;</span><br><span class="line">     $openId = Cache::get(WeixinService::LOGIN_KEY_PREFIX . $request-&gt;code);</span><br><span class="line">      <span class="keyword">if</span> ($openId === <span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 还未扫码 继续查询</span></span><br><span class="line">      &#125; <span class="keyword">elseif</span> ($openId) &#123;</span><br><span class="line">         <span class="comment">// 已经扫码，拿到 openId</span></span><br><span class="line">         <span class="keyword">return</span> $openId;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 码已经过期，或者无效码</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;response-&gt;errorBadRequest(<span class="string">'二维码已经过期，或者无效'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口的目的就是实现了上面的逻辑，因为我将数据放到 redis 中，这样服务端可以每隔 1s 查询一次，如果用户已经扫码，则微信服务器会将事件推送到我们自己的服务器，这时候拿到 openid，配置到 redis 中，从而长轮询取到 openid ，后面的就是简单的登录流程，直接省略了。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://mp.weixin.qq.com/wiki?action=doc&id=mp1443433542&t=0.2205841058645851" target="_blank" rel="noopener">生成带参数的二维码</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>长轮询</tag>
        <tag>微信公众号登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel中获取真实ip</title>
    <url>/p/705c.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近在开发微信支付，微信扫码付以及微信公众号支付对接都是比较顺利，因为 laravel 中 <a href="https://github.com/yansongda/pay" target="_blank" rel="noopener">laravel-pay</a> 用起来实在太爽，但是在对接微信的 H5 支付时却怎么也过不了，一直提示「网络环境未能通过安全验证，请稍后再试」。</p><h2 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h2><p>搜素发现<a href="https://pay.weixin.qq.com/wiki/doc/api/H5.php?chapter=15_4" target="_blank" rel="noopener">支付常见问题</a>中提到了这个错误，其实简单点就是下单 ip 和支付 ip 不是同一个导致的，只是微信支付只是在 H5 支付环节对 spbill_create_ip 参数进行了校验，而源码中 spbill_create_ip 是通过如下代码获得：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;payload = [</span><br><span class="line">         <span class="string">'appid'</span>            =&gt; $config-&gt;get(<span class="string">'app_id'</span>, <span class="string">''</span>),</span><br><span class="line">         <span class="string">'mch_id'</span>           =&gt; $config-&gt;get(<span class="string">'mch_id'</span>, <span class="string">''</span>),</span><br><span class="line">         <span class="string">'nonce_str'</span>        =&gt; Str::random(),</span><br><span class="line">         <span class="string">'notify_url'</span>       =&gt; $config-&gt;get(<span class="string">'notify_url'</span>, <span class="string">''</span>),</span><br><span class="line">         <span class="string">'sign'</span>             =&gt; <span class="string">''</span>,</span><br><span class="line">         <span class="string">'trade_type'</span>       =&gt; <span class="string">''</span>,</span><br><span class="line">         <span class="string">'spbill_create_ip'</span> =&gt; Request::createFromGlobals()-&gt;getClientIp(), <span class="comment">// 重点！！！</span></span><br><span class="line">     ];</span><br></pre></td></tr></table></figure><p>这里是 Request 是来自 <code>Symfony\Component\HttpFoundation\Request</code> ，createFromGlobals 方法恰巧是通过 php 中全局的 <code>$_GET</code>, <code>$_POST</code>,<code>$_COOKIE</code>, <code>$_FILES</code>, <code>$_SERVER</code> 变量构造的，而 <code>$_SERVER</code> 中包含了大量的由 php-fpm 注入的参数。</p><blockquote><p>顺便提一下，laravel 中的 request 也是继承这个 <code>Symfony\Component\HttpFoundation\Request</code> 类</p></blockquote><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><p>但是通过这个方法无论如何也拿不到真实的用户 ip，由于后台的服务是由 docker 部署，api 服务是通过多个 proxy 代理到最终的 laravel 上，所以在 laravel 上始终获得的 ip 都是其中某个代理的 ip。</p><p>翻阅文档，laravel 中有个 <code>TrustProxies</code> 中间件是专门处理 ip 的问题，默认是没有代理是直接读取 <code>REMOTE_ADDR</code> 的头，如果有代理的情况可以填充代理的 ip，但是如果不知道中间代理的 ip 时，可以作如下修改：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> $proxies = <span class="string">'*'</span>;</span><br></pre></td></tr></table></figure><h2 id="深入问题"><a href="#深入问题" class="headerlink" title="深入问题"></a>深入问题</h2><p>可是问题还是没有得到解决，🤣🤣🤣<br>发现源码中 getClientIp 方法是取得 getClientIps 的第 0 个 ip 地址，那么 getClientIps 方法是可以获取所有的 ip 地址，该方法是从 <code>HTTP_X_FORWARDED_FOR</code> 中拿到所有代理的 ip ，<code>HTTP_X_FORWARDED_FOR</code> 参数是由 nginx 转发时通过 <code>proxy_set_header</code> 添加上去， nginx 的原则是每次在尾部追加代理的ip：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">HTTP_X_FORWARDED_FOR:真实ip,proxy1,proxy2</span><br></pre></td></tr></table></figure><p><strong>BUT</strong> getClientIps 返回的 ip 地址数组却变成了：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">[proxy2,proxy1,真实ip]</span><br></pre></td></tr></table></figure><p>所以 getClientIp 每次获取第 0 个参数其实是最后一个代理的 ip。</p><h2 id="伪解决问题"><a href="#伪解决问题" class="headerlink" title="伪解决问题"></a>伪解决问题</h2><p>我在php的入口函数 index.php 的顶部加入了如下一段：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个很奇怪很奇怪的问题，可能是 laravel5.7  的bug，也可能是 TrustProxies 的 bug ，获取到的IP顺序是反的</span></span><br><span class="line"><span class="keyword">if</span> ($_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>]) &#123;</span><br><span class="line">    $_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>] = implode(<span class="string">','</span>, array_reverse(explode(<span class="string">','</span>, $_SERVER[<span class="string">'HTTP_X_FORWARDED_FOR'</span>])));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序执行到这里的时候我将 <code>HTTP_X_FORWARDED_FOR</code> 中的 ip 进行倒序，getClientIp 拿到的第 0 个 ip 即为真实 ip 。</p><blockquote><p>虽然没有完美解决这个问题，但在使用中也没有发现其他 bug ，如果你有更多发现，欢迎联系我：<code>jake.zou.me@gmail.com</code></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>pay</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel开发碰到的坑</title>
    <url>/p/81b0.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><h2 id="获取-Redis-对象"><a href="#获取-Redis-对象" class="headerlink" title="获取 Redis 对象"></a>获取 Redis 对象</h2><p>最开始是这么脑残的写</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$redis = cache()-&gt;getRedis();</span><br><span class="line">$redis-&gt;hSet($hash, $field, $now);</span><br></pre></td></tr></table></figure><p>然后发现可以这么写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redis::hSet($hash, $field, $now);</span><br></pre></td></tr></table></figure><p>然后会发现如果导错包的话会抛一个异常 <strong>Redis 没有静态方法hSet</strong></p><p>其实只需要将包 <code>\Redis</code> 修改为 <code>use Illuminate\Support\Facades\Redis;</code> 即可</p><h2 id="Eloquent-Builder-中的-find-方法"><a href="#Eloquent-Builder-中的-find-方法" class="headerlink" title="Eloquent Builder 中的 find 方法"></a>Eloquent Builder 中的 find 方法</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">User:find(<span class="number">1</span>)-&gt;where(<span class="string">'status'</span>,<span class="number">1</span>)-&gt;first()</span><br></pre></td></tr></table></figure><p>发现 find方法不生效</p><p>查阅源码之后才发现 find 返回一个 Eloquent 实例或者 Eloquent 实例数组，所以其后的查询条件都不会和前面的查询发生联系，Eloquent 能够用链式查询的魅力在于每个函数都是返回的 $this 也就是 Builder 对象。</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Access-Control-Allow-Credentials</title>
    <url>/p/5f34.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>前后端分离的项目中肯定会碰到跨域的问题，究其原因还是为了安全。我在一个前端工程调试过程中发现，即使我后端已经允许了跨域，但是前端依然报一个跨域错误。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost&#x2F;api&#x2F;admin&#x2F;authorizations&#39; from origin &#39;http:&#x2F;&#x2F;localhost:9528&#39; has been blocked by CORS policy: Response to preflight request doesn&#39;t pass access control check: The value of the &#39;Access-Control-Allow-Credentials&#39; header in the response is &#39;&#39; which must be &#39;true&#39; when the request&#39;s credentials mode is &#39;include&#39;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.</span><br></pre></td></tr></table></figure><p>尝试了很多网上的方法也都没有弄清原因在哪里。索性就仔细研究一下 <code>Access-Control-Allow-Credentials</code> 这个头的作用，果然药到病除。这个是服务端下发到客户端的 response 中头部字段，意义是允许客户端携带验证信息，例如 cookie 之类的。这样客户端在发起跨域请求的时候，不就可以携带允许的头，还可以携带验证信息的头，又由于客户端是请求框架是 axios，并且手残的设置了 <code>withCredentials: true</code>，意思是客户端想要携带验证信息头，但是我的服务端设置是 <code>&#39;supportsCredentials&#39; =&gt; false,</code> ，表示不允许携带信息头，好了，错误找到了。</p><p>我们的客户端和服务端交互的时候使用的是 token，通过 Authorization头发送到服务端，并没有使用到 cookie，所以客户端没有必要设置 <code>withCredentials: true</code>，一顿操作猛如虎🤣🤣。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">mozilla的HTTP访问控制</a></li><li><a href="https://harttle.land/2016/12/28/cors-with-cookie.html" target="_blank" rel="noopener">介绍了跨域中其他的头信息</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>git 批量删除分支</title>
    <url>/p/c93.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch | grep &quot;fix-bug-*&quot; | xargs git branch -d</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>jenkins设置时区为北京时间</title>
    <url>/p/65f0.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><ul><li>方案一</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在【系统管理】-【脚本命令行】里运行</span><br><span class="line">System.setProperty(&#39;org.apache.commons.jelly.tags.fmt.timeZone&#39;, &#39;Asia&#x2F;Shanghai&#39;)</span><br></pre></td></tr></table></figure><p>比较高分的回答，但是方案一是无效的</p><ul><li>方案二</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run ... -e JAVA_OPTS&#x3D;-Duser.timezone&#x3D;Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure><p>没有测试，只要我的容器已经run起来了，不想重新跑一个。</p><ul><li>方案三</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker exec -it --user&#x3D;root laradock_jenkins_1 bash</span><br><span class="line">$ echo &quot;Asia&#x2F;Shanghai&quot; &gt; &#x2F;etc&#x2F;timezone</span><br></pre></td></tr></table></figure><p>方案三 我自己想的，直接改 linux 时区，然后重启即可。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins-docker 第一步</title>
    <url>/p/f123.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>jenkins 一个非常强大的持续集成，自动化部署的解决方案，但是部署起来异常麻烦，但是在这个时代幸好我们有 docker。<br>这篇文章不准备介绍如何安装 docker，如何拉一个 jenkins 镜像然后 run 起来，网上的文章实在太多。</p><p>聊一聊我所理解的更深层的东西，因为是 docker 里面起的 jenkins，那么 jenkins 操作的 shell 执行命令的时候，是无法访问到外界的文件的，除非你挂载一个卷，但是挂载的卷，还必须授予 linux 下为 jenkins user 的访问权限。</p><p>上面的问题都还是可以解决的，但是现在我的 php 代码同样是运行在 docker 中，那么就出现了 php-docker 和 jenkins-docker 是并列的一个关系，我想在 jenkins-docker 中执行 composer 、php artisan 等相关命令，因为根本不在一个空间下，部署构建工程变得尤为困难。</p><p>所以这里又出现了解决方案 <strong>docker-in-docker</strong>，它允许你在容器里再创建容器，但是由于存在重复嵌套等问题，现在已经很少使用。</p><p>新的解决方案是将宿主机的 docker-sock 挂载到 jenkins-docker 内部，所以在 jenkins-docker 内部操作 docker 命令的时候感觉和在外部是一样的。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -v /var/run/docker.sock:/var/run/docker.sock ...</span><br></pre></td></tr></table></figure><p>然而故事并没有这么圆满！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">exec</span> --user root jenkins bash</span><br></pre></td></tr></table></figure><p>这样进入容器，docker 命令是可以正常执行的，但是</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose <span class="built_in">exec</span>  jenkins bash</span><br></pre></td></tr></table></figure><p>这样是不行的，因为默认是以 –user jenkins 进入的，在 jenkins 中的 shell 中也都是 jenkins 用户，一旦执行 docker 等相关操作，立马会报错。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock</span><br></pre></td></tr></table></figure><p>–user jenkins 是没有权限访问到 <code>var/run/docker.sock</code>，折腾一下午，网上很多方法也都是没法用的，因为 docker 容器里面很多命令都被阉割掉了，最终在 github 上面发现了一个简短又适用的命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ chmod 777 /var/run/docker.sock</span><br></pre></td></tr></table></figure><p>完美解决我的问题，特此记录！</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/27208085" target="_blank" rel="noopener">使用 Docker-in-Docker 来运行 CI 或集成测试环境？三思！</a></li><li><a href="https://github.com/jenkinsci/docker/issues/263" target="_blank" rel="noopener">github issues</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>在线视频播放心得</title>
    <url>/p/2e80.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>最近公司准备上一套视频播放的项目，对此我很兴奋，视频播放一直是技术中比较热门板块，并且又是一个比较老的板块。想要一个视频可以成功在网页中播放，我从一个懵逼状态到到真的实现播放总结了如下几个步骤。</p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>正常情况需要有一段可以播放的视频，视频格式其实无所谓， <code>.mp4</code> <code>.avi</code> 都可以，一般保证在上传的时候保证第一手视频是非常清晰的原视频。但是如果视频太大的话就是上传的时候会慢点。由于<a href="https://www.qiniu.com/" target="_blank" rel="noopener">七牛</a>的各项费用我觉得都还不是特步贵，所以依然选择了七牛。这里涉及的其实是七牛的对象存储，七牛对于上传提供两种方式<a href="https://developer.qiniu.com/kodo/manual/1272/form-upload" target="_blank" rel="noopener">表单上传</a>和<a href="https://developer.qiniu.com/kodo/manual/1650/chunked-upload" target="_blank" rel="noopener">分片上传</a>，如果上传的资源文件小于 1gb，前者就行了，如果要使用分片上传最好是使用七牛的 sdk 了。这里我上传资源时后端接口返回到前端一个 token 和 key ，前端直接用 form 上传到七牛就行。</p><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><p>这块其实是我研究很久的一块，<strong>视频为什么需要转码？</strong>这个问题不太好回答，那么接着问自己，<strong>什么是视频？</strong>如果我说视频是一张张连续播放的带着背景音乐的图片可能很多人也不会反对。那肯定会有这样的问题， <strong>什么是图片？</strong>，图片又是一个很有意思的话题，如果以后专门有研究再开篇说图片，计算机世界里面这些视频和图片都是一堆有组织有预谋有规律的文件，前期按照一定的规则进行编码存储，后期按一定的编码打开，其实这里面还少一个阶段那就是现在的互联网时代，还会产生一个从服务端到客户端按一定编码进行传输。</p><p><a href="https://baike.baidu.com/item/视频编码" target="_blank" rel="noopener">百度百科-视频编码</a> 洋洋洒洒几千字，反正最终胜出者是 <code>H.264</code>，这是一个非常了不起的编码标准，它是集编码效率高，占用空间小，清晰度高等多个特性与一身，所以现在世面上大多数视频都是采用了这个标准。目前有个最新编码是 <code>H.265</code>，貌似又是一个非常厉害的编码格式有一统视频编码的趋势，但是由于并非所有浏览器都兼容，所以不得已选择了更为稳健的 <code>H.264</code>，如果时间充裕，后期可以考虑上多个源，前端自由搭配。</p><p>其实转码就是将原视频先解码再编码成合适的视频源，七牛和又拍云上一直提示转码的功能，我开始很懵逼，难道一定需要用他们自家的转码转的视频才能在网页上播放吗，转码到底是为播放准备些什么，不过写到这里问题肯定都是迎刃而解了。公司目前有人负责视频上传，对上传者有转码的培训和要求，所以转码可以在上传前就完成，但是如果播放的时候需要选择多个视频源，要求高清、2k、4k，这时候本地转码就显得效率低下了，使用云转码显然要便捷太多。</p><p>顺便普及一下视频清晰度，网络视频清晰和模糊会取决于多个因素，但是最重要的因为应该是网络带宽与速度、视频的编码以及视频的分辨率。网速暂且不论，编码无非是 <code>H.264</code> 和<code>H.265</code>，那最后的视频分辨率其实是代表视频画面的宽高，标准如下。</p><table><thead><tr><th>分辨率</th><th>别名</th><th>宽高</th></tr></thead><tbody><tr><td>4K</td><td>4K</td><td>3840x2160</td></tr><tr><td>2K</td><td>2K</td><td>2560x1440</td></tr><tr><td>FHD</td><td>1080P、超清</td><td>1920x1080</td></tr><tr><td>HD</td><td>720P、高清</td><td>1280x720</td></tr><tr><td>LD</td><td>-</td><td>960x540</td></tr><tr><td>SD</td><td>标准</td><td>640x480</td></tr></tbody></table><p>分辨率越高视频细节就越丰富，需要传输的内容也就越多。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>通过上面转码后的视频原则上就已经可以支持播放了，但是为什么会有切片这个过程？是因为往往一个 50mb 的视频文件，需要下载完成后才能进行播放，那么下载的过程就让用户白白等待了，为了打破视频下载中不能播放的情况，<code>m3u8</code> 应运而生，简单点说就是对一个特别长的视频进行分块切片，切成一段一段的，最终生成一堆的 .ts 文件和一个 .m3u8 的目录文件，播放视频的时候，只需要接入 m3u8 的地址，播放的时候会自动检索需要下载的片段，这样就完美解决了边下边播的问题了。</p><p>其实这里还想补充一个小插曲，就是放在七牛上的视频，不进行切片也是可以“分片播放”的，这个当时确实有点惊呆了，难道七牛自动给我切片了，还是什么原因，打开 chrome 的控制台，发现浏览器一直在发送 http 请求，返回的结果 http code 都是 206，追寻着这个足迹，又去研究了下什么是 206 请求，原来是七牛服务器做的断点续传，每次请求返回都是源文件的一个片段，客户端这边对这一个片段进行解码播放就 ok 了，我觉得这个也算一个伪切片的功能。</p><h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><p>使用 html5 的 video 标签就可以进行各种视频的播放了,或者 video.js 等其他播放器。如果用到视频加密，可以选择一些定制化视频播放器，视频加密后，通过特殊播放器解密。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="http://www.sohu.com/a/224199309_825275" target="_blank" rel="noopener">H.264和H.265对比</a></li><li><a href="https://blog.csdn.net/xiangzhihong8/article/details/84376103" target="_blank" rel="noopener">H.265/HEVC在Web视频播放的实践</a></li><li><a href="https://www.upyun.com/products/process#section-pricing" target="_blank" rel="noopener">分辨率与视频宽高</a></li><li><a href="https://blog.csdn.net/xiaofei0859/article/details/52883500" target="_blank" rel="noopener">Http 206 文件断点续传下载原理</a></li><li><a href="https://www.bbsmax.com/A/WpdKqqaXJV/" target="_blank" rel="noopener">HTML5 video标签播放视频下载原理</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>视频播放</tag>
      </tags>
  </entry>
  <entry>
    <title>关于go并发的优越性</title>
    <url>/p/aa7b.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>这篇文章本来想好好解释一下 go 并发的优越性，但是看到一个博客讲的实在太好，例子解释的太过清楚，给作者点赞。以前觉得 nodejs 里面的并发是用 async/await 这种形式才是优雅，但是不足之处也很明显，太过于粗粒度控制并发了，go 的并发在手动控制上表现力更强。</p><p>不过 go 里面的 <code>if err !=nil</code> 实在是忍受不了，最近在研究 rust ，上手有点难度🤣。</p><p>参考</p><ul><li><a href="https://juejin.im/entry/5ab893375188251fc32942fe" target="_blank" rel="noopener">用Promise实现并发 vs Go goroutine</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>git checkout 妙用</title>
    <url>/p/4ba1.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>git 上面创建一个分支是 <code>git branch fix-target</code> ，其实这个命令我还测试了一下，因为我已经忘了这个命令，一直使用的 <code>git checkout -b fix-target</code>。</p><p>这个命令优秀之处在于会创建一个分支，并切换到这个分支，但是有时候 <code>fix-target</code> 如果已经存在这个命令就会出错，蠢笨的我已经操作了 <code>git branch -D fix-target</code>，然后<br><code>git checkout -b fix-target</code> 半年了。</p><p>这里一定要注意我这里是强制删除，因为我已经确认我不需要旧分支上任何数据了，就想要个名。</p><p>今天突然发现 <code>git checkout -B fix-target</code>，正是我所想要的。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>七牛数据从一个桶转移到另一个桶</title>
    <url>/p/f6a9.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>因为七牛临时域名的原因，一些老的数据连接都对不上，我们这边需要将一个 bucketA 到另外一个 bucketB 中。操作步骤如下</p><h1 id="下载并-qshell"><a href="#下载并-qshell" class="headerlink" title="下载并 qshell"></a>下载并 qshell</h1><p><a href="https://developer.qiniu.com/kodo/tools/1302/qshell" target="_blank" rel="noopener">七牛官方下载页面</a>下载可执行文件，因为我是 mac ，所以选择 qshell_darwin_x64，找个合适的路径，我的习惯是 $HOME/bin，配置好 PATH。</p><h1 id="设置-account"><a href="#设置-account" class="headerlink" title="设置 account"></a>设置 account</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qshell account AK SK name</span><br></pre></td></tr></table></figure><p>新版本有个 name，老版本是没有的。有找个参数可以更好的作区分。</p><h1 id="列出-bucket"><a href="#列出-bucket" class="headerlink" title="列出 bucket"></a>列出 bucket</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qshell listbucket bucketA -o srccopy.txt</span><br><span class="line"></span><br><span class="line">xx简历.png	500071	FuEnT1v7oou7--ahA5gO1VIy4EHY	15283671101562504	image/png	0</span><br></pre></td></tr></table></figure><p>将 bucket 中的所有文件信息导出，<strong>BUT</strong>，这里我对七牛这点不满意，应该有个参数可以配置可以输出哪些文件信息，一股脑所有信息都抛出来了，但是这里是用 <code>\t</code> 分割的，那么我们做个切分也就 ok 了。</p><h1 id="处理文件列表"><a href="#处理文件列表" class="headerlink" title="处理文件列表"></a>处理文件列表</h1><p>来喽！这里突发奇想，来个 lua 脚本。就是爱折腾<br></p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">split</span><span class="params">( str,reps )</span></span></span><br><span class="line">    <span class="keyword">local</span> resultStrList = &#123;&#125;</span><br><span class="line">    <span class="built_in">string</span>.<span class="built_in">gsub</span>(str,<span class="string">'[^'</span>..reps..<span class="string">']+'</span>,<span class="function"><span class="keyword">function</span> <span class="params">( w )</span></span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(resultStrList,w)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">return</span> resultStrList</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">sourceFile = <span class="built_in">io</span>.<span class="built_in">open</span> (<span class="string">"srccopy.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">toFile = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"tocopy.txt"</span> ,<span class="string">"w"</span>);</span><br><span class="line">y=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> sourceFile:<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">	arr=split(line,<span class="string">"\t"</span>)</span><br><span class="line">	name=arr[<span class="number">1</span>]</span><br><span class="line">	toFile:<span class="built_in">write</span>(name..<span class="string">"\n"</span>)</span><br><span class="line">	y=y+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">sourceFile:<span class="built_in">close</span>()</span><br><span class="line">toFile:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p></p><h1 id="copy-bucket"><a href="#copy-bucket" class="headerlink" title="copy bucket"></a>copy bucket</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qshell batchcopy --force  --failure-list failure-list.txt bucketA bucketB -i tocopy.txt</span><br></pre></td></tr></table></figure><p>处理失败的我们可以记录下来，大部分是文件名已存在，我这里选择不覆盖，如果需要覆盖添加上 <code>--overwrite</code> 参数。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是第一次对 lua 的使用，感觉还挺轻量，以后还可以多使用 lua。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/qiniu/qshell" target="_blank" rel="noopener">qshell</a></li><li><a href="https://blog.csdn.net/forestsenlin/article/details/50590577" target="_blank" rel="noopener">lua切割字符串</a></li><li><a href="https://blog.csdn.net/wangbin_jxust/article/details/11810353" target="_blank" rel="noopener">lua读写文件</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>git-stash的妙用</title>
    <url>/p/a56c.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>今天一路 <code>git stash drop</code>，本地暂存的数据全被我删掉了，然后 sb 的发现，<code>Dropped refs/stash@{0} (534cb702c00f36afd4297e6328557cabead9600c)</code> 是我早上刚写的，难道几百行的代码就没了吗?</p><p>git 里面有个特点，总有 <strong>后悔药</strong>，只要能找到这个 id，肯定就能将数据恢复过来。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash pop 534cb702c00f36afd4297e6328557cabead9600c</span><br><span class="line"><span class="string">'534cb702c00f36afd4297e6328557cabead9600c'</span> is not a stash reference</span><br></pre></td></tr></table></figure><p>不料行不通！</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash apply 534cb702c00f36afd4297e6328557cabead9600c</span><br></pre></td></tr></table></figure><p>果然药到病除！</p><p>从这里也发现 <code>git stash pop</code> 和 <code>git stash apply</code> 是稍微有点区别的，如果 stash-list 里面包含了这个 commit 用法是一样的，否则 apply 可以将不在 stash-list 中的代码恢复到工作区。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>go版本Excel导入脚本</title>
    <url>/p/b6cc.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>一直挺想用 go 的，但是没想到能干啥，前段时间正好有个任务导入 Excel 到后台数据库，用 Python 的话我可能分分钟就写好了，但是作死的我就想试下 go，因为 go 可以打包成可执行程序包，然后就可以不依赖 go 的环境。</p><h1 id="直接编码"><a href="#直接编码" class="headerlink" title="直接编码"></a>直接编码</h1><h2 id="使用-flag-获取终端参数解析"><a href="#使用-flag-获取终端参数解析" class="headerlink" title="使用 flag 获取终端参数解析"></a>使用 flag 获取终端参数解析</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">path := flag.String(<span class="string">"path"</span>, <span class="string">""</span>, <span class="string">"excel 路径"</span>)</span><br><span class="line">url := flag.String(<span class="string">"url"</span>, <span class="string">"**"</span>, <span class="string">"服务器地址"</span>)</span><br><span class="line">flag.Parse()</span><br></pre></td></tr></table></figure><p>这里定义了 path 路径和服务器地址 url，唯一需要注意的是，这里变量返回都是指针。flag 有个好处，他的参数都是形如($key,$defaultValue,$description)，所以在执行 <code>-h</code> 的时候，都会返回 key 以及对应的 description。</p><h2 id="使用-Luxurioust-excelize-读取Excel文件"><a href="#使用-Luxurioust-excelize-读取Excel文件" class="headerlink" title="使用 Luxurioust/excelize 读取Excel文件"></a>使用 Luxurioust/excelize 读取Excel文件</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">xlsx, err := excelize.OpenFile(*path)</span><br><span class="line">rows := xlsx.GetRows(<span class="string">"Sheet1"</span>)</span><br><span class="line"><span class="keyword">for</span> r, row := <span class="keyword">range</span> rows &#123;</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	<span class="keyword">for</span> c, col := <span class="keyword">range</span> row &#123;</span><br><span class="line">		fmt.Println(c)</span><br><span class="line">		fmt.Println(col)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个包用起来还是很舒服，唯一一点只支持 <strong>xlsx</strong> 格式，对于老版本的 <strong>xls</strong> 格式可能需要先转化了才能使用。rows 为一个二维数组，参数为 <strong>sheet</strong> 名称，默认的名称都是 <strong>Sheet1</strong></p><h2 id="使用自带的-net-http-发送请求"><a href="#使用自带的-net-http-发送请求" class="headerlink" title="使用自带的 net/http 发送请求"></a>使用自带的 net/http 发送请求</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str, _ := json.Marshal(data)</span><br><span class="line">resp, err := http.Post(url,</span><br><span class="line">	<span class="string">"application/json"</span>,</span><br><span class="line">	strings.NewReader(<span class="keyword">string</span>(str)))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure><p>go 自带的的 http 就是这么好用，post 形式发送了一个 json 包，这个 jsonEncode 用起来稍微有点不爽但是也还好。</p><h1 id="打包程序"><a href="#打包程序" class="headerlink" title="打包程序"></a>打包程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build  main.go</span><br></pre></td></tr></table></figure><p>就可以将这个脚本打包成一个可执行文件了，但是发现文件还挺大的，我以为只有几百 k 呢，都 8m 多了</p><h1 id="压缩程序"><a href="#压缩程序" class="headerlink" title="压缩程序"></a>压缩程序</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew install upx</span><br><span class="line">$ upx main</span><br></pre></td></tr></table></figure><p><a href="https://upx.github.io/" target="_blank" rel="noopener">upx</a> 是一个专门的压缩打包可执行文件的程序，可以优化包体积。</p><blockquote><p>这里压缩过的包不能使用了，暂时没有深究什么原因。所以寻找其他方式</p></blockquote><h1 id="再次优化"><a href="#再次优化" class="headerlink" title="再次优化"></a>再次优化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go build -ldflags -w main.go</span><br></pre></td></tr></table></figure><p>发现这样弄就可以减少 1m 的体积，还是挺可观的，现在有一个可执行文件了，不用对方有 golang 环境，拿过去直接可以运行跑起来。go 就是优秀！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://studygolang.com/articles/9811" target="_blank" rel="noopener">Golang 读写 Excel</a></li><li><a href="https://www.jianshu.com/p/cd3c766b893c" target="_blank" rel="noopener">压缩go build打包的可执行文件</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>关于浏览器的强制刷新</title>
    <url>/p/7a43.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>经常出现浏览器将js缓存的问题</p><h1 id="Chrome-浏览器"><a href="#Chrome-浏览器" class="headerlink" title="Chrome 浏览器"></a>Chrome 浏览器</h1><p>Windows：Shift+F5</p><p>Linux: Ctrl+Shift+R</p><p>Mac OS: Cmd+Shft+R</p><h1 id="Safari浏览器"><a href="#Safari浏览器" class="headerlink" title="Safari浏览器"></a>Safari浏览器</h1><p>Cmd+Option+R</p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>关于授权和认证</title>
    <url>/p/ec56.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>昨天看到一篇博客专门提到 *<em>认证 VS 授权 *</em> 。</p><ol><li>名字不同，认证 （Authentication） 和 授权 （Authorization）</li><li>认证需要输入用户名和密码，授权指需要授权服务提供给当前服务若干权限从而请求确认</li><li>HTTP状态码中有 <code>401</code> 和 <code>403</code> 都表示无权访问当前资源，<code>401</code> 表示则表示没有「认证」，<code>403</code> 表示没有『授权』</li></ol><p>参考</p><blockquote><ul><li><a href="https://laravel-china.org/articles/3869/one-minute-to-clear-authentication-and-authorization" target="_blank" rel="noopener">一分钟讲清楚 Authentication 和 Authorization</a></li></ul></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Laravel中的队列执行过慢</title>
    <url>/p/a1bc.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>本来不想水的，公司的白先生硬要我水一篇，那就简单记录一下。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>上周，系统出现了一个很要命的问题，后端用的 laravel 队列执行导表任务异常缓慢，以前几分钟就能出的报告，几个小时都没动静，因为业务需要，每次用户观看视频都需要计算一些非常耗时的任务。</p><h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p>后来调查尝试也确实是这块出了问题，laravel 文档中介绍了队列的优先级，提到参数顺序的问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ php artisan queue:work --queue=high,low</span><br></pre></td></tr></table></figure><p><code>--queue</code> 为队列的名称，参数用 <code>,</code> 分割，排的越靠前优先级越高。所以将越耗时的任务的优先级设置越低，将位置设置越靠后就好了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>所以如果系统中存在耗时任务，造成整个队列都被卡住，应该按预计的执行耗时排序，将越耗时的任务提到越靠后的位置，这样就可以解决执行时间较短的任务优先执行</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><ul><li><a href="https://laravel-china.org/docs/laravel/5.7/queues/2286#queue-priorities" target="_blank" rel="noopener">队列优先级</a></li></ul></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会用postman吗</title>
    <url>/p/ce3e.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p><a href="https://www.getpostman.com" target="_blank" rel="noopener">postman</a> 一个非常牛逼的 api 测试工具。如果仅仅是打个 api，还不如直接 curl 来的简单，所以这里提供一些高级的功能的参考。</p><h2 id="多级文件夹"><a href="#多级文件夹" class="headerlink" title="多级文件夹"></a>多级文件夹</h2><p>经常需要将 api 进行按功能模块进行分组，这种多级文件夹的形式正好可以满足我的需求，某个功能每个 api 一目了然。</p><h2 id="多种请求方法"><a href="#多种请求方法" class="headerlink" title="多种请求方法"></a>多种请求方法</h2><p>postman 有多达 <strong>15</strong> 种请求方法供选择，常用 GET、POST、PUT、DELET更是切换起来异常的方便。</p><h2 id="URL-参数拼接"><a href="#URL-参数拼接" class="headerlink" title="URL 参数拼接"></a>URL 参数拼接</h2><p>这里说的并不是简单的参数拼接 <code>a=b&amp;</code> 这种，而是比较高级的参数拼接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&#123;&#123;host&#125;&#125;&#x2F;api&#x2F;topics&#x2F;:tid&#x2F;replies&#x2F;:rid</span><br></pre></td></tr></table></figure><p>然后在底下就可以补全 <code>tid</code> 和 <code>rid</code> 就可以了。</p><h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><p>授权可以通过常规的在请求 <code>Headers</code> 中添加 <code>&quot;Authorization: balabala&quot;</code>，但是 postman 更为方便的是有个专门的 <strong>Authorization</strong> 的 Tab，切换到这个 Tab 下面有多种通用的授权模式，譬如 <code>Basic Auth</code> 、<code>Bearer Token</code> 、<code>OAuth 2.0</code> 等，这里postman会自动添加相关信息到头或者 url 中。</p><h2 id="Manage-Environment"><a href="#Manage-Environment" class="headerlink" title="Manage Environment"></a>Manage Environment</h2><p>这个功能非常实用，相当于全局定义的常量。譬如线下环境的域名是 <code>dev-api.zoulux.top</code> ，线上环境的域名是 <code>api.zoulux.top</code>，那么这边新建两个 <code>Environment</code> ，分别配置 host 为上面域名，然后在所有的接口上就可以实用如下方式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&#123;&#123;host&#125;&#125;&#x2F;api&#x2F;topics&#x2F;:tid&#x2F;replies&#x2F;:rid</span><br></pre></td></tr></table></figure><p>很简单的就可以切换线上线下环境了，不仅可以配置 host ，很多公司线上线下接口的 secret 也不一样，都可以在不同的 <code>Environment</code> 中配置。</p><h2 id="Pre-request-Script"><a href="#Pre-request-Script" class="headerlink" title="Pre-request Script"></a>Pre-request Script</h2><p>如果上面定义的是全局常量，那么这里可以说是可以定义局部变量，注意这里说的是「可以」，所以功能肯定远远不止如此，此处的 <code>Script</code> 是一个 <code>JavaScript</code> 脚本。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>譬如后端要求前端每次打接口将本地的 <strong>timestamp</strong> 拼接到接口里面接口里面</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ts=<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">pm.environment.set(<span class="string">"timestamp"</span>, ts);</span><br></pre></td></tr></table></figure><p><code>pm</code> 是 <code>postman</code> 提供的全局变量，可以用于设置局部变量，那么在 Params 的 Tab 下面就可以直接使用 timestamp 变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timestamp : &#123;&#123;timestamp&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>在对接百家云的时候，他们的接口是需要签名的，接口规则还蛮复杂，这里需要接口按 key 排序，还需要加密，这里是 js 的脚本，排序就用原生的 js 就能完成，但是还需要对 md5 加密，这就为难我胖虎了，不过 postman 早就考虑到加密的情况，所以默认已经引入了一些常用 package，CryptoJS中有丰富加密方法。</p><h2 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h2><p>这个模块可以对接口的进行测试，譬如</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.test(<span class="string">"Status code is 200"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pm.response.to.have.status(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以查看接口返回的 <strong>status</strong> 是否是 200 。</p><h2 id="api文档"><a href="#api文档" class="headerlink" title="api文档"></a>api文档</h2><p>在左侧的工程目录上右键选择 <strong>Publish Docs</strong>，会弹出一个网页，点过去就可以看到一个很精美的api文档，如果平时注意多注释，文档里面都会显示出来，更加优秀的是这个api文档是实时更新的，有新的api的时候刷新就可以看到了。</p><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>其实 postman 还有很多优秀的功能，值得我去探究。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><p><a href="http://dev.baijiayun.com/default/wiki/detail/11#h0-5" target="_blank" rel="noopener">百家云接口签名</a></p><p><a href="https://www.getpostman.com/docs/v6/postman/scripts/postman_sandbox" target="_blank" rel="noopener">Commonly used libraries and utilities</a></p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>postman</tag>
      </tags>
  </entry>
  <entry>
    <title>视频日志记录</title>
    <url>/p/1b7c.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>视频记录是一件很麻烦的事情，之前是将一段视频十等分，学生每看完其中的一等分，在用户做相关操作的时候就会上传其中的几等分视频记录，相关操作包括：</p><ul><li>暂停视频</li><li>观看下节视频</li><li>拖动视频</li><li>关闭当前页面</li></ul><h1 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h1><p>调查了一下几个视频网站的记录方式，如下：</p><h2 id="优酷"><a href="#优酷" class="headerlink" title="优酷"></a>优酷</h2><p>log 接口 ： <code>http://yt1.mmstat.com/yt/vp.vtslog</code></p><p>发送频率： <code>5</code> 秒</p><p>body 日志 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: 0.5.78</span><br><span class="line">vid: 969664681</span><br><span class="line">uid: </span><br><span class="line">type: h5</span><br><span class="line">cf: 0</span><br><span class="line">cpt: 2</span><br><span class="line">full: 0</span><br><span class="line">pc: 0</span><br><span class="line">clb: 0</span><br><span class="line">playersid: 15408798967661cr1pik5u2fq2bZZx0WzQhD9</span><br><span class="line">abtest: b</span><br><span class="line">clientid: 125272a7921189a8</span><br><span class="line">iku: 125272a7921189a8</span><br><span class="line">sn: 1</span><br><span class="line">pt: 5</span><br><span class="line">hi: 5</span><br><span class="line">vvid: 8004d7c2ba930b672821e47ccf0bb8b7</span><br><span class="line">lang: 1</span><br><span class="line">r: 756681157</span><br><span class="line">cna: RSZYFOyl3CYCAWVR4r76Xboc</span><br><span class="line">speed: 1</span><br></pre></td></tr></table></figure><h2 id="腾讯视频"><a href="#腾讯视频" class="headerlink" title="腾讯视频"></a>腾讯视频</h2><p>log 接口 ： <code>https://apd-be31beb59d7da6eff28fb4bb69f24c0d.v.smtcdns.com/varietyts.tc.qq.com</code></p><p>发送频率： 不定时发送，打包一起发送</p><p>body 日志 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index: 23</span><br><span class="line">start: 241560</span><br><span class="line">end: 251560</span><br><span class="line">brs: 24702636</span><br><span class="line">bre: 25256859</span><br><span class="line">ver: 4</span><br></pre></td></tr></table></figure><h2 id="Bilibili"><a href="#Bilibili" class="headerlink" title="Bilibili"></a>Bilibili</h2><p>log 接口 ： <code>https://api.bilibili.com/x/report/web/heartbeat</code></p><p>发送频率： <code>15</code> 秒</p><p>body 日志 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aid: 34926550</span><br><span class="line">cid: 61188917</span><br><span class="line">mid: </span><br><span class="line">csrf: </span><br><span class="line">played_time: 139</span><br><span class="line">realtime: 139</span><br><span class="line">start_ts: 1540881600</span><br><span class="line">type: 3</span><br><span class="line">dt: 2</span><br><span class="line">play_type: 0</span><br></pre></td></tr></table></figure><h2 id="爱奇艺"><a href="#爱奇艺" class="headerlink" title="爱奇艺"></a>爱奇艺</h2><p>log 接口 ： <code>https://sb.scorecardresearch.com/p</code></p><p>发送频率： <code>10</code> 秒</p><p>body 日志：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c1: 2</span><br><span class="line">c2: 26181340</span><br><span class="line">ns_type: hidden</span><br><span class="line">ns_st_sv: 6.1.0.170130</span><br><span class="line">ns_st_smv: 5.8</span><br><span class="line">ns_st_it: r</span><br><span class="line">ns_st_id: 1540882415279</span><br><span class="line">ns_st_ec: 2</span><br><span class="line">ns_st_sp: 1</span><br><span class="line">ns_st_sc: 1</span><br><span class="line">ns_st_psq: 1</span><br><span class="line">ns_st_asq: 1</span><br><span class="line">ns_st_sq: 1</span><br><span class="line">ns_st_ppc: 1</span><br><span class="line">ns_st_apc: 1</span><br><span class="line">ns_st_spc: 1</span><br><span class="line">ns_st_cn: 1</span><br><span class="line">ns_st_ev: pause</span><br><span class="line">ns_st_po: 86868</span><br><span class="line">ns_st_cl: 5997951</span><br><span class="line">ns_st_mp: js_api</span><br><span class="line">ns_st_mv: 6.1.0.170130</span><br><span class="line">ns_st_pn: 1</span><br><span class="line">ns_st_tp: 0</span><br><span class="line">ns_st_ci: 1462694600</span><br><span class="line">ns_st_pt: 86868</span><br><span class="line">ns_st_dpt: 86868</span><br><span class="line">ns_st_ipt: 26853</span><br><span class="line">ns_st_et: 86868</span><br><span class="line">ns_st_det: 86868</span><br><span class="line">ns_st_upc: 86868</span><br><span class="line">ns_st_dupc: 86868</span><br><span class="line">ns_st_iupc: 26853</span><br><span class="line">ns_st_upa: 86868</span><br><span class="line">ns_st_dupa: 86868</span><br><span class="line">ns_st_iupa: 26853</span><br><span class="line">ns_st_lpc: 86868</span><br><span class="line">ns_st_dlpc: 86868</span><br><span class="line">ns_st_lpa: 86868</span><br><span class="line">ns_st_dlpa: 86868</span><br><span class="line">ns_st_pa: 86868</span><br><span class="line">ns_ts: 1540882532281</span><br><span class="line">ns_st_bc: 0</span><br><span class="line">ns_st_dbc: 0</span><br><span class="line">ns_st_bt: 0</span><br><span class="line">ns_st_dbt: 0</span><br><span class="line">ns_st_bp: 0</span><br><span class="line">ns_st_skc: 0</span><br><span class="line">ns_st_dskc: 0</span><br><span class="line">ns_st_ska: 0</span><br><span class="line">ns_st_dska: 0</span><br><span class="line">ns_st_skd: 0</span><br><span class="line">ns_st_skt: 0</span><br><span class="line">ns_st_dskt: 0</span><br><span class="line">ns_st_pc: 1</span><br><span class="line">ns_st_dpc: 1</span><br><span class="line">ns_st_pp: 1</span><br><span class="line">ns_st_br: 0</span><br><span class="line">ns_st_rt: 100</span><br><span class="line">ns_st_ub: 0</span><br><span class="line">ns_st_ki: 1200000</span><br><span class="line">ns_st_pr: 声林之王之林宥嘉萧敬腾1对1指导学员 巫启贤女儿唱约翰丹佛名作</span><br><span class="line">ns_st_sn: *null</span><br><span class="line">ns_st_en: 1</span><br><span class="line">ns_st_ep: 声林之王之林宥嘉萧敬腾1对1指导学员 巫启贤女儿唱约翰丹佛名作</span><br><span class="line">ns_st_ct: vc12</span><br><span class="line">ns_st_ge: 港台,音乐,真人秀</span><br><span class="line">ns_st_st: iqiyi</span><br><span class="line">ns_st_ce: 1</span><br><span class="line">ns_st_ia: 0</span><br><span class="line">ns_st_ddt: *null</span><br><span class="line">ns_st_tdt: *null</span><br><span class="line">ns_st_pu: *null</span><br><span class="line">c3: *null</span><br><span class="line">c4: 6</span><br><span class="line">c6: *null</span><br><span class="line">c7: https:&#x2F;&#x2F;www.iqiyi.com&#x2F;v_19rr6haox0.html</span><br><span class="line">c8: 声林之王之林宥嘉萧敬腾1对1指导学员 巫启贤女儿唱约翰丹佛名作-综艺-高清正版视频在线观看–爱奇艺</span><br><span class="line">c9: https:&#x2F;&#x2F;www.iqiyi.com&#x2F;</span><br></pre></td></tr></table></figure><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><h2 id="定时日志"><a href="#定时日志" class="headerlink" title="定时日志"></a>定时日志</h2><p>上述的几个平台中除了 <strong>爱奇艺</strong> 传的数据太多，其他都很精简，总结一下关键信息我准备设计成如下几个字段：</p><ul><li>视频id</li><li>当前用户id</li><li>定时上传次数 index</li><li>随机数 random</li><li>视频开始位置</li><li>视频结束位置</li><li>开始时间戳</li><li>结束时间戳</li><li>播放倍速</li><li>播放设备平台</li><li>日志类型 ：timing</li></ul><p>日志包整理好了，就看日志日志发送频率了，除了<em>腾讯视频</em> 应该是有专门收集日志，有个统一的触发机制，一次性发送了多条日志，其他网站都是以单位时间的频率发送给服务端，考虑到实施的简便性，综合几个发送频率，暂定频率为 <code>10</code> 秒。随机数 <code>random</code> 每次打开视频都刷新，可以区分不同的 <code>log</code> 的日志链，定时上传次数 <code>index</code> 可以检查一段 <code>log</code> 的完整性。</p><p>我们的单个视频平均时长在<code>15分钟</code>,那么如果有一次发送log日志失败对总体进度影响是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 * 60 &#x3D;900 s</span><br><span class="line">10 &#x2F; 900 &#x3D; 0.011111111 &#x3D; 1.11%</span><br></pre></td></tr></table></figure><p>为了一次日志失败对总体进度的影响，所以频率确定为 <code>5</code> 秒，但是相对来说，数据库的需要的储存空间也需要扩大一倍</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 * 60 &#x3D;900 s</span><br><span class="line">5 &#x2F; 900 &#x3D; 0.005555556 &#x3D; 0.56%</span><br></pre></td></tr></table></figure><p>单条数据丢失对整体影响也直接降低一半。</p><h2 id="操作日志"><a href="#操作日志" class="headerlink" title="操作日志"></a>操作日志</h2><p>上面的几家平台都有做操作日志的记录，这里唯一添加一个 <code>random</code> 字段，取值和定时日志每次生成的随机值相同，这里操作日志分为以下几类</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：start</li></ul><h3 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：pause</li></ul><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：complete</li></ul><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：exit</li></ul><h3 id="拖动"><a href="#拖动" class="headerlink" title="拖动"></a>拖动</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>视频原有位置</li><li>视频现有位置</li><li>时间戳</li><li>播放设备平台</li><li>日志类型 ：drag</li></ul><h3 id="倍速"><a href="#倍速" class="headerlink" title="倍速"></a>倍速</h3><ul><li>视频id</li><li>当前用户id</li><li>随机数 random</li><li>视频原有倍速</li><li>视频现有倍速</li><li>时间戳</li><li>视频位置</li><li>播放设备平台</li><li>日志类型 ：speed</li></ul><h1 id="实施"><a href="#实施" class="headerlink" title="实施"></a>实施</h1><ol><li>客户端每次将日志发送到服务端</li><li>如果成功，则本次日志提交结束</li><li>如果失败，则客户端需要将日志存储在本地</li><li>等待时机合适，重新提交日志</li><li>如果成功，删除本地存储日志，本次日志提交结束</li><li>如果失败，重复第 <code>4</code> 步</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上几个有趣的命令（一）</title>
    <url>/p/a074.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>首先我是一个 Mac 党，但是对于 Linux 也尤为喜爱，他们上面有那么一些命令总是那么饶有趣味，又由于都是类 Unix 系统，很多命令都是通用的，本文的代码也都是在 Mac 上面完成</p><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>一个大名鼎鼎的命令，作为一个程序员，如果 <code>curl</code> 都不知道，那就真的很尴尬，主要是做网络请求</p><h3 id="直接返回下载文件内容到终端"><a href="#直接返回下载文件内容到终端" class="headerlink" title="直接返回下载文件内容到终端"></a>直接返回下载文件内容到终端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下载文件到指定文件"><a href="#下载文件到指定文件" class="headerlink" title="下载文件到指定文件"></a>下载文件到指定文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl baidu.com -o baidu.html</span><br><span class="line">$ cat baidu.html</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="下载文件到默认文件"><a href="#下载文件到默认文件" class="headerlink" title="下载文件到默认文件"></a>下载文件到默认文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl https://nodejs.org/dist/v8.12.0/node-v8.12.0.pkg -O</span><br><span class="line">$ ls node-v8.12.0.pkg</span><br><span class="line">node-v8.12.0.pkg</span><br></pre></td></tr></table></figure><h3 id="查看返回头信息"><a href="#查看返回头信息" class="headerlink" title="查看返回头信息"></a>查看返回头信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -i baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Sat, 20 Oct 2018 14:30:47 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 81</span><br><span class="line">Cache-Control: max-age&#x3D;86400</span><br><span class="line">Expires: Sun, 21 Oct 2018 14:30:47 GMT</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="查看请求的整个过程"><a href="#查看请求的整个过程" class="headerlink" title="查看请求的整个过程"></a>查看请求的整个过程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -v baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Rebuilt URL to: baidu.com&#x2F;</span><br><span class="line">*   Trying 123.125.115.110...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to baidu.com (123.125.115.110) port 80 (#0)</span><br><span class="line">&gt; GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl&#x2F;7.54.0</span><br><span class="line">&gt; Accept: *&#x2F;*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP&#x2F;1.1 200 OK</span><br><span class="line">&lt; Date: Sat, 20 Oct 2018 14:40:22 GMT</span><br><span class="line">&lt; Server: Apache</span><br><span class="line">&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">&lt; ETag: &quot;51-47cf7e6ee8400&quot;</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: 81</span><br><span class="line">&lt; Cache-Control: max-age&#x3D;86400</span><br><span class="line">&lt; Expires: Sun, 21 Oct 2018 14:40:22 GMT</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Type: text&#x2F;html</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv&#x3D;&quot;refresh&quot; content&#x3D;&quot;0;url&#x3D;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">* Connection #0 to host baidu.com left intact</span><br></pre></td></tr></table></figure><h3 id="发送-Post-请求"><a href="#发送-Post-请求" class="headerlink" title="发送 Post 请求"></a>发送 Post 请求</h3><h4 id="不带参数"><a href="#不带参数" class="headerlink" title="不带参数"></a>不带参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST baidu.com</span><br></pre></td></tr></table></figure><h4 id="form形式"><a href="#form形式" class="headerlink" title="form形式"></a>form形式</h4><p>将以 <code>Content-Type: application/x-www-form-urlencoded</code> 形式提交</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -d <span class="string">'a=b'</span> baidu.com</span><br></pre></td></tr></table></figure><h4 id="json形式"><a href="#json形式" class="headerlink" title="json形式"></a>json形式</h4><p>将以 <code>Content-Type: application/json</code> 形式提交</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST baidu.com -H <span class="string">'content-type: application/json'</span> -d <span class="string">'&#123;"a":"b"&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="发送其他-method-请求"><a href="#发送其他-method-请求" class="headerlink" title="发送其他 method 请求"></a>发送其他 method 请求</h3><p>如果你们公司也在用 <code>restful api</code> ，很幸运的是 <code>curl</code> 会是一个好帮手</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X GET baidu.com</span><br><span class="line">$ curl -X POST baidu.com</span><br><span class="line">$ curl -X PUT baidu.com</span><br><span class="line">$ curl -X DELETE baidu.com</span><br></pre></td></tr></table></figure><h3 id="发送带自定义-header-请求"><a href="#发送带自定义-header-请求" class="headerlink" title="发送带自定义 header 请求"></a>发送带自定义 header 请求</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -X POST -H <span class="string">'custom-key: custom-value'</span> baidu.com</span><br></pre></td></tr></table></figure><h3 id="查看当前-ip"><a href="#查看当前-ip" class="headerlink" title="查看当前 ip"></a>查看当前 ip</h3><p>这算是一个非常实用的技巧了，因为我这里开了代理，所以网络 ip 显示的是美国</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl ip.cn</span><br><span class="line">当前 IP：138.128.193.*** 来自：美国</span><br></pre></td></tr></table></figure><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p><code>ping(packet internet groper)</code>通过发送<code>icmp(internet control messages protocol)</code>协议包查看当前机器和目标机器的连通性，mac上面如果不指定 <code>ping</code> 次数，则会一直执行</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping baidu.com</span><br></pre></td></tr></table></figure><p>ctrl-c 强行停止</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING baidu.com (123.125.115.110): 56 data bytes</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;0 ttl&#x3D;55 time&#x3D;111.843 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;113.706 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;26.261 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;3 ttl&#x3D;55 time&#x3D;25.522 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;4 ttl&#x3D;55 time&#x3D;26.935 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过 <code>-c</code> 指定执行次数</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ping  -c3 baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING baidu.com (123.125.115.110): 56 data bytes</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;0 ttl&#x3D;55 time&#x3D;232.282 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;1 ttl&#x3D;55 time&#x3D;44.364 ms</span><br><span class="line">64 bytes from 123.125.115.110: icmp_seq&#x3D;2 ttl&#x3D;55 time&#x3D;38.667 ms</span><br><span class="line"></span><br><span class="line">--- baidu.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0.0% packet loss</span><br><span class="line">round-trip min&#x2F;avg&#x2F;max&#x2F;stddev &#x3D; 38.667&#x2F;105.104&#x2F;232.282&#x2F;89.958 ms</span><br></pre></td></tr></table></figure><p>执行结束会一段对本次所以请求的汇报，发送了多少次包，多少返回了，多少丢失了，<code>round-trip time</code> 时间 <strong>最短/平均/最长/标准差</strong></p><h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p><code>traceroute</code> 其实也是发送 <code>icmp</code> 协议报文查看到达目标 <code>ip</code> 中间经过所有的路由信息</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ traceroute www.baidu.com</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">traceroute: Warning: www.baidu.com has multiple addresses; using 61.135.169.121</span><br><span class="line">traceroute to www.a.shifen.com (61.135.169.121), 64 hops max, 52 byte packets</span><br><span class="line"> 1  * * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  * * *</span><br><span class="line"> 4  * * *</span><br></pre></td></tr></table></figure><p>尴尬的是后面直接星号了，因为大多数网关都禁止对 <code>icmp</code> 报文作出响应</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>开发笔记</category>
      </categories>
  </entry>
  <entry>
    <title>定制博客</title>
    <url>/p/4e.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>虽然默认的 next 主题已经很美了，但是网上有一堆对 next 进行定制的教程，本着优雅不炫技的原则，我对博客作了以下简单的优化：</p><h3 id="添加-hexo-admin-插件"><a href="#添加-hexo-admin-插件" class="headerlink" title="添加 hexo-admin 插件"></a>添加 hexo-admin 插件</h3><p><a href="https://github.com/jaredly/hexo-admin" target="_blank" rel="noopener">hexo-admin</a> 为一套hexo 博客管理工具，我准备将博客的开发环境也部署到服务器上，这样就不用开本地环境，有了它就可以在线编辑博客了，非常方便。</p><ol><li><p>安装依赖库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-admin</span><br></pre></td></tr></table></figure></li><li><p>启动本地博客，并在浏览器打开</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s </span><br><span class="line">$ open http://localhost:4000/admin</span><br></pre></td></tr></table></figure></li><li><p>如果不出错的话 admin 界面就已经展现在眼前，但是很多时候想配置账户密码去登录到这个管理后台，就需要接着配置</p></li><li><p>在 admin 的界面 ,前往<code>Settings &gt;Setup authentification</code> 可以看到<code>Username,Password,Secret</code> ，输入自己心仪的账户密码以及秘钥，拷贝 <code>hexo-admin authentification</code> 下的内容</p></li><li><p>在博客根目录下的 <code>_config.yml</code> 最底下粘贴如下配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">admin:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">password_hash:</span> <span class="string">$2a$10$L.XAIqIWgTc5S1zpvV3MEu7/rH34p4Is/nq824smv8EZ3lIPCp1su</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">wobuhuigaosunide</span></span><br></pre></td></tr></table></figure></li><li><p>重新执行第 <code>2</code> 步，发现这时候已经需要登录，输入配置中的账号和密码即可</p></li></ol><h3 id="添加-分类-和-标签"><a href="#添加-分类-和-标签" class="headerlink" title="添加 分类 和 标签"></a>添加 <strong>分类</strong> 和 <strong>标签</strong></h3><p>每篇文章可以有一个分类和多个标签，这也是分类和标签的最大的区别。</p><h4 id="创建-分类-选项"><a href="#创建-分类-选项" class="headerlink" title="创建 分类 选项"></a>创建 <strong>分类</strong> 选项</h4><ol><li><p>生成 <strong>分类</strong> 页并添加属性<code>type</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></li><li><p>找到上面提示的 <code>index.md</code> 文件路径 ，打开发现是这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-10-17 00:33:17</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>将其修改为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2018-10-17 00:33:17</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>博客根目录下依次打开 <code>source &gt;_post</code> 找一篇博客打开，顶部有一些文章的配置信息，为 <code>categories</code> 字段添加属性</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="string">3eeb</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">随笔</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-10</span><span class="number">-15</span> <span class="number">16</span><span class="string">:27:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p>一篇文章只有一个分类，如果需要二级分类的话可以如下修改，可以参考<a href="https://hexo.io/zh-cn/docs/front-matter#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">hexo 分类和标签</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="string">3eeb</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">[]</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">web开发</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ruby</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-10</span><span class="number">-15</span> <span class="number">16</span><span class="string">:27:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="创建-标签-选项"><a href="#创建-标签-选项" class="headerlink" title="创建 标签 选项"></a>创建 <strong>标签</strong> 选项</h4><ol><li><p>生成 <strong>标签</strong> 页并添加属性<code>type</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure></li><li><p>找到上面提示的 <code>index.md</code> 文件路径 ，打开发现是这样</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2018-10-20 14:33:17</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>将其修改为</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2018-10-20 14:33:17</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>博客根目录下依次打开 <code>source &gt;_post</code> 找一篇博客打开，顶部有一些文章的配置信息，为 <code>tags</code> 字段添加属性</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">Hello</span> <span class="string">World</span></span><br><span class="line"><span class="attr">abbrlink:</span> <span class="string">3eeb</span></span><br><span class="line"><span class="attr">tags:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-admin</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">随笔</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018</span><span class="number">-10</span><span class="number">-15</span> <span class="number">16</span><span class="string">:27:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></li><li><p>打开上面的文章底部，就可以看到标签</p><p><img src="/images/material/WechatIMG51504.png" alt="标签"></p></li></ol><h3 id="添加加载进度条"><a href="#添加加载进度条" class="headerlink" title="添加加载进度条"></a>添加加载进度条</h3><p>修改 <code>pace: true</code> 并设置自己喜欢的 <code>pace_theme</code>，可以每个都测试一下</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">pace_theme:</span> <span class="string">pace-theme-flash</span></span><br></pre></td></tr></table></figure><h3 id="添加赞赏"><a href="#添加赞赏" class="headerlink" title="添加赞赏"></a>添加赞赏</h3><ol><li><p>修改自己的微信或者支付宝的图片</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward</span></span><br><span class="line"><span class="attr">reward_comment:</span> <span class="string">坚持原创技术分享，您的支持将鼓励我继续创作！</span></span><br><span class="line"><span class="comment">#wechatpay: /images/wechatpay.jpg</span></span><br><span class="line"><span class="attr">alipay:</span> <span class="string">/images/alipay.png</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure></li><li><p>但是打开发现赞赏的按钮上面的文字是 <code>Donate</code>,看着很奇怪，编辑 <code>themes/next/layout/_macro/reward.swig</code> 文件中第 4 行，将 <code>Donate</code> 修改为 <code>赏</code></p></li></ol><h3 id="首页文章添加阅读全文"><a href="#首页文章添加阅读全文" class="headerlink" title="首页文章添加阅读全文"></a>首页文章添加阅读全文</h3><p>阅读原文有两种方法可以实现，一种是自动，根据文字长度自动切割，另一种是手动的，添加 <code>more</code> 标签，则此标签以下就会被隐藏掉</p><ol><li><p>自动，编辑 <code>_config.yml</code>，指定文字长度，默认是150</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure></li><li><p>手动，打开任意文章，在文章的任意行插入 <code>&lt;!-- more --&gt;</code> 观察效果</p></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>自定义GitHubPages的域名</title>
    <url>/p/a916.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><p>今天在配置 githubpages 自定义域名的时候怎么也连不通，通过搜素发现需要在 git 项目根目录下<code>setting</code>，配置<code>Custom domain</code>为自己的自定义域名，这时 github 配置了一个临时的<em>CNAME</em>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>重新部署之后，github 又会将<code>Custom domain</code>置为空，所以找到最终结局方法，在 hexo 项目的<code>source</code>目录下添加 <code>CNAME</code> 的文件，文件内容为自定义的域名：如 <code>blog.zoulux.top</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅的删除git子模块</title>
    <url>/p/b63b.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><ol><li><p>git submodule deinit $mod // 逆初始化</p></li><li><p>git rm –cached $mode // 删除子模块缓存信息</p></li><li><p>git commit -am “Remove a $mode.” // 提交更改</p></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/p/3eeb.html</url>
    <content><![CDATA[<!-- build time:Wed Sep 30 2020 18:20:37 GMT+0800 (China Standard Time) --><h1 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome"></a>Welcome</h1><p>欢迎来到我的博客，希望我能勤快点，每周一更！</p><p>每学一门新语言的时候，我们总是希望能在控制台中快速输出<code>Hello world</code>，这次也不理外。</p><p>世界，你好，我来了！</p><blockquote><p>业精于勤荒于嬉，行成于思毁于随。共勉！</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
